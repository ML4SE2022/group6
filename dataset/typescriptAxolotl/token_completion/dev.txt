<s> import { <EOL> ValidationMessagesService , <EOL> ValidationMessagesConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> NgModule <EOL> } from '<STR_LIT>' ; <EOL> @ NgModule ( ) export class ValidationModule { <EOL> errorMessages : ValidationMessagesConfig = { <EOL> email : '<STR_LIT>' , <EOL> length : '<STR_LIT>' , <EOL> max : '<STR_LIT>' , <EOL> maxlength : '<STR_LIT>' , <EOL> min : '<STR_LIT>' , <EOL> minlength : '<STR_LIT>' , <EOL> required : '<STR_LIT>' , <EOL> notInteger : '<STR_LIT>' , <EOL> toManyDecimalPlaces : '<STR_LIT>' , <EOL> isGreaterThanLowerBound : '<STR_LIT>' , <EOL> pattern : { <EOL> message : '<STR_LIT>' , <EOL> validatorValue : '<STR_LIT>' , <EOL> pattern : '<STR_LIT>' <EOL> } <EOL> } ; constructor ( private validationMessageService ) { <EOL> this . validationMessageService . setValidationMessages ( this . errorMessages ) ; <EOL> } <EOL> } </s>
<s> import React , { <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> format , <EOL> parse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Draggable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FaCalendar , <EOL> FaTrash <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TaskColor <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Heading <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DialogConfirm <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> useBoardContext <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> type Props = { <EOL> taskId : number ; onClick ( ) : void ; index : number ; <EOL> } ; <EOL> export const TaskCard = ( { <EOL> taskId , <EOL> onClick , <EOL> index <EOL> } ) = > { <EOL> const [ promptRemove , setPromptRemove ] = useState ( false ) ; <EOL> const { <EOL> getTask , <EOL> removeTask <EOL> } = useBoardContext ( ) ; <EOL> const task = getTask ( taskId ) ; <EOL> function handleKeydown ( event ) { <EOL> if ( promptRemove ) return ; <EOL> if ( event . key == = '<STR_LIT>' ) setPromptRemove ( true ) ; <EOL> if ( event . key == = '<STR_LIT>' ) onClick ( ) ; <EOL> } <EOL> return ( < Draggable draggableId = { taskId + '<STR_LIT>' } index = { index } > { ( provided ) = > { return ( < div ref = { provided . innerRef } { ... provided . draggableProps } { ... provided . dragHandleProps } tabIndex = { <NUM_LIT> } onKeyDown = { handleKeydown } onClick = { ( event ) = > { event . currentTarget . focus ( ) ; onClick ( ) ; } } > { promptRemove & & ( < DialogConfirm onConfirm = { ( ) = > { removeTask ( taskId ) ; setPromptRemove ( false ) ; } } onCancel = { ( ) = > setPromptRemove ( false ) } aria - label = "<STR_LIT>" >   ⚠   ️ Are you sure you want to remove this task   ? < / DialogConfirm > ) } { task & & ( < TaskColor task = { task } > < div className = "<STR_LIT>" > < div className = "<STR_LIT>" > < Heading size = { <NUM_LIT> } > { task . name } < / Heading > < div className = "<STR_LIT>" > { task . content | | < i > No Content < / i > } < / div > < / div > < footer className = "<STR_LIT>" > < div className = "<STR_LIT>" > < span className = "<STR_LIT>" > < FaCalendar color = {   ` var ( - - taskColor ) ` } / > < span > { format ( parse ( task . date , '<STR_LIT>' , new Date ( ) ) , '<STR_LIT>' ) } < / span > < / span > < / div > < div > < button className = "<STR_LIT>" tabIndex = { - <NUM_LIT> } onClick = { ( e ) = > { e . stopPropagation ( ) ; setPromptRemove ( true ) ; } } > < FaTrash color = "<STR_LIT>" / > < / button > < / div > < / footer > < / div > < / TaskColor > ) } < / div > ) ; } } < / Draggable > ) ; } ; </s>
<s> import { <EOL> ChangeDetectionStrategy , <EOL> Component , <EOL> ElementRef , <EOL> EventEmitter , <EOL> Input , <EOL> OnInit , <EOL> Output , <EOL> ViewChild , <EOL> ViewEncapsulation , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AngularFireStorage , <EOL> AngularFireUploadTask <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BehaviorSubject , <EOL> Observable , <EOL> of <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> catchError , <EOL> finalize <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> encapsulation : ViewEncapsulation . None , <EOL> changeDetection : ChangeDetectionStrategy . OnPush , <EOL> } ) export class CardImageUploadComponent implements OnInit { <EOL> @ Input ( ) pictureUrl : string ; <EOL> @ Output ( ) pictureUrlChange = new EventEmitter < string > ( ) ; <EOL> @ ViewChild ( '<STR_LIT>' , { <EOL> static : true <EOL> } ) fileInput : ElementRef ; <EOL> isPending $ = new BehaviorSubject < boolean > ( false ) ; <EOL> snapshot $ : Observable < any > ; <EOL> constructor ( private storage ) { } <EOL> ngOnInit ( ) { } <EOL> browse ( ) { <EOL> this . fileInput . nativeElement . click ( ) ; <EOL> } <EOL> uploadFile ( files ) { <EOL> const [ file ] = Array . from ( files ) ; <EOL> if ( file . type . split ( '<STR_LIT>' ) [ <NUM_LIT> ] != = '<STR_LIT>' ) { <EOL> console . error ( ` unsupported file type   $ { file . type } ` ) ; <EOL> return ; <EOL> } <EOL> const path =   ` test / $ { Date . now ( ) } _ $ { file . name } ` ; <EOL> const ref = this . storage . ref ( path ) ; <EOL> const task = this . storage . upload ( path , file ) ; <EOL> this . isPending $ . next ( true ) ; <EOL> this . snapshot $ = task . snapshotChanges ( ) . pipe ( finalize ( async ( ) = > { <EOL> const metadata = await ref . getMetadata ( ) . toPromise ( ) ; <EOL> this . pictureUrl = metadata . fullPath ; <EOL> this . pictureUrlChange . emit ( metadata . fullPath ) ; <EOL> } ) , catchError ( err = > { <EOL> this . isPending $ . next ( false ) ; <EOL> console . error ( err ) ; <EOL> return of ( ) ; <EOL> } ) ) ; <EOL> } <EOL> loaded ( ) { <EOL> this . isPending $ . next ( false ) ; <EOL> } <EOL> } </s>
<s> import React , { <EOL> FunctionComponent , <EOL> memo , <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Image , <EOL> StyleProp , <EOL> StyleSheet , <EOL> Text , <EOL> View , <EOL> ViewStyle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ReviewTypes <EOL> } from '<STR_LIT>' ; <EOL> import FSI18n , { <EOL> translationKeys <EOL> } from '<STR_LIT>' ; <EOL> const componentTranslationKeys = translationKeys . flagship . reviews ; <EOL> const S = StyleSheet . create ( { <EOL> row : { <EOL> flexDirection : '<STR_LIT>' , <EOL> flexWrap : '<STR_LIT>' , <EOL> paddingBottom : <NUM_LIT> <EOL> } , <EOL> syndicatedLabel : { <EOL> color : '<STR_LIT>' , <EOL> fontSize : <NUM_LIT> , <EOL> display : '<STR_LIT>' , <EOL> flexDirection : '<STR_LIT>' , <EOL> justifyContent : '<STR_LIT>' <EOL> } <EOL> } ) ; <EOL> export interface SyndicationIndicatorProps { <EOL> syndicationSource : ReviewTypes . SyndicationSource ; rowStyle   ? : StyleProp < ViewStyle > ; <EOL> } <EOL> export const SyndicationIndicator = memo ( ( props ) : JSX . Element = > { <EOL> const [ syndicatedImageHeight , setSyndicatedImageHeight ] = useState < number > ( ) ; <EOL> const [ syndicatedImageWidth , setSyndicatedImageWidth ] = useState < number > ( ) ; <EOL> const getImageSizeSuccess = ( w , h ) = > { <EOL> if ( ! syndicatedImageHeight | |   ! syndicatedImageWidth ) { <EOL> setSyndicatedImageHeight ( h ) ; <EOL> setSyndicatedImageWidth ( w ) ; <EOL> } <EOL> } ; <EOL> Image . getSize ( props . syndicationSource . LogoImageUrl | | '<STR_LIT>' , getImageSizeSuccess , ( ) = > null ) ; <EOL> return ( < View style = { [ S . row , { flexDirection : '<STR_LIT>' , flexWrap : '<STR_LIT>' , paddingBottom : <NUM_LIT> } , props . rowStyle ] } > < Image style = { { height : syndicatedImageHeight , width : syndicatedImageWidth , marginRight : <NUM_LIT> } } source = { { uri : props . syndicationSource . LogoImageUrl } } accessibilityLabel = {   ` $ { props . syndicationSource . Name } logo ` } / > < Text style = { [ S . syndicatedLabel ] } > { FSI18n . string ( componentTranslationKeys . syndicatedLabel , { site : props . syndicationSource . Name } ) } < / Text > < / View > ) ; } ) ; </s>
<s> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Action <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GetReviewersStatisticsCollectionPayload <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ReviewerStatistics <EOL> } from '<STR_LIT>' ; <EOL> export namespace fromUserActions { <EOL> export enum Types { <EOL> GetReviewersStatisticsCollection = '<STR_LIT>' , GetReviewersStatisticsCollectionFail = '<STR_LIT>' , GetReviewersStatisticsCollectionSuccess = '<STR_LIT>' <EOL> } <EOL> export class GetReviewersStatisticsCollection implements Action { <EOL> readonly type = Types . GetReviewersStatisticsCollection ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class GetReviewersStatisticsCollectionFail implements Action { <EOL> readonly type = Types . GetReviewersStatisticsCollectionFail ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class GetReviewersStatisticsCollectionSuccess implements Action { <EOL> readonly type = Types . GetReviewersStatisticsCollectionSuccess ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export type CollectiveType = GetReviewersStatisticsCollection | GetReviewersStatisticsCollectionFail | GetReviewersStatisticsCollectionSuccess ; <EOL> } </s>
<s> import { <EOL> fromSettingsActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SettingModel <EOL> } from '<STR_LIT>' ; <EOL> export const SETTINGS_FEATURE_KEY = '<STR_LIT>' ; <EOL> export interface SettingsState { <EOL> settingModelCollection : SettingModel [ ] ; settingModelCollectionLoading : boolean ; settingModelCollectionLoadError : HttpErrorResponse | null ; settingModelUpdating : boolean ; settingModelUpdateError : HttpErrorResponse | null ; <EOL> } <EOL> export interface SettingsPartialState { <EOL> readonly [ SETTINGS_FEATURE_KEY ] : SettingsState ; <EOL> } <EOL> export const initialState = { <EOL> settingModelCollection : [ ] , <EOL> settingModelCollectionLoading : false , <EOL> settingModelCollectionLoadError : null , <EOL> settingModelUpdating : false , <EOL> settingModelUpdateError : null <EOL> } ; <EOL> export function settingsReducer ( state = initialState , action ) { <EOL> switch ( action . type ) { <EOL> case fromSettingsActions . Types . GetSettingModelCollection : { <EOL> state = { <EOL> ... state , <EOL> settingModelCollection : [ ] , <EOL> settingModelCollectionLoading : true , <EOL> settingModelCollectionLoadError : null <EOL> } ; <EOL> break ; <EOL> } <EOL> case fromSettingsActions . Types . GetSettingModelCollectionFail : { <EOL> state = { <EOL> ... state , <EOL> settingModelCollection : [ ] , <EOL> settingModelCollectionLoading : false , <EOL> settingModelCollectionLoadError : action . payload <EOL> } ; <EOL> break ; <EOL> } <EOL> case fromSettingsActions . Types . GetSettingModelCollectionSuccess : { <EOL> state = { <EOL> ... state , <EOL> settingModelCollection : action . payload , <EOL> settingModelCollectionLoading : false , <EOL> settingModelCollectionLoadError : null <EOL> } ; <EOL> break ; <EOL> } <EOL> case fromSettingsActions . Types . UpdateSettingModel : { <EOL> state = { <EOL> ... state , <EOL> settingModelUpdating : true , <EOL> settingModelUpdateError : null <EOL> } ; <EOL> break ; <EOL> } <EOL> case fromSettingsActions . Types . UpdateSettingModelFail : { <EOL> state = { <EOL> ... state , <EOL> settingModelUpdating : false , <EOL> settingModelUpdateError : action . payload <EOL> } ; <EOL> break ; <EOL> } <EOL> case fromSettingsActions . Types . UpdateSettingModelSuccess : { <EOL> state = { <EOL> ... state , <EOL> settingModelCollection : [ ... state . settingModelCollection . map ( setting = > { <EOL> const patch = action . payload . patch . find ( el = > el . id == = setting . id ) ; <EOL> if ( patch ) return { <EOL> ... setting , <EOL> value : patch . value <EOL> } ; <EOL> else return setting ; <EOL> } ) ] , <EOL> settingModelUpdating : false , <EOL> settingModelUpdateError : null <EOL> } ; <EOL> break ; <EOL> } <EOL> } <EOL> return state ; <EOL> } </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> colors <EOL> } from "<STR_LIT>" ; <EOL> export interface DisclosureArrowIconProps { <EOL> color   ? : string ; <EOL> height   ? : number ; <EOL> width   ? : number ; <EOL> } <EOL> export const DisclosureArrowIcon = props = > { <EOL> const color = props . color | | colors . accent . CIVIL_BLUE ; <EOL> const width = ( props . width | | <NUM_LIT> ) . toString ( ) ; <EOL> const height = ( props . height | | <NUM_LIT> ) . toString ( ) ; <EOL> return ( < svg width = { width } height = { height } viewBox = "<STR_LIT>" xmlns = "<STR_LIT>" > < g stroke = "<STR_LIT>" strokeWidth = "<STR_LIT>" fill = { color } fillRule = "<STR_LIT>" > < g transform = "<STR_LIT>" > < polygon points = "<STR_LIT>" / > < / g > < / g > < / svg > ) ; } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import ReactDOM from '<STR_LIT>' ; <EOL> import { <EOL> atom , <EOL> RecoilRoot , <EOL> useRecoilValue , <EOL> useRecoilState , <EOL> selector <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> inc , <EOL> reduxSelector , <EOL> ReduxBridge , <EOL> useDispatch , <EOL> useSelector <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> store , <EOL> State <EOL> } from '<STR_LIT>' ; <EOL> const getReduxCount = ( s ) = > s . count ; <EOL> const counterAtom = atom ( { <EOL> key : '<STR_LIT>' , <EOL> default : <NUM_LIT> <EOL> } ) ; <EOL> const maxCounterType = selector < string > ( { <EOL> key : '<STR_LIT>' , <EOL> get : ( { <EOL> get <EOL> } ) = > { <EOL> const re = get ( counterAtom ) ; <EOL> const rx = get ( reduxSelector ( getReduxCount ) ) as number ; <EOL> return re == = rx   ? '<STR_LIT>' : re > rx   ? '<STR_LIT>' : '<STR_LIT>' ; <EOL> } , <EOL> } ) ; <EOL> function App ( ) { <EOL> const reduxCount = useSelector ( getReduxCount ) ; <EOL> const dispatch = useDispatch ( ) ; <EOL> const [ counter , setCounter ] = useRecoilState ( counterAtom ) ; <EOL> const maxType = useRecoilValue ( maxCounterType ) ; <EOL> return ( < > < div > reduxCounter : { reduxCount } < button onClick = { ( ) = > dispatch ( { type : '<STR_LIT>' } ) } > dispatch < / button > < / div > < div > recoilCounter : { counter } < button onClick = { ( ) = > setCounter ( inc ) } > dispatch < / button > < / div > < div > { maxType } < / div > < / > ) ; } ReactDOM . render ( < RecoilRoot > < ReduxBridge store = { store } > < App / > < / ReduxBridge > < / RecoilRoot > , document . getElementById ( '<STR_LIT>' ) ) ; </s>
<s> import { <EOL> makeAutoObservable , <EOL> autorun <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * Setup <EOL> * / <EOL> class Person { <EOL> age = <NUM_LIT> ; <EOL> constructor ( ) { <EOL> makeAutoObservable ( this ) ; <EOL> } <EOL> addYear ( ) { <EOL> this . age += <NUM_LIT> ; <EOL> } <EOL> get canRentCar ( ) { <EOL> return this . age >= <NUM_LIT> ; <EOL> } <EOL> } <EOL> const me = new Person ( ) ; <EOL> / ** <EOL> * Read and Write Values <EOL> * / <EOL> const id = setInterval ( ( ) = > { <EOL> me . addYear ( ) ; <EOL> } , <NUM_LIT> ) ; <EOL> autorun ( ( ) = > { <EOL> if ( me . canRentCar ) { <EOL> console . log ( '<STR_LIT>' ) ; <EOL> } else { <EOL> console . log ( "<STR_LIT>" ) ; <EOL> } <EOL> } ) ; <EOL> autorun ( ( ) = > { <EOL> console . log ( ` age   $ { me . age } ` ) ; <EOL> if ( me . age >= <NUM_LIT> ) { <EOL> clearInterval ( id ) ; <EOL> } <EOL> } ) ; </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import * as storage from '<STR_LIT>' ; <EOL> export const FavoriteProductProvider = ( { <EOL> children <EOL> } ) = > { <EOL> return ( < React . Fragment > { children } < / React . Fragment > ) ; } ; export function useFavoriteProduct ( ) { } interface FavoriteProductContextValue { isFavorite ( productId ) : boolean ; addFavorite ( productId ) : void ; removeFavorite ( productId ) : void ; } </s>
<s> import * as chalk from '<STR_LIT>' ; <EOL> import { <EOL> EMOJIS <EOL> } from '<STR_LIT>' ; <EOL> export const MESSAGES = { <EOL> PROJECT_SELECTION_QUESTION : '<STR_LIT>' , <EOL> LIBRARY_PROJECT_SELECTION_QUESTION : '<STR_LIT>' , <EOL> DRY_RUN_MODE : '<STR_LIT>' , <EOL> PROJECT_INFORMATION_START :   ` $ { EMOJIS . ZAP } We will scaffold your app in a few seconds . . ` , <EOL> RUNNER_EXECUTION_ERROR : ( command ) = >   ` \ nFailed to execute command :   $ { command } ` , <EOL> PACKAGE_MANAGER_QUESTION :   ` Which package manager would you   $ { EMOJIS . HEART } to use ? ` , <EOL> PACKAGE_MANAGER_INSTALLATION_IN_PROGRESS :   ` Installation in progress ...   $ { EMOJIS . COFFEE } ` , <EOL> PACKAGE_MANAGER_UPDATE_IN_PROGRESS :   ` Installation in progress ...   $ { EMOJIS . COFFEE } ` , <EOL> PACKAGE_MANAGER_UPGRADE_IN_PROGRESS :   ` Installation in progress ...   $ { EMOJIS . COFFEE } ` , <EOL> PACKAGE_MANAGER_PRODUCTION_INSTALLATION_IN_PROGRESS :   ` Package installation in progress ...   $ { EMOJIS . COFFEE } ` , <EOL> GIT_INITIALIZATION_ERROR : '<STR_LIT>' , <EOL> PACKAGE_MANAGER_INSTALLATION_SUCCEED : ( name ) = > name != = '<STR_LIT>'   ?   ` $ { EMOJIS . ROCKET } Successfully created project   $ { chalk . green ( name ) } ` :   ` $ { EMOJIS . ROCKET } Successfully created a new project ` , <EOL> GET_STARTED_INFORMATION :   ` $ { EMOJIS . POINT_RIGHT } Get started with the following commands : ` , <EOL> CHANGE_DIR_COMMAND : ( name ) = >   ` $ cd   $ { name } ` , <EOL> START_COMMAND : ( name ) = >   ` $   $ { name } run start ` , <EOL> PACKAGE_MANAGER_INSTALLATION_FAILED :   ` $ { EMOJIS . SCREAM } Packages installation failed , see above ` , <EOL> NEST_INFORMATION_PACKAGE_MANAGER_FAILED :   ` $ { EMOJIS . SMIRK } cannot read your project package . json file , are you inside your project directory ? ` , <EOL> LIBRARY_INSTALLATION_FAILED_BAD_PACKAGE : ( name ) = >   ` Unable to install library   $ { name } because package did not install . Please check package name . ` , <EOL> LIBRARY_INSTALLATION_FAILED_NO_LIBRARY : '<STR_LIT>' , <EOL> LIBRARY_INSTALLATION_STARTS : '<STR_LIT>' , <EOL> } ; </s>
<s> import { <EOL> Component , <EOL> EventEmitter , <EOL> HostListener , <EOL> Input , <EOL> OnInit , <EOL> Output <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> EventService <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> FullscreenService <EOL> } from "<STR_LIT>" ; <EOL> @ Component ( { <EOL> selector : "<STR_LIT>" , <EOL> templateUrl : "<STR_LIT>" , <EOL> styleUrls : [ "<STR_LIT>" ] <EOL> } ) export class MatFullscreenButtonComponent implements OnInit { <EOL> canFullscreen = false ; <EOL> @ Input ( ) player : HTMLVideoElement ; <EOL> @ Input ( ) fullscreen = false ; <EOL> @ Output ( ) fullscreenChanged = new EventEmitter < boolean > ( ) ; <EOL> @ Input ( ) keyboard = true ; <EOL> constructor ( private fscreen , private evt ) { } <EOL> ngOnInit ( ) { <EOL> if ( this . fscreen . isEnabled ( ) ) { <EOL> this . canFullscreen = true ; <EOL> } <EOL> this . fscreen . onChange ( event = > ( this . fscreen . isFullscreen ( )   ? this . onChangesFullscreen ( true ) : this . onChangesFullscreen ( false ) ) ) ; <EOL> } <EOL> setFullscreen ( value ) { <EOL> if ( this . canFullscreen & & this . fullscreen != = value ) { <EOL> this . toggleFullscreen ( ) ; <EOL> } <EOL> } <EOL> toggleFullscreen ( ) { <EOL> this . fullscreen =   ! this . fullscreen ; <EOL> this . updateFullscreen ( ) ; <EOL> } <EOL> updateFullscreen ( ) { <EOL> this . fullscreen   ? this . fscreen . request ( this . player ) : this . fscreen . exit ( ) ; <EOL> this . fullscreenChanged . emit ( this . fullscreen ) ; <EOL> } <EOL> onChangesFullscreen ( value ) { <EOL> this . fullscreen = value ; <EOL> this . fullscreenChanged . emit ( this . fullscreen ) ; <EOL> } <EOL> @ HostListener ( "<STR_LIT>" , [ "<STR_LIT>" ] ) onFullscreenKey ( event ) { <EOL> if ( this . keyboard ) { <EOL> this . toggleFullscreen ( ) ; <EOL> event . preventDefault ( ) ; <EOL> } <EOL> } <EOL> } </s>
<s> export const environment = { <EOL> production : false <EOL> } ; </s>
<s> import { <EOL> createFeatureSelector , <EOL> createSelector <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> State <EOL> } from '<STR_LIT>' ; <EOL> const getState = createFeatureSelector < State > ( '<STR_LIT>' ) ; <EOL> export const getNavigationId = createSelector ( getState , state = > state . navigationId ) ; <EOL> export const getUrlSnapshot = createSelector ( getState , state = > ( state   ? state . state : ( { } <EOL> as any ) ) ) ; <EOL> export const getUrl = createSelector ( getUrlSnapshot , state = > state . url ) ; <EOL> export const getParams = createSelector ( getUrlSnapshot , state = > state . params ) ; <EOL> export const getQueryParams = createSelector ( getUrlSnapshot , state = > state . queryParams ) ; <EOL> export const getData = createSelector ( getUrlSnapshot , state = > state . data | | { } ) ; <EOL> export const getGuarded = createSelector ( getUrlSnapshot , state = > state . guarded | | false ) ; </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConfigService <EOL> } from '<STR_LIT>' ; <EOL> import * as AWS from '<STR_LIT>' ; <EOL> import got from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class AppService { <EOL> client : AWS . DynamoDB . DocumentClient ; constructor ( private readonly configService ) { <EOL> AWS . config . update ( { <EOL> credentials : { <EOL> accessKeyId : this . configService . get ( '<STR_LIT>' ) , <EOL> secretAccessKey : this . configService . get ( '<STR_LIT>' ) , <EOL> } , <EOL> region : '<STR_LIT>' , <EOL> } ) ; <EOL> this . client = new AWS . DynamoDB . DocumentClient ( ) ; <EOL> } <EOL> async getChatIds ( ) { <EOL> try { <EOL> const chatIdsData = await this . client . get ( { <EOL> TableName : '<STR_LIT>' , <EOL> Key : { <EOL> PartitionKey : '<STR_LIT>' , <EOL> } , <EOL> } ) . promise ( ) ; <EOL> if ( chatIdsData . Item ) { <EOL> if ( '<STR_LIT>' in chatIdsData . Item ) { <EOL> const chatIds = chatIdsData . Item ? . ids ; <EOL> return chatIds ; <EOL> } <EOL> } <EOL> return null ; <EOL> } catch ( e ) { <EOL> return null ; <EOL> } <EOL> } <EOL> async addChatId ( chatId ) { <EOL> try { <EOL> await this . client . update ( { <EOL> TableName : '<STR_LIT>' , <EOL> Key : { <EOL> PartitionKey : '<STR_LIT>' , <EOL> } , <EOL> UpdateExpression : '<STR_LIT>' , <EOL> ExpressionAttributeValues : { <EOL> '<STR_LIT>' : [ chatId ] , <EOL> } , <EOL> } ) . promise ( ) ; <EOL> return true ; <EOL> } catch ( e ) { <EOL> return false ; <EOL> } <EOL> } <EOL> async getLastSeen ( ) { <EOL> try { <EOL> const lastSeenData = await this . client . get ( { <EOL> TableName : '<STR_LIT>' , <EOL> Key : { <EOL> PartitionKey : '<STR_LIT>' , <EOL> } , <EOL> } ) . promise ( ) ; <EOL> if ( lastSeenData . Item ) { <EOL> if ( '<STR_LIT>' in lastSeenData . Item ) { <EOL> const lastSeen = lastSeenData . Item ? . lastSeen ; <EOL> return lastSeen ; <EOL> } <EOL> } <EOL> } catch ( e ) { <EOL> return null ; <EOL> } <EOL> } <EOL> async sendMessage ( message , chatId ) { <EOL> try { <EOL> await got . post ( ` https : // api . telegram . org / $ { this . configService . get ( '<STR_LIT>' ) } / sendMessage ` , { <EOL> json : { <EOL> chat_id : chatId , <EOL> text : message , <EOL> parse_mode : '<STR_LIT>' , <EOL> } , <EOL> } ) ; <EOL> return true ; <EOL> } catch ( e ) { <EOL> return false ; <EOL> } <EOL> } <EOL> async saveLastSeen ( lastSeen ) { <EOL> try { <EOL> await this . client . update ( { <EOL> TableName : '<STR_LIT>' , <EOL> Key : { <EOL> PartitionKey : '<STR_LIT>' , <EOL> } , <EOL> UpdateExpression : '<STR_LIT>' , <EOL> ExpressionAttributeValues : { <EOL> '<STR_LIT>' : lastSeen , <EOL> } , <EOL> } ) . promise ( ) ; <EOL> } catch ( e ) { } <EOL> } <EOL> } </s>
<s> import { <EOL> createFeatureSelector , <EOL> createSelector <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> REVIEWERS_FEATURE_KEY , <EOL> selectAll , <EOL> UserState <EOL> } from '<STR_LIT>' ; <EOL> const getReviewersStatisticsState = createFeatureSelector < UserState > ( REVIEWERS_FEATURE_KEY ) ; <EOL> const getReviewersStatisticsCollectionEntityState = createSelector ( getReviewersStatisticsState , state = > state . reviewersStatisticsCollection ) ; <EOL> const getReviewersStatisticsCollection = createSelector ( getReviewersStatisticsCollectionEntityState , selectAll ) ; <EOL> const getReviewersStatisticsCollectionLoading = createSelector ( getReviewersStatisticsState , state = > state . reviewersStatisticsCollectionLoading ) ; <EOL> const getReviewersStatisticsCollectionLoadError = createSelector ( getReviewersStatisticsState , state = > state . reviewersStatisticsCollectionLoadError ) ; <EOL> export const reviewersStatisticsQuery = { <EOL> getReviewersStatisticsCollection : getReviewersStatisticsCollection , <EOL> getReviewersStatisticsCollectionLoading : getReviewersStatisticsCollectionLoading , <EOL> getReviewersStatisticsCollectionLoadError : getReviewersStatisticsCollectionLoadError <EOL> } ; </s>
<s> import { <EOL> Contributor <EOL> } from '<STR_LIT>' ; <EOL> export class ContributorsList { <EOL> public static getAllContributors ( ) { <EOL> return [ new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new Contributor ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , ] ; <EOL> } <EOL> } </s>
<s> import { <EOL> assert , <EOL> expect <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> describe , <EOL> it <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> bindArgs , <EOL> evalFnBody , <EOL> metaesEval , <EOL> uncps , <EOL> uncpsp <EOL> } from "<STR_LIT>" ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> const evalFnBodyAsPromise = uncpsp ( evalFnBody ( metaesEval ) ) ; <EOL> it ( "<STR_LIT>" , ( ) = > new Promise ( ( resolve ) = > metaesEval ( "<STR_LIT>" , resolve ) ) ) ; <EOL> it ( "<STR_LIT>" , ( ) = > new Promise ( ( resolve ) = > metaesEval ( "<STR_LIT>" , undefined , resolve ) ) ) ; <EOL> it ( "<STR_LIT>" , ( ) = > { <EOL> expect ( ( ) = > metaesEval ( "<STR_LIT>" ) ) . to . not . throw ( ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> assert . equal ( await evalFnBodyAsPromise ( ( a ) = > a * <NUM_LIT> , { <EOL> values : { <EOL> a : <NUM_LIT> <EOL> } <EOL> } ) , <NUM_LIT> ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] . forEach ( async ( i ) = > assert . equal ( await evalFnBodyAsPromise ( ( a ) = > a * <NUM_LIT> , { <EOL> values : { <EOL> a : i <EOL> } <EOL> } ) , i * <NUM_LIT> ) ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( "<STR_LIT>" , function ( ) { <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> assert . equal ( uncps ( metaesEval ) ( "<STR_LIT>" , { <EOL> a : <NUM_LIT> <EOL> } ) , <NUM_LIT> ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> let thrown ; <EOL> try { <EOL> uncps ( metaesEval ) ( "<STR_LIT>" , { <EOL> a : <NUM_LIT> <EOL> } ) ; <EOL> } catch ( exception ) { <EOL> thrown = exception . value ; <EOL> } <EOL> assert . equal ( thrown , <NUM_LIT> ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( "<STR_LIT>" , function ( ) { <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> const oneAndTwo = bindArgs ( <NUM_LIT> , <NUM_LIT> ) ; <EOL> const add = ( a , b ) = > a + b ; <EOL> assert . equal ( oneAndTwo ( add ) , <NUM_LIT> ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> Settings , <EOL> ControllerConstructor <EOL> } from '<STR_LIT>' ; <EOL> export const isClient = typeof window != = '<STR_LIT>' ; <EOL> export const isServer =   ! isClient ; <EOL> const defaultAppSettings = { <EOL> container : '<STR_LIT>' , <EOL> basename : '<STR_LIT>' , <EOL> context : { <EOL> isServer , <EOL> isClient <EOL> } , <EOL> type : '<STR_LIT>' , <EOL> loader : ( value ) = > value as ControllerConstructor <EOL> } ; <EOL> export default defaultAppSettings ; </s>
<s> export default function slowFunction ( ) { <EOL> const x = <NUM_LIT> ; <EOL> for ( let i = <NUM_LIT> ; i < x ; i + + ) { } <EOL> return x ; <EOL> } </s>
<s> import { <EOL> Component , <EOL> Input , <EOL> Output , <EOL> EventEmitter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AppsyncService <EOL> } from '<STR_LIT>' ; <EOL> import getAllUsers from '<STR_LIT>' ; <EOL> import createConversation from '<STR_LIT>' ; <EOL> import createUserConversations from '<STR_LIT>' ; <EOL> import getUserConversationsConnection from '<STR_LIT>' ; <EOL> import subscribeToNewUserUsers from '<STR_LIT>' ; <EOL> import { <EOL> constants , <EOL> addConversation , <EOL> addUser <EOL> } from '<STR_LIT>' ; <EOL> import Conversation from '<STR_LIT>' ; <EOL> import { <EOL> getAllUsersQuery as UsersQuery <EOL> } from '<STR_LIT>' ; <EOL> import * as _ from '<STR_LIT>' ; <EOL> import { <EOL> v4 as uuid <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Analytics <EOL> } from '<STR_LIT>' ; <EOL> import User from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] <EOL> } ) export class ChatUserListComponent { <EOL> _user ; <EOL> users : User [ ] = [ ] ; <EOL> order = '<STR_LIT>' ; <EOL> no_user = false ; <EOL> @ Input ( ) set user ( user ) { <EOL> this . _user = user ; <EOL> if ( this . _user ) { <EOL> this . getAllUsers ( ) ; <EOL> } <EOL> } <EOL> @ Output ( ) onNewConvo = new EventEmitter < any > ( ) ; <EOL> constructor ( private appsync ) { } <EOL> getAllUsers ( ) { <EOL> this . appsync . hc ( ) . then ( client = > { <EOL> const observable = client . watchQuery ( { <EOL> query : getAllUsers , <EOL> fetchPolicy : '<STR_LIT>' <EOL> } ) ; <EOL> observable . subscribe ( ( { <EOL> data <EOL> } ) = > { <EOL> if ( ! data ) { <EOL> return console . log ( '<STR_LIT>' ) ; <EOL> } <EOL> this . users = _ ( data . allUser ) . sortBy ( '<STR_LIT>' ) . reject ( [ '<STR_LIT>' , this . _user . id ] ) . value ( ) ; <EOL> console . log ( '<STR_LIT>' , this . users ) ; <EOL> this . no_user = ( this . users . length == = <NUM_LIT> ) ; <EOL> } ) ; <EOL> observable . subscribeToMore ( { <EOL> document : subscribeToNewUserUsers , <EOL> updateQuery : ( prev , { <EOL> subscriptionData : { <EOL> data : { <EOL> subscribeToNewUsers : user <EOL> } <EOL> } <EOL> } ) = > { <EOL> console . log ( '<STR_LIT>' , user , prev ) ; <EOL> return this . _user . id == = user . id   ? prev : addUser ( prev , user ) ; <EOL> } <EOL> } ) ; <EOL> } ) ; <EOL> } <EOL> createNewConversation ( user , event ) { <EOL> event . stopPropagation ( ) ; <EOL> this . appsync . hc ( ) . then ( client = > { <EOL> const options = { <EOL> query : getUserConversationsConnection , <EOL> variables : { <EOL> first : constants . conversationFirst <EOL> } <EOL> } ; <EOL> const userConvos = client . readQuery ( options ) ; <EOL> const path = '<STR_LIT>' ; <EOL> const userConvo = ( _ . chain ( userConvos ) . get ( path ) as any ) . find ( c = > _ . some ( c . associated , [ '<STR_LIT>' , user . id ] ) ) . value ( ) ; <EOL> if ( userConvo ) { <EOL> return this . onNewConvo . emit ( userConvo . conversation ) ; <EOL> } <EOL> const newConvo = { <EOL> id : uuid ( ) , <EOL> name : _ . map ( [ this . _user , user ] , '<STR_LIT>' ) . sort ( ) . join ( '<STR_LIT>' ) , <EOL> createdAt :   ` $ { Date . now ( ) } ` <EOL> } ; <EOL> client . mutate ( { <EOL> mutation : createConversation , <EOL> variables : newConvo <EOL> } ) . then ( ( ) = > createUserConvo ( client , user . id , newConvo . id ) ) . then ( ( ) = > createUserConvo ( client , this . _user . id , newConvo . id , true ) ) . then ( ( ) = > this . onNewConvo . emit ( newConvo ) ) . catch ( err = > console . log ( '<STR_LIT>' , err ) ) ; <EOL> Analytics . record ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> } <EOL> } <EOL> function createUserConvo ( client , id , convoId , update = false ) { <EOL> const options = { <EOL> mutation : createUserConversations , <EOL> variables : { <EOL> '<STR_LIT>' : id , <EOL> '<STR_LIT>' : convoId <EOL> } , <EOL> ... ( ! update   ? { } : { <EOL> update ( proxy , { <EOL> data : { <EOL> createUserConversations : userConvo <EOL> } <EOL> } ) { <EOL> console . log ( '<STR_LIT>' , userConvo ) ; <EOL> const _options = { <EOL> query : getUserConversationsConnection , <EOL> variables : { <EOL> first : constants . conversationFirst <EOL> } <EOL> } ; <EOL> const prev = proxy . readQuery ( _options ) ; <EOL> const data = addConversation ( prev , userConvo ) ; <EOL> proxy . writeQuery ( { <EOL> ... _options , <EOL> data <EOL> } ) ; <EOL> } <EOL> } ) <EOL> } ; <EOL> return client . mutate ( options ) ; <EOL> } </s>
<s> import { <EOL> ChangeDetectionStrategy , <EOL> Component , <EOL> Inject , <EOL> OnDestroy , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UntilDestroy , <EOL> untilDestroyed <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RepositoryFacade <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormBuilder , <EOL> FormControl , <EOL> FormGroup , <EOL> Validators <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MAT_DIALOG_DATA , <EOL> MatDialogRef <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeUnit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AddEditRepositoryDialogData , <EOL> AddRepositoryPayload , <EOL> EditRepositoryPayload , <EOL> Repository <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SnackbarService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AddEditRepositoryDialogService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Router <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ApiException <EOL> } from '<STR_LIT>' ; <EOL> @ UntilDestroy ( ) @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class AddEditRepositoryDialogComponent implements OnInit { <EOL> dialogTitle : string ; form : FormGroup ; repositoryToEdit : Repository ; submitMsg : string ; constructor ( @ Inject ( MAT_DIALOG_DATA ) data , private repoFacade , private fb , private dialogRef , private snackbarService , private router , private addEditRepositoryDialogService ) { <EOL> if ( data ) { <EOL> this . dialogTitle = data . dialogTitle ; <EOL> this . repositoryToEdit = data . repositoryToEdit ; <EOL> this . submitMsg = data . submitMsg ; <EOL> } <EOL> } <EOL> ngOnInit ( ) { <EOL> this . form = this . addEditRepositoryDialogService . initForm ( this . repositoryToEdit ) ; <EOL> } <EOL> submit ( ) { <EOL> if ( this . form . valid ) { <EOL> const { <EOL> repositoryUrl , <EOL> maxLines , <EOL> maxWaitingTime , <EOL> maxPrs <EOL> } = this . form . value ; <EOL> if ( this . repositoryToEdit ) { <EOL> this . editRepository ( { <EOL> maxLines , <EOL> maxWaitingTime , <EOL> maxPrs , <EOL> repositoryId : this . repositoryToEdit . id <EOL> } ) ; <EOL> } else { <EOL> this . addRepository ( repositoryUrl , maxLines , maxWaitingTime , maxPrs ) ; <EOL> } <EOL> } <EOL> } <EOL> private addRepository ( repositoryUrl , maxLines , maxWaitingTime , maxPrs ) { <EOL> this . repoFacade . addRepository ( { <EOL> repositoryUrl , <EOL> maxLines , <EOL> maxWaitingTime , <EOL> maxPrs <EOL> } ) . subscribe ( payload = > { <EOL> this . snackbarService . open ( '<STR_LIT>' ) ; <EOL> this . router . navigate ( [ '<STR_LIT>' , payload . repository . id ] ) ; <EOL> this . dialogRef . close ( ) ; <EOL> } , ( error ) = > { <EOL> this . snackbarService . open ( error . message ) ; <EOL> } ) ; <EOL> } <EOL> private editRepository ( payload ) { <EOL> this . repoFacade . editRepository ( payload ) . subscribe ( ( ) = > { <EOL> this . snackbarService . open ( '<STR_LIT>' ) ; <EOL> this . dialogRef . close ( ) ; <EOL> } , error = > { <EOL> this . snackbarService . open ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> } <EOL> } </s>
<s> import Nano , { <EOL> Fragment <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ApplicationSettingItem , <EOL> ApplicationSettingItemProps , <EOL> ApplicationSettingItemState , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n , <EOL> sentenceKey <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CloudSyncChip , <EOL> RebootNeededChip <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Context <EOL> } from '<STR_LIT>' ; <EOL> export class Language extends ApplicationSettingItem < ApplicationSettingItemProps , ApplicationSettingItemState > { <EOL> override render ( ) { <EOL> return ( < Fragment > < div class = "<STR_LIT>" > < div class = "<STR_LIT>" > < div class = "<STR_LIT>" > { i18n . t ( sentenceKey . languageSetting ) } < / div > < div class = "<STR_LIT>" > { i18n . t ( sentenceKey . languageSettingDesc ) } < / div > < div class = "<STR_LIT>" > < CloudSyncChip / > < RebootNeededChip / > < / div > < / div > < div class = "<STR_LIT>" > < select class = "<STR_LIT>" onchange = { event = > this . select ( Context . languageSettingId , event . target ) } > < option value = "<STR_LIT>" { ... ( this . localContext . languageSetting == = '<STR_LIT>'   ? { selected : true } : { } ) } > { i18n . t ( sentenceKey . auto ) } < / option > < option value = "<STR_LIT>" { ... ( this . localContext . languageSetting == = '<STR_LIT>'   ? { selected : true } : { } ) } > 中文 < / option > < option value = "<STR_LIT>" { ... ( this . localContext . languageSetting == = '<STR_LIT>'   ? { selected : true } : { } ) } > English < / option > < / select > < / div > < / div > < / Fragment > ) ; } } </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Router <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuthFacade <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( { <EOL> providedIn : '<STR_LIT>' <EOL> } ) export class AuthFeatureFacade { <EOL> constructor ( private authFacade , private router ) { } <EOL> loginRememberedUserOrGoToLogin ( ) { <EOL> const savedToken = this . authFacade . getSavedToken ( ) ; <EOL> if ( ! ! savedToken ) { <EOL> this . authFacade . applyToken ( savedToken ) ; <EOL> } else { <EOL> this . router . navigate ( [ '<STR_LIT>' ] ) ; <EOL> } <EOL> } <EOL> } </s>
<s> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Router <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Actions , <EOL> Effect , <EOL> ofType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataPersistence <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map , <EOL> tap <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> LoginSuccessPayload <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GetUserSuccessPayload <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuthDataService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fromAuthActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuthPartialState <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class AuthEffects { <EOL> @ Effect ( ) login $ = this . dp . fetch ( fromAuthActions . Types . Login , { <EOL> run : ( action ) = > this . authDataService . login ( action . payload ) . pipe ( tap ( ( res ) = > this . authDataService . saveToken ( res . token ) ) , map ( ( res ) = > new fromAuthActions . LoginSuccess ( res ) ) ) , <EOL> onError : ( action , error ) = > { <EOL> return new fromAuthActions . LoginFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> @ Effect ( ) getUser $ = this . dp . fetch ( fromAuthActions . Types . GetUser , { <EOL> run : ( ) = > this . authDataService . getUser ( ) . pipe ( map ( ( res ) = > new fromAuthActions . GetUserSuccess ( res ) ) ) , <EOL> onError : ( action , error ) = > { <EOL> return new fromAuthActions . GetUserFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> @ Effect ( { <EOL> dispatch : false <EOL> } ) logout $ = this . actions $ . pipe ( ofType ( fromAuthActions . Types . Logout ) , tap ( ( ) = > { <EOL> this . authDataService . clearSavedToken ( ) ; <EOL> } ) ) ; <EOL> constructor ( private dp , private actions $ , private router , private authDataService ) { } <EOL> } </s>
<s> import { <EOL> ApplicationStart , <EOL> IBasePath <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ForwardDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> normalizePath <EOL> } from '<STR_LIT>' ; <EOL> export const navigateToLegacyOpenSearchDashboardsUrl = ( path , forwards , basePath , application ) : { <EOL> navigated : boolean ; <EOL> } = > { <EOL> const normalizedPath = normalizePath ( path ) ; <EOL> const relevantForward = forwards . find ( ( forward ) = > normalizedPath . startsWith ( ` / $ { forward . legacyAppId } ` ) ) ; <EOL> if ( ! relevantForward ) { <EOL> return { <EOL> navigated : false <EOL> } ; <EOL> } <EOL> const targetAppPath = relevantForward . rewritePath ( normalizedPath ) ; <EOL> const targetAppId = relevantForward . newAppId ; <EOL> application . navigateToApp ( targetAppId , { <EOL> path : targetAppPath , <EOL> replace : true <EOL> } ) ; <EOL> return { <EOL> navigated : true <EOL> } ; <EOL> } ; </s>
<s> </s>
<s> import Nano , { <EOL> Fragment <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DescriptionGetter , <EOL> InputSettingItem <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AdapterSettingItem , <EOL> AdapterSettingItemProps , <EOL> AdapterSettingItemState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isEmpty , <EOL> isFn , <EOL> isNil <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n , <EOL> sentenceKey <EOL> } from '<STR_LIT>' ; <EOL> import fs from '<STR_LIT>' ; <EOL> import { <EOL> existsCacheSync <EOL> } from '<STR_LIT>' ; <EOL> export interface InputProps extends AdapterSettingItemProps { <EOL> item : InputSettingItem ; <EOL> } <EOL> export class Input extends AdapterSettingItem < InputProps , AdapterSettingItemState > { <EOL> select ( event , id , name ) { <EOL> let result = utools . showOpenDialog ( { <EOL> title : name , <EOL> message : name , <EOL> properties : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ] , <EOL> } ) ; <EOL> if ( isNil ( result ) | | isEmpty ( result ) ) { <EOL> alert ( i18n . t ( sentenceKey . nonExistsPathOrCancel ) ) ; <EOL> } else { <EOL> let path = result ! [ <NUM_LIT> ] ; <EOL> if ( ! isEmpty ( path ) ) { <EOL> if ( ! fs . existsSync ( path ) ) { <EOL> alert ( i18n . t ( sentenceKey . nonExistsFileOrDeleted ) ) ; <EOL> event . target . value = '<STR_LIT>' ; <EOL> return ; <EOL> } <EOL> utools . dbStorage . setItem ( id , path ) ; <EOL> this . props . update ( ) ; <EOL> } <EOL> } <EOL> } <EOL> input ( event , id ) { <EOL> let inputValue = event . target ? . value ; <EOL> if ( isNil ( inputValue ) ) { <EOL> alert ( i18n . t ( sentenceKey . unknownInputError ) ) ; <EOL> } else if ( isEmpty ( inputValue ) ) { <EOL> return ; <EOL> } else { <EOL> let path = inputValue ; <EOL> if ( ! fs . existsSync ( path ) ) { <EOL> alert ( i18n . t ( sentenceKey . nonExistsFileOrDeleted ) ) ; <EOL> event . target . value = '<STR_LIT>' ; <EOL> return ; <EOL> } <EOL> utools . dbStorage . setItem ( id , path ) ; <EOL> this . props . update ( ) ; <EOL> } <EOL> } <EOL> override render ( ) { <EOL> return ( < Fragment > < div class = "<STR_LIT>" > < div class = "<STR_LIT>" > { this . props . item . name } < / div > { isNil ( this . props . item . description )   ? < Fragment / > : < div class = "<STR_LIT>" > { isFn ( this . props . item . description )   ? ( this . props . item . description as DescriptionGetter ) ( ) : this . props . item . description } < / div > } < div class = "<STR_LIT>" > { this . props . context . enableEditPathInputDirectly   ? < Fragment > < input type = "<STR_LIT>" class = {   ` form - input input - sm   $ { existsCacheSync ( this . props . item . value as string )   ? '<STR_LIT>' : '<STR_LIT>' } ` } value = { this . props . item . value == null   ? '<STR_LIT>' : this . props . item . value } placeholder = { i18n . t ( sentenceKey . inputDirectlyPlaceholder ) } onBlur = { event = > this . input ( event , this . props . item . id ) } / > < / Fragment > : < Fragment > < input type = "<STR_LIT>" class = {   ` form - input input - sm   $ { existsCacheSync ( this . props . item . value as string )   ? '<STR_LIT>' : '<STR_LIT>' } ` } value = { this . props . item . value == null   ? '<STR_LIT>' : this . props . item . value } placeholder = { i18n . t ( sentenceKey . fileSelectorPlaceholder ) } onClick = { event = > this . select ( event , this . props . item . id , this . props . item . name ) } readOnly / > < / Fragment > } < button class = "<STR_LIT>" onClick = { ( ) = > this . clear ( this . props . item . id ) } > < i class = "<STR_LIT>" / > < / button > < / div > < div class = "<STR_LIT>" style = {   ` display :   $ { existsCacheSync ( this . props . item . value as string )   ? '<STR_LIT>' : '<STR_LIT>' } ` } > { i18n . t ( sentenceKey . filePathNonExistsTips ) } < / div > < / div > < / Fragment > ) ; } } </s>
<s> import React , { <EOL> useEffect , <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Heading <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Task <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> api <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> type Props = { <EOL> taskId : number ; onClick ( ) : void ; <EOL> } ; <EOL> export const TaskCard = ( { <EOL> taskId , <EOL> onClick <EOL> } ) = > { <EOL> const [ task , setTask ] = useState < Task | null > ( null ) ; <EOL> return ( < div onClick = { ( ) = > { onClick ( ) ; } } role = "<STR_LIT>" className = "<STR_LIT>" > < div className = "<STR_LIT>" > < Heading size = { <NUM_LIT> } > { task   ? . name } < / Heading > < div className = "<STR_LIT>" > { task   ? . content | | < i > Get Task Data from Database < / i > } < / div > < / div > < / div > ) ; } ; </s>
<s> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES , <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggTypesDependencies <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BucketAggType , <EOL> IBucketAggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createFilterHistogram <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BUCKET_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExtendedBounds <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isAutoInterval , <EOL> autoInterval <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> calculateHistogramInterval <EOL> } from '<STR_LIT>' ; <EOL> export interface AutoBounds { <EOL> min : number ; max : number ; <EOL> } <EOL> export interface HistogramBucketAggDependencies { <EOL> getConfig : < T = any > ( key : string ) = > T ; getFieldFormatsStart : AggTypesDependencies [ '<STR_LIT>' ] ; } export interface IBucketHistogramAggConfig extends IBucketAggConfig { setAutoBounds : ( bounds : AutoBounds ) = > void ; getAutoBounds : ( ) = > AutoBounds ; } export interface AggParamsHistogram extends BaseAggParams { field : string ; interval : string ; maxBars   ? : number ; intervalBase   ? : number ; min_doc_count   ? : boolean ; has_extended_bounds   ? : boolean ; extended_bounds   ? : ExtendedBounds ; } export const getHistogramBucketAgg = ( { getConfig , getFieldFormatsStart , } ) = > new BucketAggType < IBucketHistogramAggConfig > ( { name : BUCKET_TYPES . HISTOGRAM , title : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , ordered : { } , makeLabel ( aggConfig ) { return aggConfig . getFieldDisplayName ( ) ; } , createFilter : createFilterHistogram ( getFieldFormatsStart ) , decorateAggConfig ( ) { let autoBounds ; return { setAutoBounds : { configurable : true , value ( newValue ) { autoBounds = newValue ; } , } , getAutoBounds : { configurable : true , value ( ) { return autoBounds ; } , } , } ; } , params : [ { name : '<STR_LIT>' , type : '<STR_LIT>' , filterFieldTypes : OSD_FIELD_TYPES . NUMBER , } , { name : '<STR_LIT>' , default : null , write : ( ) = > { } , } , { name : '<STR_LIT>' , default : autoInterval , modifyAggConfigOnSearchRequestStart ( aggConfig , searchSource , options ) { const field = aggConfig . getField ( ) ; const aggBody = field . scripted   ? { script : { source : field . script , lang : field . lang } } : { field : field . name } ; const childSearchSource = searchSource . createChild ( ) . setField ( '<STR_LIT>' , <NUM_LIT> ) . setField ( '<STR_LIT>' , { maxAgg : { max : aggBody , } , minAgg : { min : aggBody , } , } ) ; return childSearchSource . fetch ( options ) . then ( ( resp ) = > { const min = resp . aggregations   ? . minAgg   ? . value   ? ? <NUM_LIT> ; const max = resp . aggregations   ? . maxAgg   ? . value   ? ? <NUM_LIT> ; aggConfig . setAutoBounds ( { min , max , } ) ; } ) . catch ( ( e ) = > { if ( e . name == = '<STR_LIT>' ) return ; throw new Error ( i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) ) ; } ) ; } , write ( aggConfig , output ) { const values = aggConfig . getAutoBounds ( ) ; output . params . interval = calculateHistogramInterval ( { values , interval : aggConfig . params . interval , maxBucketsUiSettings : getConfig ( UI_SETTINGS . HISTOGRAM_MAX_BARS ) , maxBucketsUserInput : aggConfig . params . maxBars , intervalBase : aggConfig . params . intervalBase , esTypes : aggConfig . params . field   ? . spec   ? . esTypes | | [ ] , } ) ; } , } , { name : '<STR_LIT>' , shouldShow ( agg ) { return isAutoInterval ( get ( agg , '<STR_LIT>' ) ) ; } , write : ( ) = > { } , } , { name : '<STR_LIT>' , default : false , write ( aggConfig , output ) { if ( aggConfig . params . min_doc_count ) { output . params . min_doc_count = <NUM_LIT> ; } else { output . params . min_doc_count = <NUM_LIT> ; } } , } , { name : '<STR_LIT>' , default : false , write : ( ) = > { } , } , { name : '<STR_LIT>' , default : { min : '<STR_LIT>' , max : '<STR_LIT>' , } , write ( aggConfig , output ) { const { min , max } = aggConfig . params . extended_bounds ; if ( aggConfig . params . has_extended_bounds & & ( min | | min == = <NUM_LIT> ) & & ( max | | max == = <NUM_LIT> ) ) { output . params . extended_bounds = { min , max } ; } } , shouldShow : ( aggConfig ) = > aggConfig . params . has_extended_bounds , } , ] , } ) ; </s>
<s> import { <EOL> Component , <EOL> OnInit , <EOL> OnDestroy , <EOL> ChangeDetectionStrategy <EOL> } from '<STR_LIT>' ; <EOL> import Debug = require ( '<STR_LIT>' ) ; <EOL> const debug = Debug ( '<STR_LIT>' ) ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> template :   ` <EOL> < router - outlet > < / router - outlet > <EOL>     ` , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class RootComponent implements OnInit , OnDestroy { <EOL> ngOnInit ( ) { <EOL> debug ( '<STR_LIT>' ) ; <EOL> } <EOL> ngOnDestroy ( ) { <EOL> debug ( '<STR_LIT>' ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> ExpressionValueBoxed <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExecutionContextSearch <EOL> } from '<STR_LIT>' ; <EOL> export type ExpressionValueSearchContext = ExpressionValueBoxed < '<STR_LIT>' , ExecutionContextSearch > ; <EOL> export type OPENSEARCH_DASHBOARDS_CONTEXT_NAME = '<STR_LIT>' ; <EOL> export type OpenSearchDashboardsContext = ExpressionValueSearchContext ; <EOL> export const opensearchDashboardsContext = { <EOL> name : '<STR_LIT>' , <EOL> from : { <EOL> null : ( ) = > { <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> } ; <EOL> } , <EOL> } , <EOL> to : { <EOL> null : ( ) = > { <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> } ; <EOL> } , <EOL> } , <EOL> } ; </s>
<s> export const action = < A extends any [ ] > ( func , name = "<STR_LIT>" ) : ( ( ... args : A ) = > void ) = > { <EOL> ( func as any ) . __name = name ; <EOL> return func as any ; <EOL> } ; </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> import { <EOL> toRegexStr <EOL> } from '<STR_LIT>' ; <EOL> const list = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ] ; <EOL> export const visibility = ( ) = > [ <EOL> [ new RegExp ( ` ^ visibility - ( ? < value > $ { toRegexStr ( list ) } ) $ ` ) , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> value <EOL> } = groups as { <EOL> value : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` visibility - $ { value } :   $ { value } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import { <EOL> createUserKvs <EOL> } from "<STR_LIT>" ; <EOL> export const getUserList = async ( ) = > { <EOL> const userKVS = await createUserKvs ( ) ; <EOL> return userKVS . someUserNames ( ) ; <EOL> } ; </s>
<s> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer <EOL> } from '<STR_LIT>' ; <EOL> export const boxSizing = ( ) = > [ <EOL> [ / ^ box - sizing - ( ? < value > content - box | border - box ) $ / , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> value <EOL> } = groups as { <EOL> value : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` box - sizing :   $ { value } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> nodeTypes <EOL> } from '<STR_LIT>' ; <EOL> import * as ast from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> KueryNode , <EOL> IFieldType , <EOL> LatLon <EOL> } from '<STR_LIT>' ; <EOL> export function buildNodeParams ( fieldName , params ) { <EOL> params = _ . pick ( params , '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> const fieldNameArg = nodeTypes . literal . buildNode ( fieldName ) ; <EOL> const args = _ . map ( params , ( value , key ) = > { <EOL> const latLon =   ` $ { value . lat } ,   $ { value . lon } ` ; <EOL> return nodeTypes . namedArg . buildNode ( key , latLon ) ; <EOL> } ) ; <EOL> return { <EOL> arguments : [ fieldNameArg , ... args ] , <EOL> } ; <EOL> } <EOL> export function toOpenSearchQuery ( node , indexPattern   ? , config = { } , context = { } ) { <EOL> const [ fieldNameArg , ... args ] = node . arguments ; <EOL> const fullFieldNameArg = { <EOL> ... fieldNameArg , <EOL> value : context ? . nested   ?   ` $ { context . nested . path } . $ { fieldNameArg . value } ` : fieldNameArg . value , <EOL> } ; <EOL> const fieldName = nodeTypes . literal . toOpenSearchQuery ( fullFieldNameArg ) as string ; <EOL> const fieldList = indexPattern ? . fields   ? ? [ ] ; <EOL> const field = fieldList . find ( ( fld ) = > fld . name == = fieldName ) ; <EOL> const queryParams = args . reduce ( ( acc , arg ) = > { <EOL> const snakeArgName = _ . snakeCase ( arg . name ) ; <EOL> return { <EOL> ... acc , <EOL> [ snakeArgName ] : ast . toOpenSearchQuery ( arg ) , <EOL> } ; <EOL> } , { } ) ; <EOL> if ( field ? . scripted ) { <EOL> throw new Error ( ` Geo bounding box query does not support scripted fields ` ) ; <EOL> } <EOL> return { <EOL> geo_bounding_box : { <EOL> [ fieldName ] : queryParams , <EOL> ignore_unmapped : true , <EOL> } , <EOL> } ; <EOL> } </s>
<s> const elementTypes = { <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> '<STR_LIT>' : { } , <EOL> } ; <EOL> export const elementNames = Object . keys ( elementTypes ) ; <EOL> export const LIMIT_QBLIQUE_ANGLE = <NUM_LIT> ; </s>
<s> import Board from '<STR_LIT>' ; <EOL> import { <EOL> getData <EOL> } from '<STR_LIT>' ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> document . body . innerHTML =   ` <EOL> < div id = "<STR_LIT>" > < / div > <EOL>         ` ; <EOL> const opts = { <EOL> width : <NUM_LIT> , <EOL> height : <NUM_LIT> , <EOL> contextWidth : <NUM_LIT> , <EOL> contextHeight : <NUM_LIT> , <EOL> devicePixelRatio : <NUM_LIT> <EOL> } ; <EOL> const mount = document . querySelector ( '<STR_LIT>' ) as HTMLDivElement ; <EOL> const board = new Board ( mount , opts ) ; <EOL> const ctx = board . getContext ( ) ; <EOL> const data = getData ( ) ; <EOL> board . clear ( ) ; <EOL> ctx . clearRect ( <NUM_LIT> , <NUM_LIT> , opts . width , opts . height ) ; <EOL> ctx . setFillStyle ( '<STR_LIT>' ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , opts . width , opts . height ) ; <EOL> data . elements . forEach ( ele = > { <EOL> ctx . setFillStyle ( ele . desc . color ) ; <EOL> ctx . fillRect ( ele . x , ele . y , ele . w , ele . h ) ; <EOL> } ) ; <EOL> board . draw ( ) ; <EOL> const originCtx = board . getOriginContext2D ( ) ; <EOL> const originCalls = originCtx . __getDrawCalls ( ) ; <EOL> expect ( originCalls ) . toMatchSnapshot ( ) ; <EOL> const displayCtx = board . getDisplayContext2D ( ) ; <EOL> const displayCalls = displayCtx . __getDrawCalls ( ) ; <EOL> expect ( displayCalls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> CommonModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HttpClientModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ModuleWithProviders , <EOL> NgModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FontAwesomeModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> InfiniteScrollModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DropzoneDirective <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ImagePipe <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AngularMaterialModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fontawesomeImports <EOL> } from '<STR_LIT>' ; <EOL> fontawesomeImports ( ) ; <EOL> @ NgModule ( { <EOL> imports : [ CommonModule , HttpClientModule , AngularMaterialModule , InfiniteScrollModule , FontAwesomeModule , ] , <EOL> declarations : [ DropzoneDirective , ImagePipe ] , <EOL> exports : [ HttpClientModule , AngularMaterialModule , DropzoneDirective , InfiniteScrollModule , FontAwesomeModule , ImagePipe , ] , <EOL> } ) export class SharedModule { <EOL> public static forRoot ( ) { <EOL> return { <EOL> ngModule : SharedModule , <EOL> providers : [ ImagePipe ] , <EOL> } ; <EOL> } <EOL> } </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer , <EOL> getUnitAndNum <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> import { <EOL> GAP_ENUM_STR , <EOL> NONNEGATIVE_NUMBER_REGEX_STR , <EOL> UNIT_ENUM_STR , <EOL> } from '<STR_LIT>' ; <EOL> export const gap = ( ) = > [ <EOL> [ new RegExp ( ` ^ gap - ( ( ( ? < num > $ { NONNEGATIVE_NUMBER_REGEX_STR } ) ( ? < unit > $ { UNIT_ENUM_STR } ) ? ) | ( ? < value > $ { GAP_ENUM_STR } ) ) $ ` ) , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> num , <EOL> unit , <EOL> value <EOL> } = groups as { <EOL> num   ? : string ; <EOL> unit   ? : string ; <EOL> value : string ; <EOL> } ; <EOL> const newValue = value | | getUnitAndNum ( unit , num ) ; <EOL> return ConvertToCssObject ( [ ` column - gap :   $ { newValue } ` ,   ` row - gap :   $ { newValue } ` , ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> export interface CircleLockIconProps { <EOL> color   ? : string ; <EOL> className   ? : string ; <EOL> } <EOL> export const CircleLockIcon = props = > { <EOL> const color = props . color | | "<STR_LIT>" ; <EOL> return ( < svg width = "<STR_LIT>" height = "<STR_LIT>" viewBox = "<STR_LIT>" version = "<STR_LIT>" xmlns = "<STR_LIT>" className = { props . className } > < g fill = "<STR_LIT>" fillRule = "<STR_LIT>" transform = "<STR_LIT>" > < circle id = "<STR_LIT>" stroke = { color } strokeWidth = "<STR_LIT>" cx = "<STR_LIT>" cy = "<STR_LIT>" r = "<STR_LIT>" > < / circle > < path d = "<STR_LIT>" fill = { color } fillRule = "<STR_LIT>" > < / path > < / g > < / svg > ) ; } ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> makeNestedLabel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> siblingPipelineAggHelper <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggConfigSerialized , <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsBucketAvg extends BaseAggParams { <EOL> customMetric   ? : AggConfigSerialized ; <EOL> customBucket   ? : AggConfigSerialized ; <EOL> } <EOL> const overallAverageLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const averageBucketTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export const getBucketAvgMetricAgg = ( ) = > { <EOL> const { <EOL> subtype , <EOL> params , <EOL> getSerializedFormat <EOL> } = siblingPipelineAggHelper ; <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . AVG_BUCKET , <EOL> title : averageBucketTitle , <EOL> makeLabel : ( agg ) = > makeNestedLabel ( agg , overallAverageLabel ) , <EOL> subtype , <EOL> params : [ ... params ( ) ] , <EOL> getSerializedFormat , <EOL> getValue ( agg , bucket ) { <EOL> const customMetric = agg . getParam ( '<STR_LIT>' ) ; <EOL> const customBucket = agg . getParam ( '<STR_LIT>' ) ; <EOL> const scaleMetrics = customMetric . type & & customMetric . type . isScalable ( ) ; <EOL> let value = bucket [ agg . id ] & & bucket [ agg . id ] . value ; <EOL> if ( scaleMetrics & & customBucket . type . name == = '<STR_LIT>' ) { <EOL> const aggInfo = customBucket . write ( ) ; <EOL> value *= get ( aggInfo , '<STR_LIT>' , <NUM_LIT> ) ; <EOL> } <EOL> return value ; <EOL> } , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> CreateController <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ServerController , <EOL> ServerControllerConstructor <EOL> } from '<STR_LIT>' ; <EOL> const createController = ( c , location , context ) = > { <EOL> return new c ( location , context ) ; <EOL> } ; <EOL> export default createController ; </s>
<s> import { <EOL> Reporter , <EOL> Storage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HttpSetup <EOL> } from '<STR_LIT>' ; <EOL> interface AnalyicsReporterConfig { <EOL> localStorage : Storage ; debug : boolean ; fetch : HttpSetup ; <EOL> } <EOL> export function createReporter ( config ) { <EOL> const { <EOL> localStorage , <EOL> debug <EOL> } = config ; <EOL> return new Reporter ( { <EOL> debug , <EOL> storage : localStorage , <EOL> } ) ; <EOL> } </s>
<s> import test from "<STR_LIT>" ; <EOL> import { <EOL> testCombinations , <EOL> testStrictness <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> delay <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> observable , <EOL> autorun , <EOL> runInAction , <EOL> computed <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> computedAsync <EOL> } from "<STR_LIT>" ; <EOL> test ( "<STR_LIT>" , async ( assert ) = > { <EOL> const o = observable ( { <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> <EOL> } ) ; <EOL> const r = computedAsync ( <NUM_LIT> , async ( ) = > { <EOL> const vx = o . x , <EOL> vy = o . y ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> return vx + vy ; <EOL> } ) ; <EOL> assert . equal ( r . busy , true ) ; <EOL> } ) ; <EOL> testCombinations ( "<STR_LIT>" , async ( delayed , assert ) = > { <EOL> const o = observable ( { <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> <EOL> } ) ; <EOL> const r = computedAsync ( <NUM_LIT> , async ( ) = > { <EOL> const vx = o . x , <EOL> vy = o . y ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> return vx + vy ; <EOL> } , delayed   ? <NUM_LIT> : <NUM_LIT> ) ; <EOL> let expect = ( v ) = > assert . equal ( v , <NUM_LIT> ) ; <EOL> function expected ( expecting ) { <EOL> return new Promise < void > ( resolve = > { <EOL> expect = got = > { <EOL> assert . equal ( got , expecting , "<STR_LIT>" + expecting ) ; <EOL> resolve ( ) ; <EOL> } ; <EOL> } ) ; <EOL> } <EOL> let stopRunner = autorun ( ( ) = > expect ( r . value ) ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . y = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> runInAction ( ( ) = > o . y = <NUM_LIT> ) ; <EOL> assert . equal ( r . value , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> expect = v = > { <EOL> assert . fail ( ` unexpected [ <NUM_LIT> ] :   $ { v } ` ) ; <EOL> } ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> expect = v = > assert . equal ( v , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> stopRunner = autorun ( ( ) = > expect ( r . value ) ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> expect = v = > assert . fail ( ` unexpected [ <NUM_LIT> ] :   $ { v } ` ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> } ) ; <EOL> testStrictness ( "<STR_LIT>" , async ( assert ) = > { <EOL> const o = observable ( { <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> <EOL> } ) ; <EOL> const r = computedAsync ( <NUM_LIT> , async ( ) = > { <EOL> const vx = o . x , <EOL> vy = o . y ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> return vx + vy ; <EOL> } ) ; <EOL> let expect = ( v ) = > assert . equal ( v , <NUM_LIT> ) ; <EOL> function expected ( expecting ) { <EOL> return new Promise < void > ( resolve = > { <EOL> expect = got = > { <EOL> assert . equal ( got , expecting , "<STR_LIT>" + expecting ) ; <EOL> resolve ( ) ; <EOL> } ; <EOL> } ) ; <EOL> } <EOL> let stopRunner = autorun ( ( ) = > expect ( r . value ) ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . y = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> runInAction ( ( ) = > o . y = <NUM_LIT> ) ; <EOL> assert . equal ( r . value , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> expect = v = > { <EOL> assert . fail ( ` unexpected [ <NUM_LIT> ] :   $ { v } ` ) ; <EOL> } ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> expect = v = > assert . equal ( v , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> stopRunner = autorun ( ( ) = > expect ( r . value ) ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expected ( <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> expect = v = > assert . fail ( ` unexpected [ <NUM_LIT> ] :   $ { v } ` ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> } ) ; <EOL> testStrictness ( "<STR_LIT>" , async ( assert ) = > { <EOL> const o = observable ( { <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> <EOL> } ) ; <EOL> const r = computedAsync < number > ( <NUM_LIT> , ( ) = > { <EOL> return o . x + o . y ; <EOL> } ) ; <EOL> assert . equal ( r . value , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> assert . equal ( r . value , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> runInAction ( ( ) = > o . y = <NUM_LIT> ) ; <EOL> assert . equal ( r . value , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> return Promise . resolve ( ) ; <EOL> } ) ; <EOL> testCombinations ( "<STR_LIT>" , async ( delayed , assert ) = > { <EOL> const o = observable ( { <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> <EOL> } ) ; <EOL> const r = computedAsync ( { <EOL> init : <NUM_LIT> , <EOL> fetch : async ( ) = > { <EOL> const vx = o . x , <EOL> vy = o . y ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> return vx + vy ; <EOL> } , <EOL> revert : true , <EOL> delay : delayed   ? <NUM_LIT> : <NUM_LIT> <EOL> } ) ; <EOL> const transitions = [ ] ; <EOL> async function expect ( ... expected ) { <EOL> let timeout = <NUM_LIT> ; <EOL> while ( transitions . length < expected . length ) { <EOL> timeout + + ; <EOL> assert . doesNotEqual ( timeout , <NUM_LIT> ,   ` waiting for   $ { JSON . stringify ( expected ) } , seeing   $ { JSON . stringify ( transitions ) } ` ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> } <EOL> assert . deepEqual ( transitions , expected ) ; <EOL> transitions . length = <NUM_LIT> ; <EOL> } <EOL> let stopRunner = autorun ( ( ) = > transitions . push ( r . value ) ) ; <EOL> await expect ( <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expect ( <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . y = <NUM_LIT> ) ; <EOL> await expect ( <NUM_LIT> , <NUM_LIT> ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await expect ( <NUM_LIT> , <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> runInAction ( ( ) = > o . y = <NUM_LIT> ) ; <EOL> assert . equal ( r . value , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> assert . equal ( r . value , <NUM_LIT> , "<STR_LIT>" ) ; <EOL> await expect ( ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> await expect ( ) ; <EOL> stopRunner = autorun ( ( ) = > transitions . push ( r . value ) ) ; <EOL> runInAction ( ( ) = > o . x = <NUM_LIT> ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> await expect ( <NUM_LIT> , <NUM_LIT> ) ; <EOL> stopRunner ( ) ; <EOL> } ) ; <EOL> testCombinations ( "<STR_LIT>" , async ( delayed , assert ) = > { <EOL> const o = observable ( { <EOL> b : true <EOL> } ) ; <EOL> const r = computedAsync ( <NUM_LIT> , ( ) = > o . b   ? Promise . reject ( "<STR_LIT>" ) : Promise . resolve ( <NUM_LIT> ) , delayed   ? <NUM_LIT> : <NUM_LIT> ) ; <EOL> assert . equal ( r . value , <NUM_LIT> ) ; <EOL> const changes = [ ] ; <EOL> const stopMonitoring = autorun ( ( ) = > { <EOL> changes . push ( { <EOL> error : r . error , <EOL> value : r . value <EOL> } ) ; <EOL> } ) ; <EOL> assert . deepEqual ( changes , [ { <EOL> error : undefined , <EOL> value : <NUM_LIT> <EOL> } ] ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> assert . deepEqual ( changes , [ { <EOL> error : undefined , <EOL> value : <NUM_LIT> <EOL> } , { <EOL> error : "<STR_LIT>" , <EOL> value : <NUM_LIT> <EOL> } ] ) ; <EOL> runInAction ( ( ) = > o . b = false ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> assert . deepEqual ( changes , [ { <EOL> error : undefined , <EOL> value : <NUM_LIT> <EOL> } , { <EOL> error : "<STR_LIT>" , <EOL> value : <NUM_LIT> <EOL> } , { <EOL> error : undefined , <EOL> value : <NUM_LIT> <EOL> } ] ) ; <EOL> runInAction ( ( ) = > o . b = true ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> assert . deepEqual ( changes , [ { <EOL> error : undefined , <EOL> value : <NUM_LIT> <EOL> } , { <EOL> error : "<STR_LIT>" , <EOL> value : <NUM_LIT> <EOL> } , { <EOL> error : undefined , <EOL> value : <NUM_LIT> <EOL> } , { <EOL> error : "<STR_LIT>" , <EOL> value : <NUM_LIT> <EOL> } ] ) ; <EOL> stopMonitoring ( ) ; <EOL> } ) ; <EOL> testCombinations ( "<STR_LIT>" , async ( delayed , assert ) = > { <EOL> const o = observable ( { <EOL> b : true <EOL> } ) ; <EOL> const r = computedAsync < string > ( { <EOL> init : "<STR_LIT>" , <EOL> fetch : ( ) = > o . b   ? Promise . reject ( "<STR_LIT>" ) : Promise . resolve ( "<STR_LIT>" ) , <EOL> error : e = > "<STR_LIT>" + e , <EOL> delay : delayed   ? <NUM_LIT> : <NUM_LIT> <EOL> } ) ; <EOL> assert . equal ( r . value , "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> const valueChanges = [ ] ; <EOL> const stopCountValueChanges = autorun ( ( ) = > { <EOL> valueChanges . push ( r . value ) ; <EOL> } ) ; <EOL> const errorChanges = [ ] ; <EOL> const stopCountErrorChanges = autorun ( ( ) = > { <EOL> errorChanges . push ( r . error ) ; <EOL> } ) ; <EOL> assert . deepEqual ( valueChanges , [ "<STR_LIT>" ] , "<STR_LIT>" ) ; <EOL> assert . deepEqual ( errorChanges , [ undefined ] , "<STR_LIT>" ) ; <EOL> assert . equal ( r . value , "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> assert . deepEqual ( valueChanges , [ "<STR_LIT>" , "<STR_LIT>" ] , "<STR_LIT>" ) ; <EOL> assert . deepEqual ( errorChanges , [ undefined , "<STR_LIT>" ] , "<STR_LIT>" ) ; <EOL> assert . equal ( r . value , "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> assert . equal ( r . error , "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> runInAction ( ( ) = > o . b = false ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> assert . deepEqual ( valueChanges , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , "<STR_LIT>" ) ; <EOL> assert . deepEqual ( errorChanges , [ undefined , "<STR_LIT>" , undefined ] , "<STR_LIT>" ) ; <EOL> assert . equal ( r . value , "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> assert . equal ( r . error , undefined , "<STR_LIT>" ) ; <EOL> runInAction ( ( ) = > o . b = true ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> assert . deepEqual ( valueChanges , [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] , "<STR_LIT>" ) ; <EOL> assert . deepEqual ( errorChanges , [ undefined , "<STR_LIT>" , undefined , "<STR_LIT>" ] , "<STR_LIT>" ) ; <EOL> assert . equal ( r . value , "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> assert . equal ( r . error , "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> stopCountErrorChanges ( ) ; <EOL> stopCountValueChanges ( ) ; <EOL> } ) ; <EOL> testCombinations ( "<STR_LIT>" , async ( delayed , assert ) = > { <EOL> const o = observable ( { <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> <EOL> } ) ; <EOL> const r = computedAsync < number > ( { <EOL> init : <NUM_LIT> , <EOL> fetch : async ( ) = > { <EOL> return o . x + o . y ; <EOL> } , <EOL> delay : delayed   ? <NUM_LIT> : <NUM_LIT> <EOL> } ) ; <EOL> class Test { <EOL> @ computed get val ( ) { <EOL> return r . value ; <EOL> } <EOL> } <EOL> const t = new Test ( ) ; <EOL> const stop = autorun ( ( ) = > t . val ) ; <EOL> assert . equal ( t . val , <NUM_LIT> ) ; <EOL> stop ( ) ; <EOL> await delay ( <NUM_LIT> ) ; <EOL> } ) ; </s>
<s> import { <EOL> ExpressionTypeDefinition , <EOL> ExpressionValueBoxed <EOL> } from '<STR_LIT>' ; <EOL> const name = '<STR_LIT>' ; <EOL> / ** <EOL> * Represents an object that is intended to be rendered . <EOL> * / <EOL> export type ExpressionValueRender < T > = ExpressionValueBoxed < typeof name , { <EOL> as : string ; value : T ; <EOL> } > ; <EOL> deprecated <EOL> export type Render < T > = ExpressionValueRender < T > ; <EOL> export const render = { <EOL> name , <EOL> from : { <EOL> '<STR_LIT>' : < T > ( v ) : ExpressionValueRender < T > = > ( { type : name , as : '<STR_LIT>' , value : v , } ) , } , } ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> noop <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> forwardModifyAggConfigOnSearchRequestStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IMetricAggConfig , <EOL> MetricAggParam <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parentPipelineAggWriter <EOL> } from '<STR_LIT>' ; <EOL> const metricAggFilter = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ] ; <EOL> export const parentPipelineType = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export const parentPipelineAggHelper = { <EOL> subtype : parentPipelineType , <EOL> params ( ) { <EOL> return [ { <EOL> name : '<STR_LIT>' , <EOL> default : '<STR_LIT>' , <EOL> write : parentPipelineAggWriter , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> allowedAggs : metricAggFilter , <EOL> makeAgg ( termsAgg , state = { <EOL> type : '<STR_LIT>' <EOL> } ) { <EOL> const metricAgg = termsAgg . aggConfigs . createAggConfig ( state , { <EOL> addToAggConfigs : false <EOL> } ) ; <EOL> metricAgg . id = termsAgg . id + '<STR_LIT>' ; <EOL> return metricAgg ; <EOL> } , <EOL> modifyAggConfigOnSearchRequestStart : forwardModifyAggConfigOnSearchRequestStart ( '<STR_LIT>' ) , <EOL> write : noop , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> write : noop , <EOL> } , ] as Array < MetricAggParam < IMetricAggConfig > > ; <EOL> } , <EOL> getSerializedFormat ( agg ) { <EOL> let subAgg ; <EOL> const customMetric = agg . getParam ( '<STR_LIT>' ) ; <EOL> if ( customMetric ) { <EOL> subAgg = customMetric ; <EOL> } else { <EOL> subAgg = agg . aggConfigs . byId ( agg . getParam ( '<STR_LIT>' ) ) ; <EOL> } <EOL> return subAgg   ? subAgg . type . getSerializedFormat ( subAgg ) : { } ; <EOL> } , <EOL> } ; </s>
<s> export class GetBySkuProductQuery { <EOL> public constructor ( public readonly sku ) { } <EOL> } </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent , <EOL> ReactNode <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css , <EOL> keyframes <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> zIndex <EOL> } from "<STR_LIT>" ; <EOL> interface Props { <EOL> children : ReactNode ; <EOL> } <EOL> const Modal = ( { <EOL> children <EOL> } ) = > ( < div css = { wrapperStyle } > { children } < / div > ) ; const wrapperStyle = css ( { position : "<STR_LIT>" , top : <NUM_LIT> , left : <NUM_LIT> , right : <NUM_LIT> , bottom : <NUM_LIT> , zIndex : zIndex . modal , overflow : "<STR_LIT>" , backgroundColor : "<STR_LIT>" , willChange : "<STR_LIT>" , animation :   ` $ { keyframes   ` from { opacity : <NUM_LIT> ; } to { opacity : <NUM_LIT> ; } ` } <NUM_LIT> s ease ` , } ) ; export default Modal ; </s>
<s> import { <EOL> omit , <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter <EOL> } from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> param { <EOL> object <EOL> } <EOL> filter returns { <EOL> object <EOL> } <EOL> export const cleanFilter = ( filter ) : Filter = > omit ( filter , [ '<STR_LIT>' , '<STR_LIT>' ] ) as Filter ; <EOL> export const isFilterDisabled = ( filter ) : boolean = > get ( filter , '<STR_LIT>' , false ) ; </s>
<s> import { <EOL> assert <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> describe , <EOL> it <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> metaesEvalModule <EOL> } from "<STR_LIT>" ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> it ( "<STR_LIT>" , ( ) = > { <EOL> let result ; <EOL> metaesEvalModule ( ` export function function1 ( ) { } ; export const test = <NUM_LIT> ; ` , ( _result ) = > ( result = _result ) ) ; <EOL> assert . hasAllKeys ( result , [ "<STR_LIT>" , "<STR_LIT>" ] ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> export const MAX_SIZE = <NUM_LIT> * <NUM_LIT> ; <EOL> export const EXTENSIONS = [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , ] as <EOL> const ; <EOL> export const CONTENT_TYPE_FROM_EXTENSION = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> as <EOL> const ; <EOL> export const EXTENSION_FROM_CONTENT_TYPE = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" <EOL> } <EOL> as <EOL> const ; <EOL> export const BASE58_ALPHABET = "<STR_LIT>" ; <EOL> export const MIN_LEN = <NUM_LIT> ; <EOL> export const MAX_LEN = <NUM_LIT> ; <EOL> export const ALIAS_NAME_REGEX = / [ a - zA - Z0 - <NUM_LIT> - _ ] + / ; <EOL> export const ALIAS_TAG_REGEX = / [ a - zA - Z0 - <NUM_LIT> - _ \ . ] + / ; <EOL> export const ALIAS_NAME_REGEX_TEST = new RegExp ( ` ^ $ { ALIAS_NAME_REGEX . source } $ ` ) ; <EOL> export const ALIAS_TAG_REGEX_TEST = new RegExp ( ` ^ $ { ALIAS_TAG_REGEX . source } $ ` ) ; <EOL> export const ID_PATH =   ` : id ( [ $ { BASE58_ALPHABET } ] { $ { MIN_LEN } , $ { MAX_LEN } } ) : ext ( ( ? : \ \ . ( ? : $ { EXTENSIONS . join ( "<STR_LIT>" ) } ) ) ? ) ` ; <EOL> export const ALIAS_PATH =   ` : alias ( $ { ALIAS_NAME_REGEX . source } ) @ : tag ( $ { ALIAS_TAG_REGEX . source } ) : ext ( ( ? : \ \ . ( ? : $ { EXTENSIONS . join ( "<STR_LIT>" ) } ) ) ? ) ` ; <EOL> export const S3_BUCKET = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const DYNAMO_ALIAS_TABLE = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const DYNAMO_USER_TABLE = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const S3_REGION = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const S3_ACCESS_KEY_ID = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const S3_SECRET_ACCESS_KEY = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const DYNAMO_REGION = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const DYNAMO_ACCESS_KEY_ID = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const DYNAMO_SECRET_ACCESS_KEY = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const GITHUB_CLIENT_ID = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const GITHUB_CLIENT_SECRET = Deno . env . get ( "<STR_LIT>" )   ! ; <EOL> export const GITHUB_CALLBACK_URL = Deno . env . get ( "<STR_LIT>" ) ; </s>
<s> import { <EOL> Config as SchemaGeneratorConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Config <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> readConfigFromFile <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> addUnique , <EOL> findFile <EOL> } from '<STR_LIT>' ; <EOL> export const defaultConfig = { <EOL> path : "<STR_LIT>" , <EOL> tsConfigPath : findFile ( process . cwd ( ) , "<STR_LIT>" ) | | "<STR_LIT>" , <EOL> configFile : "<STR_LIT>" , <EOL> sortProperties : true , <EOL> asComment : true , <EOL> skipTypeCheck : false , <EOL> detectGraphQL : true , <EOL> graphQLExpandedTypes : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> graphQLRemoveProps : [ '<STR_LIT>' ] , <EOL> expandTypes : [ ] , <EOL> removeProps : [ ] , <EOL> types : [ ] , <EOL> jsonFormat : false , <EOL> modelVersion : "<STR_LIT>" , <EOL> } ; <EOL> export interface GetConfigResult { <EOL> / ** <EOL> * ts - to - openapi options <EOL> * / <EOL> config : Config ; <EOL> / ** <EOL> * ts - json - schema - generator Config <EOL> * / <EOL> schemaGeneratorConfig : SchemaGeneratorConfig ; <EOL> } <EOL> export function getConfig ( opts = { } ) { <EOL> const configFromFile = readConfigFromFile ( opts ) ; <EOL> const config = Object . assign ( defaultConfig , configFromFile . config , opts ) ; <EOL> if ( config . detectGraphQL ) { <EOL> config . expandTypes = addUnique ( config . expandTypes , ... config . graphQLExpandedTypes ) ; <EOL> config . removeProps = addUnique ( config . removeProps , ... config . graphQLRemoveProps ) ; <EOL> } <EOL> const schemaGeneratorConfig = { <EOL> path : config . path , <EOL> tsconfig : config . tsConfigPath , <EOL> expose : "<STR_LIT>" , <EOL> topRef : true , <EOL> jsDoc : "<STR_LIT>" , <EOL> sortProps : config . sortProperties , <EOL> strictTuples : false , <EOL> skipTypeCheck : config . skipTypeCheck , <EOL> extraTags : [ ] , <EOL> } ; <EOL> return { <EOL> config , <EOL> schemaGeneratorConfig <EOL> } ; <EOL> } </s>
<s> import { <EOL> Player <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Index <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> GridHelper <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> PlayerSprites <EOL> } from "<STR_LIT>" ; <EOL> export class Guard extends Player { <EOL> avatar : string ; constructor ( index ) { <EOL> super ( index , PlayerSprites . GRIM_REAPER , '<STR_LIT>' ) ; <EOL> this . color = '<STR_LIT>' ; <EOL> this . avatar = GridHelper . prefixUrl ( PlayerSprites . GRIM_REAPER_AVATAR ) ; <EOL> } <EOL> } </s>
<s> import React from "<STR_LIT>" ; <EOL> import SettingSection from "<STR_LIT>" ; <EOL> import { <EOL> Shortcut <EOL> } from "<STR_LIT>" ; <EOL> const ShortcutSection = ( ) = > { <EOL> return ( < > < SettingSection heading = "<STR_LIT>" > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < / SettingSection > < SettingSection heading = "<STR_LIT>" > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < Shortcut name = "<STR_LIT>" shortcutKey = "<STR_LIT>" id = "<STR_LIT>" / > < / SettingSection > < / > ) ; } ; export default ShortcutSection ; </s>
<s> import { <EOL> PluginInitializerContext <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OpenSearchDashboardsLegacyPlugin <EOL> } from '<STR_LIT>' ; <EOL> export const plugin = ( initializerContext ) = > new OpenSearchDashboardsLegacyPlugin ( initializerContext ) ; <EOL> export * from '<STR_LIT>' ; <EOL> export { <EOL> initAngularBootstrap <EOL> } <EOL> from '<STR_LIT>' ; <EOL> export { <EOL> PaginateDirectiveProvider , <EOL> PaginateControlsDirectiveProvider <EOL> } <EOL> from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; </s>
<s> export class TimeoutAPI { <EOL> private timeout_handlers = [ ] ; <EOL> setTimeout ( callback , delay ) { <EOL> const handle = window . setTimeout ( callback , delay ) ; <EOL> this . timeout_handlers . push ( handle ) ; <EOL> return handle ; <EOL> } <EOL> clearAllTimeouts ( ) { <EOL> for ( const handler of this . timeout_handlers ) { <EOL> clearTimeout ( handler ) ; <EOL> } <EOL> this . timeout_handlers = [ ] ; <EOL> } <EOL> } </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> useContext , <EOL> useCallback <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Observer <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> StoreContext <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> IconButton <EOL> } from "<STR_LIT>" ; <EOL> import ReactionLayout from "<STR_LIT>" ; <EOL> import { <EOL> toggleReaction , <EOL> sendReaction <EOL> } from "<STR_LIT>" ; <EOL> export const ReactionOpener = ( ) = > { <EOL> const store = useContext ( StoreContext ) ; <EOL> const onClickToggleReaction = useCallback ( toggleReaction ( store ) , [ store ] ) ; <EOL> const onClickSendReaction = useCallback ( sendReaction ( store ) , [ store ] ) ; <EOL> const { <EOL> ui <EOL> } = store ; <EOL> return ( < Observer > { ( ) = > ( < > < IconButton name = "<STR_LIT>" onClick = { onClickToggleReaction } / > { ui . isReactionOpen   ? ( < ReactionLayout onClickSend = { onClickSendReaction } / > ) : null } < / > ) } < / Observer > ) ; } ; </s>
<s> import { <EOL> createConnection <EOL> } from '<STR_LIT>' ; <EOL> export const DatabaseProvider = [ { <EOL> provide : '<STR_LIT>' , <EOL> useFactory : async ( ) = > await createConnection ( { <EOL> type : '<STR_LIT>' , <EOL> host : '<STR_LIT>' , <EOL> port : <NUM_LIT> , <EOL> username : '<STR_LIT>' , <EOL> password : '<STR_LIT>' , <EOL> database : '<STR_LIT>' , <EOL> entities : [ '<STR_LIT>' ] , <EOL> synchronize : true , <EOL> } ) , <EOL> } , ] ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Assign <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . CUMULATIVE_SUM > ; <EOL> type Arguments = Assign < AggArgs , { <EOL> customMetric   ? : AggExpressionType ; <EOL> } > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , Arguments , Output > ; <EOL> export const aggCumulativeSum = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> metricAgg : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customMetric : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> buckets_path : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . CUMULATIVE_SUM , <EOL> params : { <EOL> ... rest , <EOL> customMetric : args . customMetric ? . value , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> export const fontWeight = ( ) = > [ <EOL> [ / ^ ( font - weight | fw ) - ( ? < value > [ <NUM_LIT> - <NUM_LIT> ] <NUM_LIT> | bold | bolder | inherit | initial | lighter | normal | unset ) $ / , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> value <EOL> } = groups as { <EOL> value : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` font - weight :   $ { value } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import { <EOL> ImageMimeType <EOL> } from "<STR_LIT>" ; <EOL> / ** <EOL> * Class for holding and downloading glTF file data <EOL> * / <EOL> export class GLTFData { <EOL> / ** <EOL> * Object which contains the file name as the key and its data as the value <EOL> * / <EOL> glTFFiles : { <EOL> [ fileName ] : string | Blob ; <EOL> } ; <EOL> / ** <EOL> * Initializes the glTF file object <EOL> * / <EOL> public constructor ( ) { <EOL> this . glTFFiles = { } ; <EOL> } <EOL> / ** <EOL> * Downloads the glTF data as files based on their names and data <EOL> * / <EOL> public downloadFiles ( ) { <EOL> param str param suffix returns <EOL> function endsWith ( str , suffix ) { <EOL> return str . indexOf ( suffix , str . length - suffix . length ) != = - <NUM_LIT> ; <EOL> } <EOL> for ( let key in this . glTFFiles ) { <EOL> let link = document . createElement ( '<STR_LIT>' ) ; <EOL> document . body . appendChild ( link ) ; <EOL> link . setAttribute ( "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> link . download = key ; <EOL> let blob = this . glTFFiles [ key ] ; <EOL> let mimeType ; <EOL> if ( endsWith ( key , "<STR_LIT>" ) ) { <EOL> mimeType = { <EOL> type : "<STR_LIT>" <EOL> } ; <EOL> } else if ( endsWith ( key , "<STR_LIT>" ) ) { <EOL> mimeType = { <EOL> type : "<STR_LIT>" <EOL> } ; <EOL> } else if ( endsWith ( key , "<STR_LIT>" ) ) { <EOL> mimeType = { <EOL> type : "<STR_LIT>" <EOL> } ; <EOL> } else if ( endsWith ( key , "<STR_LIT>" ) | | endsWith ( key , "<STR_LIT>" ) ) { <EOL> mimeType = { <EOL> type : ImageMimeType . JPEG <EOL> } ; <EOL> } else if ( endsWith ( key , "<STR_LIT>" ) ) { <EOL> mimeType = { <EOL> type : ImageMimeType . PNG <EOL> } ; <EOL> } <EOL> link . href = window . URL . createObjectURL ( new Blob ( [ blob ] , mimeType ) ) ; <EOL> link . click ( ) ; <EOL> } <EOL> } <EOL> } </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Effect <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataPersistence <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fromTimelineActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimelinePartialState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimelineDataService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class TimelineEffects { <EOL> @ Effect ( ) getTimeline $ = this . dp . fetch ( fromTimelineActions . Types . GetTimeline , { <EOL> run : ( action ) = > { <EOL> return this . timelineDataService . getTimeline ( action . payload ) . pipe ( map ( data = > new fromTimelineActions . GetTimelineSuccess ( data ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromTimelineActions . GetTimelineFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> constructor ( private dp , private timelineDataService ) { } <EOL> } </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import AntdTooltip from '<STR_LIT>' ; <EOL> import * as S from '<STR_LIT>' ; <EOL> import { <EOL> ConfirmMessageProps <EOL> } from '<STR_LIT>' ; <EOL> export const ConfirmMessage = ( { <EOL> children , <EOL> placement = '<STR_LIT>' , <EOL> title , <EOL> onClick , <EOL> displayDuration = <NUM_LIT> , <EOL> icon , <EOL> } ) = > { <EOL> const [ visible , setVisible ] = React . useState < boolean > ( false ) ; <EOL> React . useEffect ( ( ) : ( ( ) = > void ) = > { <EOL> const timeout = setTimeout ( ( ) = > { <EOL> setVisible ( false ) ; <EOL> } , displayDuration ) ; <EOL> return ( ) : void = > { <EOL> clearTimeout ( timeout ) ; <EOL> } ; <EOL> } , [ visible , displayDuration ] ) ; <EOL> const showMessage = ( ) : void = > { <EOL> setVisible ( true ) ; <EOL> } ; <EOL> const handleClick = React . useCallback ( ( ) = > { <EOL> onClick & & onClick ( showMessage ) ; <EOL> } , [ onClick ] ) ; <EOL> const content = React . useMemo ( ( ) = > { <EOL> return ( < S . ConfirmMessage > { icon } < S . ConfirmMessageTitle > { title } < / S . ConfirmMessageTitle > < / S . ConfirmMessage > ) ; } , [ title , icon ] ) ; return ( < S . Message onClick = { handleClick } data - testid = "<STR_LIT>" > < AntdTooltip overlayStyle = { { maxWidth : '<STR_LIT>' } } autoAdjustOverflow = { false } title = { content } align = { { offset : [ <NUM_LIT> , <NUM_LIT> ] } } visible = { visible } placement = { placement } > { children } < / AntdTooltip > < / S . Message > ) ; } ; export default ConfirmMessage ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggTypesDependencies <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getResponseAggConfigClass , <EOL> IResponseAggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getPercentileValue <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsPercentileRanks extends BaseAggParams { <EOL> field : string ; values   ? : number [ ] ; <EOL> } <EOL> export type IPercentileRanksAggConfig = IResponseAggConfig ; <EOL> export interface PercentileRanksMetricAggDependencies { <EOL> getFieldFormatsStart : AggTypesDependencies [ '<STR_LIT>' ] ; <EOL> } <EOL> const getValueProps = ( getFieldFormatsStart ) = > { <EOL> return { <EOL> makeLabel ( this ) { <EOL> const { <EOL> getDefaultInstance <EOL> } = getFieldFormatsStart ( ) ; <EOL> const field = this . getField ( ) ; <EOL> const format = ( field & & field . format ) | | getDefaultInstance ( OSD_FIELD_TYPES . NUMBER ) ; <EOL> const customLabel = this . getParam ( '<STR_LIT>' ) ; <EOL> const label = customLabel | | this . getFieldDisplayName ( ) ; <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> format : format . convert ( this . key , '<STR_LIT>' ) , <EOL> label <EOL> } , <EOL> } ) ; <EOL> } , <EOL> } ; <EOL> } ; <EOL> export const getPercentileRanksMetricAgg = ( { <EOL> getFieldFormatsStart , <EOL> } ) = > { <EOL> return new MetricAggType < IPercentileRanksAggConfig > ( { <EOL> name : METRIC_TYPES . PERCENTILE_RANKS , <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> makeLabel ( agg ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> field : agg . getFieldDisplayName ( ) <EOL> } , <EOL> } ) ; <EOL> } , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : [ OSD_FIELD_TYPES . NUMBER , OSD_FIELD_TYPES . HISTOGRAM ] , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> default : [ ] , <EOL> } , { <EOL> write ( agg , output ) { <EOL> output . params . keyed = false ; <EOL> } , <EOL> } , ] , <EOL> getResponseAggs ( agg ) { <EOL> const ValueAggConfig = getResponseAggConfigClass ( agg , getValueProps ( getFieldFormatsStart ) ) ; <EOL> const values = agg . getParam ( '<STR_LIT>' ) ; <EOL> return values . map ( ( value ) = > new ValueAggConfig ( value ) ) ; <EOL> } , <EOL> getSerializedFormat ( agg ) { <EOL> return { <EOL> id : '<STR_LIT>' , <EOL> } ; <EOL> } , <EOL> getValue ( agg , bucket ) { <EOL> return getPercentileValue ( agg , bucket ) / <NUM_LIT> ; <EOL> } , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PrStatistics <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class TableReviewerStatisticsPresenter { <EOL> public sortData ( item , property ) { <EOL> switch ( property ) { <EOL> case '<STR_LIT>' : <EOL> return item . author . name ; <EOL> case '<STR_LIT>' : <EOL> return item . commentsCount ; <EOL> case '<STR_LIT>' : <EOL> return item . reviewers . length ; <EOL> default : <EOL> return item [ property ] ; <EOL> } <EOL> } <EOL> } </s>
<s> import BitArray from '<STR_LIT>' ; <EOL> import StringBuilder from '<STR_LIT>' ; <EOL> import AbstractExpandedDecoder from '<STR_LIT>' ; <EOL> export default class AnyAIDecoder extends AbstractExpandedDecoder { <EOL> private static readonly HEADER_SIZE : number = <NUM_LIT> + <NUM_LIT> + <NUM_LIT> ; <EOL> constructor ( information ) { <EOL> super ( information ) ; <EOL> } <EOL> public parseInformation ( ) { <EOL> let buf = new StringBuilder ( ) ; <EOL> return this . getGeneralDecoder ( ) . decodeAllCodes ( buf , AnyAIDecoder . HEADER_SIZE ) ; <EOL> } <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> ApplicationStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getClosestLink , <EOL> hasActiveModifierKey <EOL> } from '<STR_LIT>' ; <EOL> interface CreateCrossAppClickHandlerOptions { <EOL> container : HTMLElement ; navigateToUrl : ApplicationStart [ '<STR_LIT>' ] ; <EOL> } <EOL> export const createNavigateToUrlClickHandler = ( { <EOL> container , <EOL> navigateToUrl , <EOL> } ) : React . MouseEventHandler < HTMLElement > = > { <EOL> return ( e ) = > { <EOL> if ( container == null ) { <EOL> return ; <EOL> } <EOL> const target = e . target as HTMLElement ; <EOL> const link = getClosestLink ( target , container ) ; <EOL> if ( ! link ) { <EOL> return ; <EOL> } <EOL> if ( link . href & & ( link . target == = '<STR_LIT>' | | link . target == = '<STR_LIT>' ) & & e . button == = <NUM_LIT> & &   ! e . defaultPrevented & &   ! hasActiveModifierKey ( e ) ) { <EOL> e . preventDefault ( ) ; <EOL> navigateToUrl ( link . href ) ; <EOL> } <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsGeoBounds extends BaseAggParams { <EOL> field : string ; <EOL> } <EOL> const geoBoundsTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const geoBoundsLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export const getGeoBoundsMetricAgg = ( ) = > { <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . GEO_BOUNDS , <EOL> title : geoBoundsTitle , <EOL> makeLabel : ( ) = > geoBoundsLabel , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : OSD_FIELD_TYPES . GEO_POINT , <EOL> } , ] , <EOL> } ) ; <EOL> } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import FloatingLabel from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> const FloatingLabelScreenshotTest = ( ) = > { <EOL> return ( < div > < div className = '<STR_LIT>' > < FloatingLabel > My Label Text < / FloatingLabel > < / div > < div className = '<STR_LIT>' > < FloatingLabel float > Floated Label < / FloatingLabel > < / div > < / div > ) ; } ; export default FloatingLabelScreenshotTest ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . PERCENTILES > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , AggArgs , Output > ; <EOL> export const aggPercentiles = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> field : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> percents : { <EOL> types : [ '<STR_LIT>' ] , <EOL> multi : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . PERCENTILES , <EOL> params : { <EOL> ... rest , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> Component , <EOL> forwardRef , <EOL> Injector , <EOL> Input , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AbstractControl , <EOL> ControlValueAccessor , <EOL> FormGroup , <EOL> NG_VALIDATORS , <EOL> NG_VALUE_ACCESSOR , <EOL> NgControl , <EOL> ValidationErrors , <EOL> Validator , <EOL> Validators <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeInputService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UntilDestroy , <EOL> untilDestroyed <EOL> } from '<STR_LIT>' ; <EOL> @ UntilDestroy ( ) @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> providers : [ { <EOL> provide : NG_VALUE_ACCESSOR , <EOL> useExisting : forwardRef ( ( ) = > TimeInputComponent ) , <EOL> multi : true <EOL> } , { <EOL> provide : NG_VALIDATORS , <EOL> useExisting : forwardRef ( ( ) = > TimeInputComponent ) , <EOL> multi : true <EOL> } , TimeInputService ] <EOL> } ) export class TimeInputComponent implements ControlValueAccessor , Validator , OnInit { <EOL> @ Input ( ) label : string ; <EOL> form : FormGroup ; <EOL> unitControl : AbstractControl ; <EOL> timeControl : AbstractControl ; <EOL> units : { <EOL> value : number ; key : string ; <EOL> } [ ] ; <EOL> control : AbstractControl ; <EOL> private changeHandler : ( output : number ) = > void ; <EOL> constructor ( private service , private injector ) { <EOL> this . form = this . service . getFormConfiguration ( ) ; <EOL> this . unitControl = this . form . get ( '<STR_LIT>' ) ; <EOL> this . timeControl = this . form . get ( '<STR_LIT>' ) ; <EOL> this . units = this . service . getUnits ( ) ; <EOL> } <EOL> registerOnChange ( fn ) { <EOL> this . changeHandler = fn ; <EOL> } <EOL> registerOnTouched ( fn ) { } <EOL> writeValue ( obj ) { <EOL> this . service . externalValueUpdate ( this . form , obj ) ; <EOL> } <EOL> validate ( control ) { <EOL> if ( this . control ) this . timeControl . setValidators ( this . control . validator ) ; <EOL> return this . service . getErrors ( control . value ) ; <EOL> } <EOL> updateTimeUnitValidation = ( time ) : void = > { <EOL> if ( time & & time > <NUM_LIT> ) { <EOL> this . unitControl . setValidators ( Validators . required ) ; <EOL> this . unitControl . markAsTouched ( ) ; <EOL> this . unitControl . enable ( ) ; <EOL> } else { <EOL> this . unitControl . markAsUntouched ( ) ; <EOL> this . unitControl . disable ( ) ; <EOL> this . unitControl . clearValidators ( ) ; <EOL> } <EOL> this . unitControl . updateValueAndValidity ( ) ; <EOL> } ; <EOL> ngOnInit ( ) { <EOL> this . control = this . injector . get ( NgControl ) . control ; <EOL> this . timeControl . valueChanges . pipe ( untilDestroyed ( this ) ) . subscribe ( this . updateTimeUnitValidation ) ; <EOL> this . form . valueChanges . pipe ( untilDestroyed ( this ) ) . subscribe ( values = > this . changeHandler & & this . changeHandler ( this . service . getOutputValue ( values ) ) ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> TypeData <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TypePoint <EOL> } from '<STR_LIT>' ; <EOL> type TypeController = TypePoint & { <EOL> invisible   ? : boolean ; <EOL> } ; <EOL> type TypeHeplerSelectedElementWrapper = { <EOL> uuid : string ; controllerSize : number ; controllerOffset : number ; lock : boolean ; controllers : { <EOL> topLeft : TypeController ; top : TypeController ; topRight : TypeController ; right : TypeController ; bottomRight : TypeController ; bottom : TypeController ; bottomLeft : TypeController ; left : TypeController ; rotate : TypeController ; <EOL> } ; lineDash : number [ ] ; lineWidth : number ; color : string ; radian   ? : number ; translate   ? : TypePoint ; <EOL> } ; <EOL> type TypeHeplerSelectedAreaWrapper = { <EOL> x : number ; y : number ; w : number ; h : number ; startPoint : TypePoint ; endPoint : TypePoint ; lineWidth : number ; lineDash : number [ ] ; color : string ; <EOL> } ; <EOL> type TypeHelperConfig = { <EOL> elementIndexMap : { <EOL> [ key ] : number ; <EOL> } ; selectedAreaWrapper   ? : TypeHeplerSelectedAreaWrapper ; selectedElementWrapper   ? : TypeHeplerSelectedElementWrapper ; selectedElementListWrappers   ? : Array < TypeHeplerSelectedElementWrapper > ; <EOL> } ; <EOL> type TypeHelperUpdateOpts = { <EOL> width : number ; height : number ; selectedUUID   ? : string | null ; selectedUUIDList   ? : string [ ] ; devicePixelRatio : number ; scale : number ; canScroll : boolean ; scrollX : number ; scrollY : number ; <EOL> } ; <EOL> interface TypeHelper { <EOL> updateConfig ( data , opts ) : void ; <EOL> getConfig ( ) : TypeHelperConfig ; <EOL> } <EOL> type TypeHelperWrapperControllerDirection = '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' ; <EOL> export { <EOL> TypeHelper , <EOL> TypeHelperConfig , <EOL> TypeHelperUpdateOpts , <EOL> TypeHelperWrapperControllerDirection , <EOL> TypeHeplerSelectedElementWrapper , <EOL> TypeHeplerSelectedAreaWrapper , <EOL> } ; </s>
<s> import { <EOL> DomainEvents <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IHandle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UserEmailChangedEvent <EOL> } from '<STR_LIT>' ; <EOL> export class AfterUserEmailChanged implements IHandle < UserEmailChangedEvent > { <EOL> constructor ( ) { <EOL> this . setupSubscriptions ( ) ; <EOL> } <EOL> setupSubscriptions ( ) { <EOL> DomainEvents . register ( this . onUserEmailChangedEvent . bind ( this ) , UserEmailChangedEvent . name ) ; <EOL> } <EOL> private async onUserEmailChangedEvent ( event ) { <EOL> const { <EOL> user <EOL> } = event ; <EOL> console . log ( user ) ; <EOL> } <EOL> } </s>
<s> import React , { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> StyleSheet , <EOL> Text <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ProductItemProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> types <EOL> } from '<STR_LIT>' ; <EOL> export type ProductItemBrandProps = Pick < ProductItemProps , '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' > ; <EOL> const styles = StyleSheet . create ( { <EOL> brand : { <EOL> marginBottom : <NUM_LIT> <EOL> } <EOL> } ) ; <EOL> export class ProductItemBrand extends Component < ProductItemBrandProps > { <EOL> render ( ) { <EOL> const { <EOL> brand , <EOL> brandStyle , <EOL> renderBrand <EOL> } = this . props ; <EOL> if ( renderBrand ) { <EOL> return renderBrand ( ) ; <EOL> } <EOL> if ( ! brand ) { <EOL> return null ; <EOL> } <EOL> return < Text style = { [ types . caption , styles . brand , brandStyle ] } > { brand . toUpperCase ( ) } < / Text > ; } } </s>
<s> import ibkr , { <EOL> EventName <EOL> } from '<STR_LIT>' ; <EOL> import includes from '<STR_LIT>' ; <EOL> import isEmpty from '<STR_LIT>' ; <EOL> import { <EOL> LIVE_ACCOUNT_IDS <EOL> } from '<STR_LIT>' ; <EOL> import IBKRConnection from '<STR_LIT>' ; <EOL> import { <EOL> IBKREVENTS , <EOL> IbkrEvents , <EOL> publishDataToTopic <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> log <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Portfolios <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getRadomReqId <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IBKRAccountSummary <EOL> } from '<STR_LIT>' ; <EOL> const appEvents = IbkrEvents . Instance ; <EOL> export class AccountSummary { <EOL> ib : ibkr ; accountReady = false ; tickerId = getRadomReqId ( ) ; AccountId ; accountIds = [ ] ; accounts : Record < string , <EOL> IBKRAccountSummary > = { } ; accountSummary : IBKRAccountSummary = { } <EOL> as any ; private static _instance : AccountSummary ; public static get Instance ( ) : AccountSummary { <EOL> return this . _instance | | ( this . _instance = new this ( ) ) ; <EOL> } <EOL> private constructor ( ) { <EOL> this . ib = IBKRConnection . Instance . getIBKR ( ) ; <EOL> } <EOL> public init ( ) { <EOL> const self = this ; <EOL> const ib = IBKRConnection . Instance . getIBKR ( ) ; <EOL> self . ib = ib ; <EOL> ib . on ( EventName . accountSummary , ( reqId , account , tag , value , currency ) = > { <EOL> self . tickerId = reqId ; <EOL> self . AccountId = account ; <EOL> self . accountSummary . AccountId = account ; <EOL> self . accountSummary [ tag ] = value ; <EOL> self . accountSummary . Currency = currency ; <EOL> self . accounts [ account ] = { <EOL> ... self . accounts [ account ] , <EOL> [ tag ] : value , <EOL> AccountId : account , <EOL> Currency : currency , <EOL> } ; <EOL> } ) ; <EOL> ib . once ( EventName . accountSummaryEnd , ( ) = > { <EOL> const { <EOL> AccountId = '<STR_LIT>' , tickerId , accountReady , accountSummary <EOL> } = self ; <EOL> log ( '<STR_LIT>' , { <EOL> AccountId , <EOL> tickerId , <EOL> accountReady <EOL> } ) ; <EOL> ib . cancelAccountSummary ( tickerId ) ; <EOL> publishDataToTopic ( { <EOL> topic : IBKREVENTS . ON_ACCOUNT_SUMMARY , <EOL> data : accountSummary , <EOL> } ) ; <EOL> self . accountReady = true ; <EOL> } ) ; <EOL> self . reqAccountSummary ( ) ; <EOL> } <EOL> / ** <EOL> * reqAccountSummary <EOL> * / <EOL> public reqAccountSummary = ( ) : void = > { <EOL> this . ib . reqAccountSummary ( this . tickerId , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ] . join ( '<STR_LIT>' ) ) ; <EOL> } ; <EOL> / ** <EOL> * initialiseDep <EOL> * / <EOL> public initialiseDep ( ) { <EOL> Portfolios . Instance ; <EOL> } <EOL> / ** <EOL> * isLiveAccount <EOL> * Check whether this is the live account <EOL> * / <EOL> public isLiveAccount ( ) { <EOL> return includes ( LIVE_ACCOUNT_IDS , this . AccountId ) ; <EOL> } <EOL> / ** <EOL> * getAccountSummary <EOL> * / <EOL> public getAccountSummary ( ) { <EOL> const { <EOL> accountSummary , <EOL> reqAccountSummary <EOL> } = this ; <EOL> return new Promise ( ( resolve ) = > { <EOL> if ( ! isEmpty ( accountSummary ) ) { <EOL> return resolve ( accountSummary ) ; <EOL> } <EOL> const handleAccountSummary = ( accountSummaryData ) = > { <EOL> appEvents . off ( IBKREVENTS . ON_ACCOUNT_SUMMARY , handleAccountSummary ) ; <EOL> resolve ( accountSummaryData ) ; <EOL> } ; <EOL> appEvents . on ( IBKREVENTS . ON_ACCOUNT_SUMMARY , handleAccountSummary ) ; <EOL> reqAccountSummary ( ) ; <EOL> } ) ; <EOL> } <EOL> } <EOL> export default AccountSummary ; </s>
<s> import { <EOL> PluginInitializerContext , <EOL> CoreStart , <EOL> CoreSetup <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConfigSchema <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getDashboardConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> injectHeaderStyle <EOL> } from '<STR_LIT>' ; <EOL> export class OpenSearchDashboardsLegacyPlugin { <EOL> constructor ( private readonly initializerContext ) { } <EOL> public setup ( core ) { <EOL> return { } ; <EOL> } <EOL> public start ( { <EOL> application , <EOL> http : { <EOL> basePath <EOL> } , <EOL> uiSettings <EOL> } ) { <EOL> injectHeaderStyle ( uiSettings ) ; <EOL> return { <EOL> deprecated dashboardConfig : getDashboardConfig ( ! application . capabilities . dashboard . showWriteControls ) , <EOL> deprecated loadFontAwesome : async ( ) = > { <EOL> await import ( '<STR_LIT>' ) ; <EOL> } , <EOL> deprecated config : this . initializerContext . config . get ( ) , <EOL> } ; <EOL> } <EOL> } <EOL> export type OpenSearchDashboardsLegacySetup = ReturnType < OpenSearchDashboardsLegacyPlugin [ '<STR_LIT>' ] > ; <EOL> export type OpenSearchDashboardsLegacyStart = ReturnType < OpenSearchDashboardsLegacyPlugin [ '<STR_LIT>' ] > ; </s>
<s> import React , { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import PropTypes from '<STR_LIT>' ; <EOL> import { <EOL> EuiCodeBlock <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Request <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RequestDetailsProps <EOL> } from '<STR_LIT>' ; <EOL> export class RequestDetailsResponse extends Component < RequestDetailsProps > { <EOL> static propTypes = { <EOL> request : PropTypes . object . isRequired , <EOL> } ; static shouldShow = ( request ) = > Boolean ( RequestDetailsResponse . getResponseJson ( request ) ) ; static getResponseJson = ( request ) = > ( request . response   ? request . response . json : null ) ; render ( ) { <EOL> const responseJSON = RequestDetailsResponse . getResponseJson ( this . props . request ) ; <EOL> if ( ! responseJSON ) { <EOL> return null ; <EOL> } <EOL> return ( < EuiCodeBlock language = "<STR_LIT>" paddingSize = "<STR_LIT>" isCopyable data - test - subj = "<STR_LIT>" > { JSON . stringify ( responseJSON , null , <NUM_LIT> ) } < / EuiCodeBlock > ) ; } } </s>
<s> import { <EOL> pressKey , <EOL> simulateTimeline , <EOL> startTimeline <EOL> } from "<STR_LIT>" ; <EOL> import visualSearchCircle from "<STR_LIT>" ; <EOL> jest . useFakeTimers ( ) ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> test ( "<STR_LIT>" , async ( ) = > { <EOL> const { <EOL> displayElement , <EOL> expectFinished , <EOL> getData <EOL> } = await startTimeline ( [ { <EOL> type : visualSearchCircle , <EOL> target : "<STR_LIT>" , <EOL> foil : "<STR_LIT>" , <EOL> fixation_image : "<STR_LIT>" , <EOL> set_size : <NUM_LIT> , <EOL> target_present : true , <EOL> target_present_key : "<STR_LIT>" , <EOL> target_absent_key : "<STR_LIT>" , <EOL> } , ] ) ; <EOL> expect ( displayElement . querySelectorAll ( "<STR_LIT>" ) . length ) . toBe ( <NUM_LIT> ) ; <EOL> jest . advanceTimersByTime ( <NUM_LIT> ) ; <EOL> expect ( displayElement . querySelectorAll ( "<STR_LIT>" ) . length ) . toBe ( <NUM_LIT> ) ; <EOL> pressKey ( "<STR_LIT>" ) ; <EOL> await expectFinished ( ) ; <EOL> expect ( getData ( ) . values ( ) [ <NUM_LIT> ] . correct ) . toBe ( true ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> test ( "<STR_LIT>" , async ( ) = > { <EOL> const { <EOL> expectFinished , <EOL> getData <EOL> } = await simulateTimeline ( [ { <EOL> type : visualSearchCircle , <EOL> target : "<STR_LIT>" , <EOL> foil : "<STR_LIT>" , <EOL> fixation_image : "<STR_LIT>" , <EOL> set_size : <NUM_LIT> , <EOL> target_present : true , <EOL> target_present_key : "<STR_LIT>" , <EOL> target_absent_key : "<STR_LIT>" , <EOL> } , ] ) ; <EOL> await expectFinished ( ) ; <EOL> const data = getData ( ) . values ( ) [ <NUM_LIT> ] ; <EOL> expect ( data . correct ) . toBe ( data . response == "<STR_LIT>" ) ; <EOL> } ) ; <EOL> test ( "<STR_LIT>" , async ( ) = > { <EOL> const { <EOL> expectRunning , <EOL> expectFinished , <EOL> getData <EOL> } = await simulateTimeline ( [ { <EOL> type : visualSearchCircle , <EOL> target : "<STR_LIT>" , <EOL> foil : "<STR_LIT>" , <EOL> fixation_image : "<STR_LIT>" , <EOL> set_size : <NUM_LIT> , <EOL> target_present : true , <EOL> target_present_key : "<STR_LIT>" , <EOL> target_absent_key : "<STR_LIT>" , <EOL> } , ] , "<STR_LIT>" ) ; <EOL> await expectRunning ( ) ; <EOL> jest . runAllTimers ( ) ; <EOL> await expectFinished ( ) ; <EOL> const data = getData ( ) . values ( ) [ <NUM_LIT> ] ; <EOL> expect ( data . correct ) . toBe ( data . response == "<STR_LIT>" ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Assign <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . MIN_BUCKET > ; <EOL> type Arguments = Assign < AggArgs , { <EOL> customBucket   ? : AggExpressionType ; customMetric   ? : AggExpressionType ; <EOL> } > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , Arguments , Output > ; <EOL> export const aggBucketMin = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customBucket : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customMetric : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . MIN_BUCKET , <EOL> params : { <EOL> ... rest , <EOL> customBucket : args . customBucket ? . value , <EOL> customMetric : args . customMetric ? . value , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> Component , <EOL> OnInit , <EOL> ViewEncapsulation <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MatDialogRef <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuthState <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> encapsulation : ViewEncapsulation . None , <EOL> } ) export class AuthModalPageComponent implements OnInit { <EOL> constructor ( private store , private dialogRef ) { } <EOL> ngOnInit ( ) { <EOL> setTimeout ( ( ) = > this . store . dispatch ( AuthState . signOutAuthModal ( ) ) ) ; <EOL> } <EOL> onSuccess ( ) { <EOL> this . dialogRef . close ( true ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> export const settingStore = new Store ( { <EOL> catalogueUpdate : true <EOL> } , undefined , '<STR_LIT>' ) ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> debounce , <EOL> keyBy , <EOL> sortBy , <EOL> uniq <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiTitle , <EOL> EuiInMemoryTable , <EOL> EuiPage , <EOL> EuiPageBody , <EOL> EuiPageContent , <EOL> EuiLink , <EOL> EuiFlexGroup , <EOL> EuiFlexItem , <EOL> EuiButton , <EOL> EuiSpacer , <EOL> EuiOverlayMask , <EOL> EuiConfirmModal , <EOL> EuiCallOut , <EOL> EuiBasicTableColumn , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HttpFetchError , <EOL> ToastsStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> toMountPoint <EOL> } from '<STR_LIT>' ; <EOL> interface Column { <EOL> name : string ; width   ? : string ; actions   ? : object [ ] ; <EOL> } <EOL> interface Item { <EOL> id   ? : string ; <EOL> } <EOL> export interface TableListViewProps { <EOL> createItem   ? ( ) : void ; <EOL> deleteItems   ? ( items ) : Promise < void > ; <EOL> editItem   ? ( item ) : void ; <EOL> entityName : string ; <EOL> entityNamePlural : string ; <EOL> findItems ( query ) : Promise < { <EOL> total : number ; hits : object [ ] ; <EOL> } > ; <EOL> listingLimit : number ; <EOL> initialFilter : string ; <EOL> initialPageSize : number ; <EOL> noItemsFragment : JSX . Element ; <EOL> tableColumns : Column [ ] ; <EOL> tableListTitle : string ; <EOL> toastNotifications : ToastsStart ; <EOL> / ** <EOL> * Id of the heading element describing the table . This id will be used as   ` aria - labelledby ` of the wrapper element . <EOL> * If the table is not empty , this component renders its own h1 element using the same id . <EOL> * / <EOL> headingId   ? : string ; <EOL> } <EOL> export interface TableListViewState { <EOL> items : object [ ] ; hasInitialFetchReturned : boolean ; isFetchingItems : boolean ; isDeletingItems : boolean ; showDeleteModal : boolean ; showLimitError : boolean ; fetchError   ? : HttpFetchError ; filter : string ; selectedIds : string [ ] ; totalItems : number ; <EOL> } <EOL> class TableListView extends React . Component < TableListViewProps , TableListViewState > { <EOL> private pagination = { } ; private _isMounted = false ; constructor ( props ) { <EOL> super ( props ) ; <EOL> this . pagination = { <EOL> initialPageIndex : <NUM_LIT> , <EOL> initialPageSize : props . initialPageSize , <EOL> pageSizeOptions : uniq ( [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , props . initialPageSize ] ) . sort ( ) , <EOL> } ; <EOL> this . state = { <EOL> items : [ ] , <EOL> totalItems : <NUM_LIT> , <EOL> hasInitialFetchReturned : false , <EOL> isFetchingItems : false , <EOL> isDeletingItems : false , <EOL> showDeleteModal : false , <EOL> showLimitError : false , <EOL> filter : props . initialFilter , <EOL> selectedIds : [ ] , <EOL> } ; <EOL> } <EOL> UNSAFE_componentWillMount ( ) { <EOL> this . _isMounted = true ; <EOL> } <EOL> componentWillUnmount ( ) { <EOL> this . _isMounted = false ; <EOL> this . debouncedFetch . cancel ( ) ; <EOL> } <EOL> componentDidMount ( ) { <EOL> this . fetchItems ( ) ; <EOL> } <EOL> debouncedFetch = debounce ( async ( filter ) = > { <EOL> try { <EOL> const response = await this . props . findItems ( filter ) ; <EOL> if ( ! this . _isMounted ) { <EOL> return ; <EOL> } <EOL> if ( filter == = this . state . filter ) { <EOL> this . setState ( { <EOL> hasInitialFetchReturned : true , <EOL> isFetchingItems : false , <EOL> items :   ! filter   ? sortBy ( response . hits , '<STR_LIT>' ) : response . hits , <EOL> totalItems : response . total , <EOL> showLimitError : response . total > this . props . listingLimit , <EOL> } ) ; <EOL> } <EOL> } catch ( fetchError ) { <EOL> this . setState ( { <EOL> hasInitialFetchReturned : true , <EOL> isFetchingItems : false , <EOL> items : [ ] , <EOL> totalItems : <NUM_LIT> , <EOL> showLimitError : false , <EOL> fetchError , <EOL> } ) ; <EOL> } <EOL> } , <NUM_LIT> ) ; fetchItems = ( ) = > { <EOL> this . setState ( { <EOL> isFetchingItems : true , <EOL> fetchError : undefined , <EOL> } , this . debouncedFetch . bind ( null , this . state . filter ) ) ; <EOL> } ; deleteSelectedItems = async ( ) = > { <EOL> if ( this . state . isDeletingItems | |   ! this . props . deleteItems ) { <EOL> return ; <EOL> } <EOL> this . setState ( { <EOL> isDeletingItems : true , <EOL> } ) ; <EOL> try { <EOL> const itemsById = keyBy ( this . state . items , '<STR_LIT>' ) ; <EOL> await this . props . deleteItems ( this . state . selectedIds . map ( ( id ) = > itemsById [ id ] ) ) ; <EOL> } catch ( error ) { <EOL> this . props . toastNotifications . addDanger ( { <EOL> title : toMountPoint ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { entityName : this . props . entityName } } / > ) , <EOL> text :   ` $ { error } ` , <EOL> } ) ; <EOL> } <EOL> this . fetchItems ( ) ; <EOL> this . setState ( { <EOL> isDeletingItems : false , <EOL> selectedIds : [ ] , <EOL> } ) ; <EOL> this . closeDeleteModal ( ) ; <EOL> } ; closeDeleteModal = ( ) = > { <EOL> this . setState ( { <EOL> showDeleteModal : false <EOL> } ) ; <EOL> } ; openDeleteModal = ( ) = > { <EOL> this . setState ( { <EOL> showDeleteModal : true <EOL> } ) ; <EOL> } ; setFilter ( { <EOL> queryText <EOL> } ) { <EOL> this . setState ( { <EOL> filter : queryText , <EOL> } , this . fetchItems ) ; <EOL> } <EOL> hasNoItems ( ) { <EOL> if ( ! this . state . isFetchingItems & & this . state . items . length == = <NUM_LIT> & &   ! this . state . filter ) { <EOL> return true ; <EOL> } <EOL> return false ; <EOL> } <EOL> renderConfirmDeleteModal ( ) { <EOL> let deleteButton = ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) ; <EOL> if ( this . state . isDeletingItems ) { <EOL> deleteButton = ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) ; <EOL> } <EOL> return ( < EuiOverlayMask > < EuiConfirmModal title = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { itemCount : this . state . selectedIds . length , entityName : this . state . selectedIds . length == = <NUM_LIT>   ? this . props . entityName : this . props . entityNamePlural , } } / > } buttonColor = "<STR_LIT>" onCancel = { this . closeDeleteModal } onConfirm = { this . deleteSelectedItems } cancelButtonText = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > } confirmButtonText = { deleteButton } defaultFocusedButton = "<STR_LIT>" > < p > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { entityNamePlural : this . props . entityNamePlural } } / > < / p > < / EuiConfirmModal > < / EuiOverlayMask > ) ; } renderListingLimitWarning ( ) { if ( this . state . showLimitError ) { return ( < React . Fragment > < EuiCallOut title = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > } color = "<STR_LIT>" iconType = "<STR_LIT>" > < p > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { entityNamePlural : this . props . entityNamePlural , totalItems : this . state . totalItems , listingLimitValue : this . props . listingLimit , listingLimitText : < strong > listingLimit < / strong > , advancedSettingsLink : ( < EuiLink href = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiLink > ) , } } / > < / p > < / EuiCallOut > < EuiSpacer size = "<STR_LIT>" / > < / React . Fragment > ) ; } } renderFetchError ( ) { if ( this . state . fetchError ) { return ( < React . Fragment > < EuiCallOut title = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > } color = "<STR_LIT>" iconType = "<STR_LIT>" > < p > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { entityName : this . props . entityName , message : this . state . fetchError . body   ? . message | | this . state . fetchError . message , } } / > < / p > < / EuiCallOut > < EuiSpacer size = "<STR_LIT>" / > < / React . Fragment > ) ; } } renderNoItemsMessage ( ) { if ( this . props . noItemsFragment ) { return this . props . noItemsFragment ; } else { return ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { entityNamePlural : this . props . entityNamePlural } } / > ) ; } } renderToolsLeft ( ) { const selection = this . state . selectedIds ; if ( selection . length == = <NUM_LIT> ) { return ; } const onClick = ( ) = > { this . openDeleteModal ( ) ; } ; return ( < EuiButton color = "<STR_LIT>" iconType = "<STR_LIT>" onClick = { onClick } data - test - subj = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { itemCount : selection . length , entityName : selection . length == = <NUM_LIT>   ? this . props . entityName : this . props . entityNamePlural , } } / > < / EuiButton > ) ; } renderTable ( ) { const selection = this . props . deleteItems   ? { onSelectionChange : ( obj ) = > { this . setState ( { selectedIds : obj . map ( ( item ) = > item . id ) . filter ( ( id ) : id is string = > Boolean ( id ) ) , } ) ; } , } : undefined ; const actions = [ { name : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , description : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , icon : '<STR_LIT>' , type : '<STR_LIT>' , enabled : ( { error } ) = >   ! error , onClick : this . props . editItem , } , ] ; const search = { onChange : this . setFilter . bind ( this ) , toolsLeft : this . renderToolsLeft ( ) , defaultQuery : this . state . filter , box : { incremental : true , } , } ; const columns = this . props . tableColumns . slice ( ) ; if ( this . props . editItem ) { columns . push ( { name : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , width : '<STR_LIT>' , actions , } ) ; } const noItemsMessage = ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { entityNamePlural : this . props . entityNamePlural } } / > ) ; return ( < EuiInMemoryTable itemId = "<STR_LIT>" items = { this . state . items } columns = { ( columns as unknown ) as Array < EuiBasicTableColumn < object > > } pagination = { this . pagination } loading = { this . state . isFetchingItems } message = { noItemsMessage } selection = { selection } search = { search } sorting = { true } data - test - subj = "<STR_LIT>" / > ) ; } renderListingOrEmptyState ( ) { if (   ! this . state . fetchError & & this . hasNoItems ( ) ) { return this . renderNoItemsMessage ( ) ; } return this . renderListing ( ) ; } renderListing ( ) { let createButton ; if ( this . props . createItem ) { createButton = ( < EuiFlexItem grow = { false } > < EuiButton onClick = { this . props . createItem } data - test - subj = "<STR_LIT>" iconType = "<STR_LIT>" fill > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { entityName : this . props . entityName } } / > < / EuiButton > < / EuiFlexItem > ) ; } return ( < div > { this . state . showDeleteModal & & this . renderConfirmDeleteModal ( ) } < EuiFlexGroup justifyContent = "<STR_LIT>" alignItems = "<STR_LIT>" data - test - subj = "<STR_LIT>" > < EuiFlexItem grow = { false } > < EuiTitle size = "<STR_LIT>" > < h1 id = { this . props . headingId } > { this . props . tableListTitle } < / h1 > < / EuiTitle > < / EuiFlexItem > { createButton } < / EuiFlexGroup > < EuiSpacer size = "<STR_LIT>" / > { this . renderListingLimitWarning ( ) } { this . renderFetchError ( ) } { this . renderTable ( ) } < / div > ) ; } renderPageContent ( ) { if (   ! this . state . hasInitialFetchReturned ) { return ; } return ( < EuiPageContent horizontalPosition = "<STR_LIT>" > { this . renderListingOrEmptyState ( ) } < / EuiPageContent > ) ; } render ( ) { return ( < EuiPage data - test - subj = { this . props . entityName + '<STR_LIT>' } className = "<STR_LIT>" restrictWidth > < EuiPageBody aria - labelledby = { this . state . hasInitialFetchReturned   ? this . props . headingId : undefined } > { this . renderPageContent ( ) } < / EuiPageBody > < / EuiPage > ) ; } } export { TableListView } ; export default TableListView ; </s>
<s> import { <EOL> AfterContentInit , <EOL> ChangeDetectionStrategy , <EOL> Component , <EOL> OnInit , <EOL> ViewChild <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PieChartComponent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> schemeCategory10 as colorScheme <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GroupingStrategy , <EOL> groupTransactions , <EOL> Transaction <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Observable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AppState <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> changeDetection : ChangeDetectionStrategy . OnPush , <EOL> host : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } ) export class SpendingPaneComponent implements OnInit , AfterContentInit { <EOL> @ ViewChild ( PieChartComponent , { <EOL> static : true <EOL> } )   $ chart ! : PieChartComponent ; <EOL> legendTitle = '<STR_LIT>' ; <EOL> data ! : Observable < TooltipData [ ] > ; <EOL> colorScheme = { <EOL> domain : colorScheme <EOL> } ; <EOL> constructor ( private store $ ) { } <EOL> ngOnInit ( ) { <EOL> this . data = this . store $ . select ( '<STR_LIT>' ) . pipe ( map ( txs = > { <EOL> return groupTransactions ( txs . map ( ( tx ) = > new Transaction ( tx ) ) , GroupingStrategy . Category ) . map ( cat = > { <EOL> return { <EOL> name : cat . id , <EOL> value : cat . txs . reduce ( ( sum , tx ) = > sum + ( tx . amount . negative   ? tx . amount . amount : <NUM_LIT> ) , <NUM_LIT> ) <EOL> } ; <EOL> } ) ; <EOL> } ) ) ; <EOL> } <EOL> ngAfterContentInit ( ) { <EOL> setTimeout ( ( ) = > { <EOL> this . $ chart . update ( ) ; <EOL> } , <NUM_LIT> ) ; <EOL> } <EOL> ttt ( params ) { <EOL> return   ` £ $ { params . data . value . toFixed ( <NUM_LIT> ) } ` ; <EOL> } <EOL> } <EOL> interface TooltipData { <EOL> name : string ; value : number ; <EOL> } <EOL> interface TooltipTextParams { <EOL> data : TooltipData ; endAngle : number ; index : number ; padAngle : number ; pos : number [ ] ; startAngle : number ; value : number ; <EOL> } </s>
<s> import { <EOL> AbstractControl <EOL> } from '<STR_LIT>' ; <EOL> export const isGreaterThanDate = ( lowerName ) = > { <EOL> return ( control ) = > { <EOL> return   ! ! control . parent & &   ! ! control . parent . value & & control . parent . controls [ lowerName ] . value . getTime ( ) < control . value . getTime ( )   ? null : { <EOL> isGreaterThanLowerBound : false <EOL> } ; <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> get , <EOL> post , <EOL> put , <EOL> patch , <EOL> httpDelete <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> format <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Board , <EOL> TaskGroup , <EOL> Task <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * NOTICE <EOL> * <EOL> * Some of the work here would realistically be done server side <EOL> * but we don ' t have a real server , we have a tool called json - server <EOL> * which allows us to play with a JSON file as if it were a restful API <EOL> * / <EOL> / ** <EOL> * Boards <EOL> * / <EOL> export function createBoard ( name   ? ) { <EOL> const defaultBoardData = { <EOL> name : name | | '<STR_LIT>' , <EOL> } ; <EOL> return post < Board > ( ` / boards ` , defaultBoardData ) ; <EOL> } <EOL> export function getBoards ( ) { <EOL> return get < Board [ ] > ( ` / boards ` ) ; <EOL> } <EOL> export function getBoard ( boardId ) { <EOL> return get < Board & { <EOL> taskGroups : TaskGroup [ ] ; tasks : Task [ ] ; <EOL> } > ( ` / boards / $ { boardId } ? _embed = taskGroups & _embed = tasks ` ) ; <EOL> } <EOL> export async function updateBoard ( boardId , data ) { <EOL> return patch < any > ( ` / boards / $ { boardId } ` , data ) ; <EOL> } <EOL> export function removeBoard ( boardId ) { <EOL> return httpDelete < any > ( ` / boards / $ { boardId } ` ) ; <EOL> } <EOL> / ** <EOL> * Task Groups <EOL> * / <EOL> export function createTaskGroup ( boardId , name   ? ) { <EOL> const defaultTaskGroupData = { <EOL> name : name | | '<STR_LIT>' , <EOL> boardId , <EOL> taskIds : [ ] as number [ ] , <EOL> } ; <EOL> return post < TaskGroup > ( ` / taskGroups ` , defaultTaskGroupData ) ; <EOL> } <EOL> export function getTaskGroups ( boardId ) { <EOL> return get < TaskGroup [ ] > ( ` / taskGroups ? boardId = $ { boardId } ` ) ; <EOL> } <EOL> export function updateTaskGroup ( taskGroupId , data ) { <EOL> return patch < any > ( ` / taskGroups / $ { taskGroupId } ` , data ) ; <EOL> } <EOL> export function updateTaskGroups ( taskGroups ) { <EOL> const p = [ ] ; <EOL> taskGroups . forEach ( ( group ) = > { <EOL> p . push ( put < any > ( ` / taskGroups / $ { group . id } ` , group ) ) ; <EOL> } ) ; <EOL> return Promise . all ( p ) ; <EOL> } <EOL> export async function removeTaskGroup ( taskGroupId ) { <EOL> const taskGroup = await get ( ` / taskGroups / $ { taskGroupId } ` ) ; <EOL> await httpDelete < any > ( ` / taskGroups / $ { taskGroupId } ` ) ; <EOL> const p = [ ] ; <EOL> taskGroup . taskIds . forEach ( ( taskId ) = > { <EOL> p . push ( httpDelete < any > ( ` / tasks / $ { taskId } ` ) ) ; <EOL> } ) ; <EOL> await Promise . all ( p ) ; <EOL> } <EOL> / ** <EOL> * Tasks <EOL> * / <EOL> export function getTasks ( boardId ) { <EOL> return get < Task [ ] > ( ` / tasks ? boardId = $ { boardId } ` ) ; <EOL> } <EOL> export function getTask ( taskId ) { <EOL> return get < Task > ( ` / tasks / $ { taskId } ` ) ; <EOL> } <EOL> export async function createTask ( boardId , taskGroupId , data   ? ) { <EOL> const defaultTaskData = { <EOL> name : '<STR_LIT>' , <EOL> content : '<STR_LIT>' , <EOL> minutes : <NUM_LIT> , <EOL> completedMinutes : <NUM_LIT> , <EOL> assignedTo : [ ] , <EOL> ... data , <EOL> boardId , <EOL> date : format ( Date . now ( ) , '<STR_LIT>' ) , <EOL> } ; <EOL> const task = await post < Task > ( ` / tasks ` , defaultTaskData ) ; <EOL> const taskGroup = await get < TaskGroup > ( ` / taskGroups / $ { taskGroupId } ` ) ; <EOL> const newTaskIds = taskGroup . taskIds . concat ( task . id ) ; <EOL> await patch < any > ( ` / taskGroups / $ { taskGroupId } ` , { <EOL> taskIds : newTaskIds <EOL> } ) ; <EOL> return task ; <EOL> } <EOL> export function updateTask ( taskId , task ) { <EOL> return put ( ` / tasks / $ { taskId } ` , task ) ; <EOL> } <EOL> export async function removeTask ( boardId , taskId ) { <EOL> await httpDelete ( ` / tasks / $ { taskId } ` ) ; <EOL> const taskGroups = await get ( ` / taskGroups / ? boardId = $ { boardId } ` ) ; <EOL> const newTaskGroups = taskGroups . map ( ( taskGroup ) = > { <EOL> return { <EOL> ... taskGroup , <EOL> taskIds : taskGroup . taskIds . filter ( ( id ) = > id != = taskId ) <EOL> } ; <EOL> } ) ; <EOL> await updateTaskGroups ( newTaskGroups ) ; <EOL> return null ; <EOL> } </s>
<s> import { <EOL> BaseDecorationOptions , <EOL> Decoration <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> LuaType , <EOL> PointerSize <EOL> } from '<STR_LIT>' ; <EOL> import Global from '<STR_LIT>' ; <EOL> import Thread from '<STR_LIT>' ; <EOL> export default abstract class LuaTypeExtension < T , K extends BaseDecorationOptions = BaseDecorationOptions > { <EOL> public readonly name : string ; protected thread : Global ; public constructor ( thread , name ) { <EOL> this . thread = thread ; <EOL> this . name = name ; <EOL> } <EOL> public isType ( _thread , _index , type , name   ? ) { <EOL> return type == = LuaType . Userdata & & name == = this . name ; <EOL> } <EOL> public abstract close ( ) ; public getValue ( thread , index , _userdata   ? ) { <EOL> const refUserdata = thread . lua . luaL_testudata ( thread . address , index , this . name ) ; <EOL> if ( ! refUserdata ) { <EOL> throw new Error ( ` data does not have the expected metatable :   $ { this . name } ` ) ; <EOL> } <EOL> const referencePointer = thread . lua . module . getValue ( refUserdata , '<STR_LIT>' ) ; <EOL> return thread . lua . getRef ( referencePointer ) ; <EOL> } <EOL> public pushValue ( thread , decoratedValue , _userdata   ? ) { <EOL> const { <EOL> target <EOL> } = decoratedValue ; <EOL> const pointer = thread . lua . ref ( target ) ; <EOL> const userDataPointer = thread . lua . lua_newuserdatauv ( thread . address , PointerSize , <NUM_LIT> ) ; <EOL> thread . lua . module . setValue ( userDataPointer , pointer , '<STR_LIT>' ) ; <EOL> if ( LuaType . Nil == = thread . lua . luaL_getmetatable ( thread . address , this . name ) ) { <EOL> thread . pop ( <NUM_LIT> ) ; <EOL> throw new Error ( ` metatable not found :   $ { this . name } ` ) ; <EOL> } <EOL> thread . lua . lua_setmetatable ( thread . address , - <NUM_LIT> ) ; <EOL> return true ; <EOL> } <EOL> } </s>
<s> import IQuillCursorsOptions from '<STR_LIT>' ; <EOL> import Cursor from '<STR_LIT>' ; <EOL> import IQuillRange from '<STR_LIT>' ; <EOL> import * as RangeFix from '<STR_LIT>' ; <EOL> import template from '<STR_LIT>' ; <EOL> import ResizeObserver from '<STR_LIT>' ; <EOL> import Delta = require ( '<STR_LIT>' ) ; <EOL> export default class QuillCursors { <EOL> public static DEFAULTS : IQuillCursorsOptions = { <EOL> template , <EOL> containerClass : '<STR_LIT>' , <EOL> selectionChangeSource : '<STR_LIT>' , <EOL> hideDelayMs : <NUM_LIT> , <EOL> hideSpeedMs : <NUM_LIT> , <EOL> } ; <EOL> public readonly quill : any ; <EOL> public readonly options : IQuillCursorsOptions ; <EOL> private readonly _cursors : { <EOL> [ id ] : Cursor ; <EOL> } = { } ; <EOL> private readonly _container : HTMLElement ; <EOL> private readonly _boundsContainer : HTMLElement ; <EOL> private _currentSelection : IQuillRange ; <EOL> private _isObserving = false ; <EOL> public constructor ( quill , options = { } ) { <EOL> this . quill = quill ; <EOL> this . options = this . _setDefaults ( options ) ; <EOL> this . _container = this . quill . addContainer ( this . options . containerClass ) ; <EOL> this . _boundsContainer = this . options . boundsContainer | | this . quill . container ; <EOL> this . _currentSelection = this . quill . getSelection ( ) ; <EOL> this . _registerSelectionChangeListeners ( ) ; <EOL> this . _registerTextChangeListener ( ) ; <EOL> this . _registerDomListeners ( ) ; <EOL> } <EOL> public createCursor ( id , name , color ) { <EOL> let cursor = this . _cursors [ id ] ; <EOL> if ( ! cursor ) { <EOL> cursor = new Cursor ( id , name , color ) ; <EOL> this . _cursors [ id ] = cursor ; <EOL> const element = cursor . build ( this . options ) ; <EOL> this . _container . appendChild ( element ) ; <EOL> } <EOL> return cursor ; <EOL> } <EOL> public moveCursor ( id , range ) { <EOL> const cursor = this . _cursors [ id ] ; <EOL> if ( ! cursor ) { <EOL> return ; <EOL> } <EOL> cursor . range = range ; <EOL> this . _updateCursor ( cursor ) ; <EOL> } <EOL> public removeCursor ( id ) { <EOL> const cursor = this . _cursors [ id ] ; <EOL> if ( ! cursor ) { <EOL> return ; <EOL> } <EOL> cursor . remove ( ) ; <EOL> delete this . _cursors [ id ] ; <EOL> } <EOL> public update ( ) { <EOL> this . cursors ( ) . forEach ( ( cursor ) = > this . _updateCursor ( cursor ) ) ; <EOL> } <EOL> public clearCursors ( ) { <EOL> this . cursors ( ) . forEach ( ( cursor ) = > this . removeCursor ( cursor . id ) ) ; <EOL> } <EOL> public toggleFlag ( id , shouldShow   ? ) { <EOL> const cursor = this . _cursors [ id ] ; <EOL> if ( ! cursor ) { <EOL> return ; <EOL> } <EOL> cursor . toggleFlag ( shouldShow ) ; <EOL> } <EOL> public cursors ( ) { <EOL> return Object . keys ( this . _cursors ) . map ( ( key ) = > this . _cursors [ key ] ) ; <EOL> } <EOL> private _registerSelectionChangeListeners ( ) { <EOL> this . quill . on ( this . quill . constructor . events . SELECTION_CHANGE , ( selection ) = > { <EOL> this . _currentSelection = selection ; <EOL> } ) ; <EOL> } <EOL> private _registerTextChangeListener ( ) { <EOL> this . quill . on ( this . quill . constructor . events . TEXT_CHANGE , ( delta ) = > this . _handleTextChange ( delta ) ) ; <EOL> } <EOL> private _registerDomListeners ( ) { <EOL> const editor = this . quill . container . getElementsByClassName ( '<STR_LIT>' ) [ <NUM_LIT> ] ; <EOL> editor . addEventListener ( '<STR_LIT>' , ( ) = > this . update ( ) ) ; <EOL> } <EOL> private _registerResizeObserver ( ) { <EOL> if ( this . _isObserving ) return ; <EOL> const editor = this . quill . container . getElementsByClassName ( '<STR_LIT>' ) [ <NUM_LIT> ] ; <EOL> const resizeObserver = new ResizeObserver ( ( [ entry ] ) = > { <EOL> if ( ! entry . target . isConnected ) { <EOL> resizeObserver . disconnect ( ) ; <EOL> this . _isObserving = false ; <EOL> } <EOL> this . update ( ) ; <EOL> } ) ; <EOL> resizeObserver . observe ( editor ) ; <EOL> this . _isObserving = true ; <EOL> } <EOL> private _updateCursor ( cursor ) { <EOL> this . _registerResizeObserver ( ) ; <EOL> if ( ! cursor . range ) { <EOL> return cursor . hide ( ) ; <EOL> } <EOL> const startIndex = this . _indexWithinQuillBounds ( cursor . range . index ) ; <EOL> const endIndex = this . _indexWithinQuillBounds ( cursor . range . index + cursor . range . length ) ; <EOL> const startLeaf = this . quill . getLeaf ( startIndex ) ; <EOL> const endLeaf = this . quill . getLeaf ( endIndex ) ; <EOL> if ( ! this . _leafIsValid ( startLeaf ) | |   ! this . _leafIsValid ( endLeaf ) ) { <EOL> return cursor . hide ( ) ; <EOL> } <EOL> cursor . show ( ) ; <EOL> const containerRectangle = this . _boundsContainer . getBoundingClientRect ( ) ; <EOL> const endBounds = this . quill . getBounds ( endIndex ) ; <EOL> cursor . updateCaret ( endBounds , containerRectangle ) ; <EOL> const ranges = this . _lineRanges ( cursor , startLeaf , endLeaf ) ; <EOL> const selectionRectangles = ranges . reduce ( ( rectangles , range ) = > rectangles . concat ( Array . from ( RangeFix . getClientRects ( range ) ) ) , [ ] ) ; <EOL> cursor . updateSelection ( selectionRectangles , containerRectangle ) ; <EOL> } <EOL> private _indexWithinQuillBounds ( index ) { <EOL> const quillLength = this . quill . getLength ( ) ; <EOL> const maxQuillIndex = quillLength   ? quillLength - <NUM_LIT> : <NUM_LIT> ; <EOL> index = Math . max ( index , <NUM_LIT> ) ; <EOL> index = Math . min ( index , maxQuillIndex ) ; <EOL> return index ; <EOL> } <EOL> private _leafIsValid ( leaf ) { <EOL> return leaf & & leaf [ <NUM_LIT> ] & & leaf [ <NUM_LIT> ] . domNode & & leaf [ <NUM_LIT> ] >= <NUM_LIT> ; <EOL> } <EOL> private _handleTextChange ( delta ) { <EOL> window . setTimeout ( ( ) = > { <EOL> if ( this . options . transformOnTextChange ) { <EOL> this . _transformCursors ( delta ) ; <EOL> } <EOL> if ( this . options . selectionChangeSource ) { <EOL> this . _emitSelection ( ) ; <EOL> this . update ( ) ; <EOL> } <EOL> } ) ; <EOL> } <EOL> private _emitSelection ( ) { <EOL> this . quill . emitter . emit ( this . quill . constructor . events . SELECTION_CHANGE , this . quill . getSelection ( ) , this . _currentSelection , this . options . selectionChangeSource ) ; <EOL> } <EOL> private _setDefaults ( options ) { <EOL> options = Object . assign ( { } , options ) ; <EOL> options . template | |= QuillCursors . DEFAULTS . template ; <EOL> options . containerClass | |= QuillCursors . DEFAULTS . containerClass ; <EOL> if ( options . selectionChangeSource != = null ) { <EOL> options . selectionChangeSource | |= QuillCursors . DEFAULTS . selectionChangeSource ; <EOL> } <EOL> options . hideDelayMs = Number . isInteger ( options . hideDelayMs )   ? options . hideDelayMs : QuillCursors . DEFAULTS . hideDelayMs ; <EOL> options . hideSpeedMs = Number . isInteger ( options . hideSpeedMs )   ? options . hideSpeedMs : QuillCursors . DEFAULTS . hideSpeedMs ; <EOL> options . transformOnTextChange =   ! ! options . transformOnTextChange ; <EOL> return options ; <EOL> } <EOL> private _lineRanges ( cursor , startLeaf , endLeaf ) { <EOL> const lines = this . quill . getLines ( cursor . range ) ; <EOL> return lines . reduce ( ( ranges , line , index ) = > { <EOL> if ( ! line . children ) { <EOL> const singleElementRange = document . createRange ( ) ; <EOL> singleElementRange . selectNode ( line . domNode ) ; <EOL> return ranges . concat ( singleElementRange ) ; <EOL> } <EOL> const [ rangeStart , startOffset ] = index == = <NUM_LIT>   ? startLeaf : line . path ( <NUM_LIT> ) . pop ( ) ; <EOL> const [ rangeEnd , endOffset ] = index == = lines . length - <NUM_LIT>   ? endLeaf : line . path ( line . length ( ) - <NUM_LIT> ) . pop ( ) ; <EOL> const range = document . createRange ( ) ; <EOL> if ( rangeStart . domNode . nodeType == = Node . TEXT_NODE ) { <EOL> range . setStart ( rangeStart . domNode , startOffset ) ; <EOL> } else { <EOL> range . setStartBefore ( rangeStart . domNode ) ; <EOL> } <EOL> if ( rangeEnd . domNode . nodeType == = Node . TEXT_NODE ) { <EOL> range . setEnd ( rangeEnd . domNode , endOffset ) ; <EOL> } else { <EOL> range . setEndAfter ( rangeEnd . domNode ) ; <EOL> } <EOL> return ranges . concat ( range ) ; <EOL> } , [ ] ) ; <EOL> } <EOL> private _transformCursors ( delta ) { <EOL> delta = new Delta ( delta ) ; <EOL> this . cursors ( ) . filter ( ( cursor ) = > cursor . range ) . forEach ( ( cursor ) = > { <EOL> cursor . range . index = delta . transformPosition ( cursor . range . index ) ; <EOL> this . _updateCursor ( cursor ) ; <EOL> } ) ; <EOL> } <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> NumberParam , <EOL> useQueryParam <EOL> } from '<STR_LIT>' ; <EOL> export default function Issue46 ( ) { <EOL> const [ a = <NUM_LIT> , setA ] = useQueryParam ( '<STR_LIT>' , NumberParam ) ; <EOL> const [ b , setB ] = React . useState ( <NUM_LIT> ) ; <EOL> React . useEffect ( ( ) = > { <EOL> console . log ( '<STR_LIT>' ) ; <EOL> if ( b % <NUM_LIT> == = <NUM_LIT> ) { <EOL> setA ( b ) ; <EOL> } <EOL> } , [ b , setA ] ) ; <EOL> return ( < div > < h4 > a : { a } < / h4 > < h4 > b : { b } < / h4 > < button type = "<STR_LIT>" onClick = { ( ) = > setB ( b + <NUM_LIT> ) } > up < / button > < / div > ) ; } </s>
<s> import { <EOL> ExpressionStatement , <EOL> BinaryExpression , <EOL> JSXElement , <EOL> FunctionExpression , <EOL> JSXIdentifier , <EOL> isIdentifier , <EOL> classMethod , <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> NodePath <EOL> } from "<STR_LIT>" ; <EOL> / ** <EOL> * <EOL> * As we want to rearrange code in literate programming , we will seperate class method from class body . <EOL> * / <EOL> export class MethodCode { <EOL> m_Path : NodePath < ExpressionStatement > ; constructor ( path ) { <EOL> this . m_Path = path ; <EOL> } <EOL> get m_Code ( ) { <EOL> return this . m_Path . node ; <EOL> } <EOL> get m_Left ( ) { <EOL> return this . m_Expression . left as JSXElement ; <EOL> } <EOL> get m_Right ( ) { <EOL> return this . m_Expression . right as FunctionExpression ; <EOL> } <EOL> get m_Expression ( ) { <EOL> return this . m_Code . expression as BinaryExpression ; <EOL> } <EOL> get m_ClassName ( ) { <EOL> return ( this . m_Left . openingElement . name as JSXIdentifier ) . name ; <EOL> } <EOL> / ** <EOL> * The syntax will be : <EOL> * <EOL>               ` ` ` ts <EOL> export class Foo { <EOL> } <EOL> < Foo / > + function Test ( this : Foo , a : number , b : string ) { <EOL> return a . toString ( ) + b ; <EOL> } <EOL>               ` ` ` <EOL> * <EOL> * After transcription , we will restore   ` Foo ` class to : <EOL> * <EOL>               ` ` ` ts <EOL> export class Foo { <EOL> static foo : number ; <EOL> Test ( a : number , b : string ) { <EOL> return a . toString ( ) + b ; <EOL> } <EOL> } <EOL>               ` ` ` <EOL> * <EOL> * <EOL> * / <EOL> ToClassMethod ( ) { <EOL> const { <EOL> id , <EOL> params : raw_params , <EOL> body , <EOL> typeParameters <EOL> } = this . m_Right ; <EOL> / ** <EOL> * remove param "<STR_LIT>" : <EOL> * / <EOL> const params = raw_params . filter ( param = > { <EOL> if ( isIdentifier ( param ) & & param . name == = "<STR_LIT>" ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } ) ; <EOL> const kind = id . name == = "<STR_LIT>"   ? id . name : "<STR_LIT>" ; <EOL> const class_method = classMethod ( kind , id , params , body ) ; <EOL> class_method . typeParameters = typeParameters ; <EOL> return class_method ; <EOL> } <EOL> } </s>
<s> import pathToRegexp from '<STR_LIT>' ; <EOL> import * as _ from '<STR_LIT>' ; <EOL> import { <EOL> Route , <EOL> IntactRoute , <EOL> Matcher , <EOL> Params , <EOL> ControllerConstructor , <EOL> LoadController <EOL> } from '<STR_LIT>' ; <EOL> export interface CreateMatcher { <EOL> ( routes ) : Matcher ; <EOL> } <EOL> export interface CreateRoute { <EOL> ( route ) : IntactRoute ; <EOL> } <EOL> export interface GetParams { <EOL> ( strMatches , keys ) : Params ; <EOL> } <EOL> export interface CleanPath { <EOL> ( path ) : string ; <EOL> } <EOL> const createMatcher = ( routes ) = > { <EOL> const finalRoutes = routes . map ( createRoute ) ; <EOL> const routeLength = finalRoutes . length ; <EOL> const matcher = ( pathname ) = > { <EOL> let finalPathname = cleanPath ( pathname ) ; <EOL> for ( let i = <NUM_LIT> ; i < routeLength ; i + + ) { <EOL> let route = finalRoutes [ i ] ; <EOL> let strMatches = route . regexp . exec ( finalPathname ) ; <EOL> if ( ! strMatches ) { <EOL> continue ; <EOL> } <EOL> let params = getParams ( strMatches , route . keys ) ; <EOL> let controller = route . controller ; <EOL> return { <EOL> path : route . path , <EOL> params , <EOL> controller <EOL> } ; <EOL> } <EOL> return null ; <EOL> } ; <EOL> return matcher ; <EOL> } ; <EOL> export default createMatcher ; <EOL> const createRoute = ( route ) = > { <EOL> let finalRoute = Object . assign ( { } , route ) ; <EOL> finalRoute . keys = [ ] ; <EOL> let keys = finalRoute . keys ; <EOL> let regexp = pathToRegexp ( finalRoute . path , keys ) ; <EOL> let intactRoute = Object . assign ( { <EOL> keys , <EOL> regexp <EOL> } , finalRoute ) ; <EOL> return intactRoute ; <EOL> } ; <EOL> const getParams = ( matches , keys ) = > { <EOL> let params = { } ; <EOL> for ( let i = <NUM_LIT> , len = matches . length ; i < len ; i + + ) { <EOL> let key = keys [ i - <NUM_LIT> ] ; <EOL> if ( key ) { <EOL> if ( typeof matches [ i ] == = '<STR_LIT>' ) { <EOL> params [ key . name ] = decodeURIComponent ( matches [ i ] ) ; <EOL> } else { <EOL> params [ key . name ] = matches [ i ] ; <EOL> } <EOL> } <EOL> } <EOL> return params ; <EOL> } ; <EOL> const cleanPath = ( path ) = > { <EOL> return path . replace ( / \ / \ // g , '<STR_LIT>' ) ; <EOL> } ; </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer , <EOL> getUnitAndNum <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> import { <EOL> UNIT_ENUM_STR , <EOL> NONNEGATIVE_NUMBER_REGEX_STR <EOL> } from '<STR_LIT>' ; <EOL> export const width = ( ) = > [ <EOL> [ new RegExp ( ` ^ ( w | width ) - ( ? < num > $ { NONNEGATIVE_NUMBER_REGEX_STR } ) ( ? < unit > $ { UNIT_ENUM_STR } ) ? $ ` ) , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> num , <EOL> unit <EOL> } = groups as { <EOL> num : string ; unit   ? : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` width :   $ { getUnitAndNum ( unit , num ) } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import { <EOL> ChangeDetectionStrategy , <EOL> Component , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Observable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuthPublicFacade <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> User <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class RepositoriesComponent implements OnInit { <EOL> user : Observable < User > ; constructor ( private authPublicFacade ) { } <EOL> ngOnInit ( ) { <EOL> this . user = this . authPublicFacade . user $ ; <EOL> } <EOL> onLogout ( ) { <EOL> this . authPublicFacade . logout ( ) ; <EOL> } <EOL> } </s>
<s> import React , { <EOL> CSSProperties , <EOL> ReactNode , <EOL> useEffect , <EOL> useRef , <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> usePanelContext <EOL> } from '<STR_LIT>' ; <EOL> export interface Props { <EOL> children : ReactNode [ ] | ReactNode ; className   ? : string ; <EOL> / ** <EOL> * initial width of the panel in percents <EOL> * / <EOL> initialWidth   ? : number ; style   ? : CSSProperties ; <EOL> } <EOL> export function Panel ( { <EOL> children , <EOL> className , <EOL> initialWidth = <NUM_LIT> , <EOL> style = { } <EOL> } ) { <EOL> const [ width , setWidth ] = useState ( ` $ { initialWidth } % ` ) ; <EOL> const { <EOL> registry <EOL> } = usePanelContext ( ) ; <EOL> const divRef = useRef < HTMLDivElement > ( null ) ; <EOL> useEffect ( ( ) = > { <EOL> registry . registerPanel ( { <EOL> width : initialWidth , <EOL> setWidth ( value ) { <EOL> setWidth ( value + '<STR_LIT>' ) ; <EOL> this . width = value ; <EOL> } , <EOL> getWidth ( ) { <EOL> return divRef . current ! . getBoundingClientRect ( ) . width ; <EOL> } , <EOL> } ) ; <EOL> } , [ initialWidth , registry ] ) ; <EOL> return ( < div className = { className } ref = { divRef } style = { { ... style , width , display : '<STR_LIT>' } } > { children } < / div > ) ; } </s>
<s> const data = { <EOL> elements : [ { <EOL> name : '<STR_LIT>' , <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> , <EOL> w : <NUM_LIT> , <EOL> h : <NUM_LIT> , <EOL> type : '<STR_LIT>' , <EOL> desc : { <EOL> color : '<STR_LIT>' , <EOL> borderRadius : <NUM_LIT> , <EOL> borderWidth : <NUM_LIT> , <EOL> borderColor : '<STR_LIT>' , <EOL> } <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> , <EOL> w : <NUM_LIT> , <EOL> h : <NUM_LIT> , <EOL> type : '<STR_LIT>' , <EOL> desc : { <EOL> fontSize : <NUM_LIT> , <EOL> text : '<STR_LIT>' , <EOL> color : '<STR_LIT>' , <EOL> borderRadius : <NUM_LIT> , <EOL> borderWidth : <NUM_LIT> , <EOL> borderColor : '<STR_LIT>' , <EOL> } <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> x : <NUM_LIT> , <EOL> y : <NUM_LIT> , <EOL> w : <NUM_LIT> , <EOL> h : <NUM_LIT> , <EOL> type : '<STR_LIT>' , <EOL> desc : { <EOL> src :   ` data : image / png ; base64 , iVBORw0KGgoAAAANSUhEUgAAAOgAAACqCAYAAACnOQMfAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAgAElEQVR4nOy9ebylV1Xn / V17P88Z71xzhYTMZDYkAdQAioDyiiAoDbS0 / dqtttptD0LLIIIi2ioBbGca7XZ4G7UVpG1FoZHRhCGQkHmokKQqNd95PtOz93r / <NUM_LIT> Pt5zrlVt5K6t + <NUM_LIT> tITm / zyepe8895zz7PGevvdb6rQn66KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz766KOPPvroo48 + + uijjz76OItwVHVgyfvdZ3odffTRRw9UVaZarddPdTqPzbaz2fl29rY9e / aUz / S6 + ujjGY + ZVuuGqVb2uaOtjh9vZX6i43Sy43Smkz3Q8P57zvT6jsV82794upN9ZaLjPjDn / ZYzvZ4 + + tgULHi / Y7LZ + dB4q9OZ6Did6DidaHk / <NUM_LIT> XY60fF6tO39eDPzs233141G4 + Izvd5l758913Z / Ptlsu4lW5sdb3k + <NUM_LIT> OpMz7exnnvC + eqbX93SGnOkFPJOgqumsc / <NUM_LIT> u8 / rzImaL96rGiAB4FRVBBEW9qogRAKN + <NUM_LIT> VhuGTLmFmNM43Su13tfXcz8WzrKW50wgAKY / K8AGOGbieFdw9b + pYjo6VzfMwF9AT0NUFWZzrLv8cj78VxV3PW44fNdHUUVjQ8I4MUAnlR4rIx5cy2Rv91sQVBVWc70tW11t2TKRYoNi1G / YunSI6xW + UpStm8dErl1M9f2TENfQDcZc95fnnl / i3P + VV3tE / <NUM_LIT> tNrt4utrJh3 + jsIrmAuwRVZLE / n3V8JaKMQ9vxnoXvL + <NUM_LIT> EPZOjLwGDwKArYKJTdhWvUouEhA95pauzHJeHnho3Zsxnre6ahL6CbBO / <NUM_LIT> Kxz73TO / <NUM_LIT> s1pgICao57ngBrUYeCx0DTJOY3Roz8qogsbsR6Z1VHXbv9HlX5N86YktEeLSng1YEITpW9E3DeiKVaBtEopBoOFw9Y1ZZY8 + E0Me8dEpnciPU9U9EX0A2Gqtp5xw9nLvsvDtlZaBwF5XgBXTOitg3vq / tTI289Ff9PVZMF5 / <NUM_LIT> x / n3Osw2MIh4vCpWLKhHBbzCEzPKrd / <NUM_LIT> LLaEnaMJl22D52x1JFaKUyYItUdVMMisNfzqcGJ + <NUM_LIT> T7z08X9AV0AzHV9jcj / gPe83wAla5Aiq5NU54I4Qtz8TcLeAzymRLy5sGyuXct7zXdbr9YjfmgU24QT / B9BUwUSIn + <NUM_LIT> / Qy3PZNZd + Ux3tPqWTZNpzgcdRLwjW7DM8a8hgxhUDnn9UoGNHHrbHvGrbyv0TEPcmS + jgGfQHdAEwuLT2LtPJfvPc / JCKm8CUleJRCLqAboEHJvzTf84iC0k6t / T2fyHvGROae7PVTy8vnJ0n519revUGNMb0nh0ThMmpoOsfXn1DuekJxHsBgBS7cotiSYaEdHhMc2waE63YaRmrhfYwSBDV / b3UkyO2JMW8bKpkvbMiNeAagL6CnAO99dTrL3uxU3obIgGjvDe0VxqBVVvNBTwVSvG / wFRWHxR9JbPr2ISsfOVZbHVSt1TvuPznv3 + HF1CEcGkpgZ4VcqAwPHnZ85XFlsRn / Jsq2QcsV26FWUtQbpjvKkSWDc + F9RBwXjQaNWrZdq8EHvzmeA6qpyN9WU / v2ishDG3pDnoboC + g6oKoym + lrnbpfd8olpriNXQEsQifH / L5RkMj2Fu9b + KZhNWL8bVb9fxople6I632NV / c + p3IJhVDHNUv + Xp4jc8qt31SOzAXuFjUMVJQrdgjb6 / m1cv5WcWo5sgxTDVCnCJZy6rhih3DRmCGRyPbmoaOoVa1q21j7h4nlvYPGHN3g2 / O0QV9A14gp76 + ho7 / h8C8Nt68bMjndUfoV15QQPxVMiKeqR9CONfyxinl2J / PfLVjE + O5rVPPgK0stuO1R5ZEjikY2NjXC5duF80cSjGSF + Xv8ZxUaHeXQsjDfksKkH67Ctbtg + <NUM_LIT> Aw + Q3BRw0IGt + IzCbwvqHE / GafSDoefQE9Scyrbm23s19U5d8gkmyGyboR6MZWIcROfTR / e4Uq6nzxtL3h7gMZd + <NUM_LIT> VWpmCGowo543C5Vss5RIxDrr68ZMLq9cggHMdOLgotJ2Qm / y7huBbdhlqJY / kIh7ypAAPHhKrT6iXd4 + W7HGm + TMZfQF9Ctx3332l3Zdf8WPO + / cgZgt044NnY17bcSZ1nlRQZAEZEIci7J1UbnsEZpc9XgTwjNaUK7YnjFYUTPBOBcVgoqAeD1UNjG8UyAxlsikcXQbnQBCsgedsgcu2G0qWHlUcNLpKSIsw4u8oYd4 + mJrPbNItOqfQF9AnwUzHvzRT / wFVrlt5o0zMojnbNGgvsxvXJjmL7MJfRZhagi9907N3CiIDTKkkXLkNdg8LKhpMZLFB + BBETiSe8TDQEJ7RwmwW2g6OLguTTUVUEAz11HHVDuH8MYMoID1aNSY7KKoG + Xs0e9vWSuWBTblV5wj6AroKZr2 / xGXZ + <NUM_LIT> zy2mAOmiIdr6s5z0YBha6Qhs2eJ0qoKg0n3P64ct8Bj / cCohhRLtoCF41ZkkQQdSvUsIjgowCdcLNobgaH9xTteaYoix3h0BIst7v3a3sNrt1tGKn5oH29Q2I6YVi3YpBMVP9HqWTfM2DM4Q28SecM + gLagwnvB43Tt4vX / + igBj0bL / fb8CCm0BqbhRW + pLKK7XqC59NlSvMwTMfDQ4eVr + <NUM_LIT> F5aYvnrljULh0h2WgFG0C8T1iGPxRFX3qTaL5NYO67uboBk5ZURRhpqEcWQ6aVRESgQtG4eqdhmqaf7aVeckqSqLMG5H3D6f2v25UauO5gr6AEsImM233JhX / K07lfBHbk7p2pjSlj9UsIWlAxUUNbk94LkhkcnvDKAfmgjl7dB7UK2pgsAJXbjOM1iWwsxhy7bfiMDhl9Ob / hcCQ957xpmViEfIE / Ir1PGc7XLLNYCODnDO + + XJEwMJ + Y / jFIWv / RET86td8euEZL6Czbf / <NUM_LIT> vf / FdFvBVAJvlLv3jojWBGrJPpqIYlg1TVF + RIJiQFLTbj1UWXP0bjFvSNNhUu2Cs8ekeAvGheEv + BiexnWDYBqodEh91UFUU9bDQcXhbkW + aIZqXiu3p2wcxBMrkkLCyL4 / QqUhbsTzNvqiXz66V6D + owV0Iklv9uk7pe954cxYjXmnuam65mIa / YiD4MoIWcuZ2CDL7yKRo9y1c4839jv + fo + xbnwKYxRzhuBy7ZayjaUt0k0ZoNZKjHRYYMFFOhVyYHtjVlHAOpY7Fj2L0GrE0xhEWH3IFyzE4bK4cQp / H51YdViUPWaWvlUYuTtg8bcs5ErPpvwjBNQ7315Jsv + g1f5OcUOx0cRerOAVmFDTzPy1Dgv0HGesg2sZ5GI3ps / S0hu3zPh + OqjGbONsIlFHVvrhsu2G4arK7WxqsTQiIsqboW62qBPkZvMxzjQ0bH2Ejx7r8Jk9E9VQbEkeC7bqly2VSgl4SV5AgQxiT / <NUM_LIT> vtpJxPwpiXnriMjMBi38rMHZSENuClRVppudV884d49Dfh1kOGc8pSiU7v19ZVH16UbBZno4OOGYWnS4Yypijl3bwrJnuWMxCNXUc915hhsugJGqRBmJZqzmv3cJo40Xzt5FHrvqQF4ZDYyvwbOtqly1BcZqguBwwIF5y2I7yLdRg2j8XrRLJDmV9Oiy / ugnH8qu39iFnx1IzvQCTgemWq2rJ9vuFkVfgSaEDRLjcEVO62rF1Gf2 / Ap1mB6vwtSCsrDcYcuQpV4xmBU + qkcM3HSR4dLtsHcStg9amm2XU02Ez5wbtnRzY7Go + h653EghlSJUk7 + zIiA2ZhkpigvfBUqC54K6cv5QII8uGfMYYwpGOj9DNCQ00MzgvsPw6JTHmeRpaQ0 + rQV0RnWk3c5 + <NUM_LIT> cFPAiXy + szowz1VRtCZZh8kj7tGn7HjlCMzGZWSsG0opZpGtzH6dKqekRo899mCqtLMLFMLnma7Gyrq1ZYaM3koeJYN3uN5 / gFaXCIwsoqKxrWHb8CrUi8btgwaqqmN6YMu + uGB1dWY2KDe8dC45YFxT6Ymr1 + <NUM_LIT> G7v4swNPSwH9BVXz0x1 + zLWz9wqyLXo6hK2yMmxypoXwRNBj / g0IAtRsC09MdRiqGLYOQJr0hoXiM0WoJnDeqGGxpUwtKJkPoZYgNCF / h5ghlOfN5gnxp4pAcgl54n3IRgKKtId4MIontcq2wYRq2RQsdPjOBNFw + PgYCTo0C / ceFubbnsA / e3yRw / j0w9NSQP / lDINPLLc / tHPYUkpN9xSO8c2zVShPChJzehTmG8pSSxgb8AxXwZhotseuBkQzfrDiqZaEmSVlYTn0FRKhyPgpTHk5 / gBbL3qzrQp7RWP5uggeT2IMowOWkVo4QLUgfuLrJf / InrmG4Z5DjsOLtngs / D + + <NUM_LIT> ru + gJ5LaDrYN + MZrHi2Dhiszdt4cA5LaNA9XoP + EwSvMDnvWGgYxgYd9XIQ4GASBl8bBSuGrQOe4WrwZ5favoh85mnwIY + <NUM_LIT> W916qvAKJpwYIb836GgMynDVMDYAiaV7oBAzoBREQkillXkeOAqPTPn4iVdaF4ZICp9pwmCT8LQV0LzXxmJTWGopo3UYq3ow5ozHOE8FRfI6ihMlL9BuZcqRaaFahm1DsWJEeusvHSCkCewYFZpNy9Sio5kRCbKTSOlbI0xv + EYFI0q1BGMDlnLaexCE9qLhAYePZNYjE8oD40Ir60ZqBBdNX3LTFtRgTV9AzxnMACq2qMBQVaYWhfllx9ZBqFeO0RI9EluENwCehEA6MxDyyg8VizmG21GUpbayPOkZqRlG65bEmpXhyMiIVivKeWXD3BLMLHucl2PiocdkF53iuiupZ2zAUisHkig3ZbsHSLcf8Pg83H1ImWuFjCcTE0gMLvrOwVcN + b / BEsi86QvouQRRPWZfKZkKR + Yc1WXH1qGUSpL / Bbox0Hgyx4181tV99sYVj5Mbjf8P / uZSo83IYMJQNTCdQsgiCokOFnCM1oXhqmVySZlv + CLEKLlpGrMi8g5 / q0GRyAbnB1 / XCDUSiKyhqo1VaEHgQ2tOg4jiVTDGMN + Ae44IB + djDZF0Y9G + J2abfy8UoRrB9E3ccwyrHPo5rb / cVvZPdRgsG7YOCYk1RVMvxceQQDcUc / bgyVeTZ9vkP7e8YXxOWVjK2DocK0YkkiriMQTSTCxsG4KhijC16FluazQhw0kVSKnI / uaaj / yh3C + UFWeHMcpA1bJ1QLASBMmLDeROTtQZj3rBecP9hx0PT1u877qTPloy3XLx8PpwxOTZX5Ir + r6APn0Q4oQLLVicUMYGHMM1MMYfFxLMO6yfXYJ6AuTUp0gkkYLZ2HJwYMpRrxi2DkKamKIjfCHUCuUUdo8a5hvK1BKo84jEcjGRIhk / N3 + PFVQCx0StBGMDJcppFh83MXMoPN8TQtHiPfumDXcd8XRcfrR0e + sGhauEpmY2Mr2K90JyjEVrU + kL6DmFJ3GdQjYLoGHjTS54FhqG0UEYKBPNuXwbnq2F2SsRYpgxl1Vz8ijEIXPLYakFy + <NUM_LIT> MkSqMDZrCVJScRY0CNFwTBiows2SYXYqhEg0 + bm7yQg9xIwZwlKywdVCoV / LOCCbcvegrIgavobfukUW45zDMLhH9yRAS8vhg9kqIgWrRccHjMCwtO5ZaGbtGSiu + X / VnYYOoDcDTV0CfBBIHEbkYCwx0vnJ0BhZKsHXQk6YGJyE8AZwjKpQYzoAoTsecU4p6ZXZJmW / ClkHDUBnoOZCIxI0V2DpA8E / nPUvtmG7Qo0HDT4o1jtG6ZbhWGLrRPzTd4vHowy62Dfcd9hyYiyRPjNeywnKRqG1DR92ltuOOR5tcsbNM1nEYcyy / AOrPgVN0HXjGCWggSkDVYlXjeIa4mdWx2DY0Yvx0y4BBbWwdUmyivG3lavuht93I6UWXHorXj1pTjg38SmBBvVfGZz1zJce2IUs1ydMF4 + sBEU9qYceYYbkJ04shLimRmjEiDNdCN3lrQIoJaN28WdQhIrQ8PDSu7BkPZqsRW / iY9DS2DhU74fod57n / iWW + vGcZ5 + HybaUQJhPlmE + F7ZNETx + Er9cRKvqDCSWah73BqzLXgMWmZ8uAMljP / Z + c7qf4PRfKs0PBFhTRU0RGct0KrbZyYMozUFG2DFpKxhdkUE7mGEJoqlaG2WXD7JJSSQ1bBoRSeuwKQkplTHnCI + ybhnuPQCuTyJIX9E68iBQmdn7dfVMd / umBJSbmO1hrqdUq3bXndaU9N72fi / s0QYwiIhhC6E85PC + M1sK4AvJAOOA8HJ33zC17tgxZaqU8cc3hsatmJZ11YZkTIqb5xaZg801Po + UYqSUM1Q02LxZHYjgk + KtjNRipBu3ajatSTEBD8pmiMLHkuOugMNsMVHHQ0N14pxR5wEHje / XMLSn / <NUM_LIT> NA8jx5posZSrdaxicHaXkN9lU9jTzlY231 / VQFSEWlv1HuuF884AQ2QmIUSdOBMW5hoCDsGIPXK6EAoSQsd6pRmZjg44xkohfkkaRoic / kGzq0rKWpKzxVrK0 + fCwytU8PkkmeukbF10DJYCUqpywvlY + <NUM_LIT> eV5kgp1Eq0JC8 + qFFtx3FA7MxqSCnteH + GpIOBDtSlWj47nj0QZ3PtbEeUhLVdJSGmOhfoVRsFp / Qd2gMIv3 / uqZlvvg1LKe3 + z4t1VS87cb8b7rxTNTQDUGtwGE2HkOJpfh099Y4vLtJV50eZWhqpB3VTcKSy1luR1GGowOConJN0qMyYlZYXadzQhcjAAGH2OcwdSHzBsOzXpqZc + <NUM_LIT> QUslyStPAM2HHnryzga5IeE9PDDueGgi5AgrXaY4Z8MLH5WodT08fLDJbQ8usdB0JKUylWoJa3JuwB9XYdM10Hs + jz81E9d7P9ZR3n3vuPupRyZcmjnhkbL / m0cn3Kcu2iJvMcackf68z0wBzWkOofArA5Fv6GjClx5rct / BNt9xeYkbLqyRJOA1w8TOdDPLymJDGR00DNQgKQ7vszDz6Ekh5L3jV8YfDYjSbMP + KcdQJWRemZhe5 / NxEj2F3vvnlLsOKo3MRG2ax1rzChkQcahaQkswz + GpNv / <NUM_LIT> YJNDM22MEaq1OtaWEBO + DWK / JFWPyS + uOVN8jKVi1hcHVdXU4f7Vvmn33vuOum2LHQNqEfHMt + Hrh7LvObjAS44uug9tq8kvGWOm13 + / <NUM_LIT> noIBqdxPisfjwhQB4qJVTmm1hqd3mE / e1uHNfxsuuqXLZjiSSEx5E6ChMLChzS8rWYUKOaU8G3nFC2pPlU2TSnEF0oxpdK0EkzwoKOTt5D7H5hmex1WFswDBctcHEjR9moqHce0CYaggg2JiUoJo3og5CLLkKVphvOD579xQPHGhSqw + QViqU0jQwzupD1RHdvGMIsd1VP0D + <NUM_LIT> zrioN77Fx9dcB98YFxvmFjs5i0J3Viyx3NwXkqHF91 / uHSUN843sl8YrNj / LiLZWq + <NUM_LIT> HjwDBTT / <NUM_LIT> qOUiBSbDQGTJJQrCYlPaLdbHJx3fOTLi1yxo8R3XVNl + <NUM_LIT> AYC58THG0Hh2Yc1ZJhx6CQpATNkRMooQNdcSDQo20DznBbFSgyDvS4x + Mv0XSfnIeFhmNsQMAYHhyHfTMhUygQRXlxdnhxPneUGDrpZHDX48t87ZEG4zMLVEtlqvWBcOj1TPvtctE9dLL0fEmrdNpcC0nkvX / <NUM_LIT> QotfvX1 / <NUM_LIT> oZ9cyre57RhML89 + bRwF830ED9 + ZEq2H1hwv3 / <NUM_LIT> Nn6y0dGfqaby + ZO95nrxDBRQ6BL8q5ENYTNYa6lWqqSJo9Vq8tCRDo9PdLjp4govvCylVop9WgXA0Gwp + <NUM_LIT> rKUE0ZrVtSE0w6jyM0wg5hmTi2pGsiniOkUq7LWh1lYs6xdz5hspEfcnHIb04kiQEfmN / g48LjR1p88aEm0wst0rQUeipZCWl82qsrV8NTy56sIczy8JT79MPjXNrM8g8WzOaulraBkcasSHH0CI22cs9B9y0HZvxnptrZT28pJb9 / stddD56hAppvh95tsVqvWSFNExIzQLvToZk1 + eIjDe492OE7n1PmWy5IsSjFcAMV5pY8i01lrC4M1 + yKmZoUaXe95VKn4 / NuBPL6U3Ca + / BSJBjkbK0RUJ8TSIaJ + YwvPLjE / olW6DZYGyCxBrGW3pYmEhnlda / uJDOJVFX + <NUM_LIT> + <NUM_LIT> KqWSctOFCZmP3452865yox / RlbnYsaC9kykfvs3JqxbkonUv + CTxDBXQHhyzJ4LQ9CSCAxihUi6RppZWp8Nco83ffMNxxz7Ly6 + uceHWME9PcYAh88r4QvC1tg4KtXLextP3CGq3tee5AKGbfpdrlhUHXDxswsY2NNoZtz / S5K69TbwqpUqNNEliyp8Gi0JzNrZrGK + OY / TrKofaGsrNzERWst / Y2 + bOwx2 + <NUM_LIT> rDjhHB5 + <NUM_LIT> B8w + DYmICRchXVhIrfPVx5cv7lMWWMLNE9SSvuW48fQV0zb1Ngp8Yyp2Of61HEWuoSoUsSWi32uyfavOntzquOi / lZVdVGakn3dMXpdlRDs0I9bJjbMCSJiuFNPdPn0xQu97hhsXh14Vco2jcrKIgGnoChTENgaH1CvfuW + arjzRZanZIyzVqaSl28ov + vwbWWEzOoctTfFPHnqLHP2MNAiolMmuBo4uG / <NUM_LIT> G7cPUOz3dfaSmnGqmJEP8OGt1SEnh0VvnkgxnTS4HhDs3OTF9A14 + TFM7iaSbnjI7fAIWPAhjFiqVaq9LJUtqtNvfsb / HIeMbNl5R5 / qUVKon2UFHKYguW246RmmOknmLzuT + ahx8gHxS0omG25Jk3KxeUV6mEJ6xOmmwO4tGVZwDRjWmKWPZNdbj1 / kWOzDlsmlCtD2Gs7T4n54gjE67aZYNPldY29uQ1qBq1YT3hG7rvCDwy7vnWC5UXX2rIilzkwGB / <NUM_LIT> mHPgxOx0VrPiIyS6WvQ9WMtCqcnPHKiF2pMZcnZTQHKaUpiDVkno9lu8ukHm9zzRJPvvKrO1eclRXNpJPht00vKfMOxZUAYrJnIBuf5vaYIyueCq / GxonEzQYPlJqH2dNoysjrptZEIpr9wfPsfQ6vj + NhtR7G2SrVWJUnyraU969Io1F2zOB + o9hRX5qlMXDnJTCJVFSNY0a5NKwgtdXz + ccMDRz3fcanlip2Wzzzc4c4DIWlfiswpKfZJWuoL6Lqxpq26rn0tocuHCGmpTJKUaLYaHF3O + NjXl7nz8YSXXVNh12iKIQs6T4XMKUfnHHPLhq1DhnLJYdRGaj / XmDkp4cKGli59UZjfudBGVavH7OHThdBYGxBLuTqKLSXYXFOu8vyVy3wq07b7vCf7FcDISScqGMFYLVqmUHS + FzwTy4a / vsfBPW6FfxwO0TxiDKjHmnTTBfTcYSnWiHVZTGvc4GridhMNnQTKNWqVKlh4ZKrNH35xnk / cvcRiOwhW3sgDMTQ6wqEpz / is0vaxnC3 / OoqkBosV4fwtlsGyQXq0Z3hetMeVnjrQ04Sey4VQpScpJXFpPpJIpw9iTy5RQUQkEbWS32PpTRzMGdwuj9B1OcLP3WispSza16DrRm / znJN5LqxZqnO / tCDmDViTUktSXJbRbLb42mNt7tqb8bxLS3znc8pUrI3msscpLDRgqekYGSDWVQYSRQAvHq9KORV2jYT2oZOLIeCvcUJZEOaeQunTjFzLiOYaRjbB1O7Vu6vbxOYklY2qihhjNLYhNau / HdB7XnepP + IcGQk / <NUM_LIT> gV0vVBZw5btNl09 + fdHQWO3OwnhlSijof9OYqnWakwttnh8eok9X2nyxYcS / vnz61z1rFIgiiQExz3K9IJnrhFahgyW43vERfm4tnoZqmVhdlmZWzI4321ncqbQPQNDhYtq7PWuG7kqWfnzaplEawizGFEbGHQXNP2qEtrVotI7dCrCe08qpnaS11w3npYm7lhJL9ycTduleIXQFlIgaLx4EntRVIVGRzi8oCy6MvXqEIktsW82433 / d4Hf / vQ8e6foIXkIGjXzjM84Dk57Wh0gxkrz0Xsqgaocq8H5W4XhqkHExNK51Q6kE1OkG6VxQw8kIqGsRQeHk / UuNwpGT9oHDbGTuGjV1Wj7VZCnHAKoCSUGp6FZ9tNKQA8vLGyfaLnfrFl3 + <NUM_LIT> bXlHTjkRQ / hcB8l9RRhCwzTC5mHF10tH3gYa1NqNVr1GuDiBFuf6LFBz85w6fuXWa5Iz2xnXCVRhv2T3mOznmyIpriYyF0iCcmAtuGhPPHYKCkFK1YNAq + BtZVNc9z7d2EygnUxjqR5xtzIgv0FKFP + iuAET2pVD8RaX7XJfJ3u0ZUV2r51QQ1nwgOsYwnWE1GqdXl7 + <NUM_LIT> LxiTR9jHXhamLhPPOGr1Z3 + pxXehuqYiEVpsxFtaqQQzbwPTtyB + dh4DKqB0Z1reRaasdtCfFWYIh3adCSJYXhwkGqSUaLFrY + <NUM_LIT> uf + g44XPKXHDhWWSOJaPmFw / <NUM_LIT> hYbBlGa8LoQCh + NviYJwqIUirBzhFLow2Ti45OJ1a3St5C1IZ9p3m4Jvb73RAF2pv43ztSY6Mp5admcU92pEzskvCaI7P6sj + <NUM_LIT> / Ew9m1801V / Hhi9Mmj4kK3gg7huzE5dvMW37z1fYjIpvPzJ3TAqqqMuH09Xj3KygXB / <NUM_LIT> k9wXXoEP1mH + PgWjIE9WeesQgqIEuWGw55ppKxwsmljMXhnCUZ2OEeqqMlg3GlsAnNNsdDi00 + f3Pt7hkW4vX31Thkp0pIXEwqE7nYWpRWWh4tg4RRvTFpeYjA4146hVDpaTMLcP0UsgL7sZMA2EmyFNn1a0bq3ed3xgcQxKtgjX4oADsHJF / VNXnvfgS86 // <NUM_LIT> uPf / <NUM_LIT> TbfdFf680A2vCBhluOL59ovKf / HKy / iZb7vEHP2t9X + YNeGcFdCj7fYLJ1ruFuAFSK9QxNS5tbC4csy / K5DrzrzvQvza1NDIYHa5Q9MbQslVvnliP9cY2C8nhtEKPaMmhJYX5rMSi94i0uTh8Ta // PcdvrpcsOkAACAASURBVO2SlNfdUGf7oCninxC64h2ccdQrjrGBOLZCPKjBiMGrJzXCWD10iJ9ZEuYa4e / xLAlXlty8PXPE0qlBuqz7ikfXXrAtIh3gv6nqX / z1PbzrL + <NUM_LIT> // aRCa14FKOBRCqVDN9xsR74Z9fKv3 / es83f / PJGfIQ14JwT0Lmmv6yd6K + o0x8QwSihiFo074wQBrp6eeoteOw4 + FX9p8i0IrmvKbQcLDQdy + <NUM_LIT> EeBtEnzTsUJDaM + <NUM_LIT> ulsQBaIHPKfFNZbAdT1VpLrV6lnSV0Wm1ue7TFXXvbfO + <NUM_LIT> Hj51RWqJUHUBQNSYKkFjVab4VrCaN2Qz + <NUM_LIT> Nyj0IY8katg95BiqW6UVHq614tdGX6sb8NsNb3BycRKKCnpwPuuq7i8wB / <NUM_LIT> m86T / <NUM_LIT> <NUM_LIT> / RD3z0ntYrM69sHTD + <NUM_LIT> q // uLLpS3i8jMet // VHDOCOis92Mdp + / sePdv8VKWWEQshAM1H0VnNbbk6J1pcNw32mMu9WhZjTHF8HDUh5FJMIDzhvmWZ74ZupyHd9Kio3tA0HxDFc9IxZILgldYbAtzTYdzgqqN9aIejJCmJdIkod3JaLRafPTOZb74SJvX3VjlBReXMHnsjZDuN7fkWWw4RgYMwzUb0 + <NUM_LIT> i9 / ZoblZLhvPGDPNNx8yiJ3OmqHftItyffAjRuYq1mrirYXvF7Dk43 / <NUM_LIT> ppReeWS6TUVa9734ospPbMT61ouzXkAfV60MdtxPtTvunWDHFLvi4A / byxcNj7sNlWGhqajPW3BEIqAQ2hgM0DhFS3OfTot5JBKbtaoaFtsw23S0nSBiMKp40TjROhqiAvWSMlyB1HQ74jU6ntkGtDMX39uA8TEhoevTirGUS5Y0SWm3W0wsdPjQ5xf4wkMV3vi8Chduz5PowqySzMPknGd + GbYNWqrl2M6ytxhclKGKZaBsmV3MmGsoriBxtfCri0PrrJTRYw7ZVRT / Rs0dXmzLtnoFttYy5hpGVfXijuqukjG3bcT7rxVnbZjlF1TNZKfzusFOdrcqHxAYW / WJRQQhz60MBubWIeFZo5ZKOea2iBaVCD0yGtg5dRDbdaAm7utgsjadMLGgTC45snxna + hrZCOpoBjK1rC9LozVDKkNa + h4w9SSZ2IROk4L4cxjpxqv3 / <NUM_LIT> g4SdjhHKlQq1ewyQp9x9e5hc / Mcsf / <NUM_LIT> MSM8thjXnyvgi0nOPQTIcjM1nIMopJ + CKmuB9GwjyW87ckDJbD3M0idS22fQkhzLNRQk + Cxd2gxtVGZGsiwV4Zrcilc0vte6bmW1 + YXWz / pTb04o24xlpwVmrQr40v7rqwpX + pIjd3H32yjdPt8B5yegwWhymFaV1LTWVqUelkMRVN854zUWDFdjN3DCCGjvfMNZWlVhFcAQw2Zp / kUyqtMYxUlIFyNBVFcd6w0FLmGy3CvrEoLna6i4JFT5C / UAlScCACJNZiq1WyUspyo8U / <NUM_LIT> mlw + <NUM_LIT> MV19f4aVXleMUbcg7sy + <NUM_LIT> YHmyE8Yx1PNxDN1YrUjwi3eMJjSanqklFxIiCl9cu6b9uYcNUTaJ + G0iBgeUrNZznmGx5V7XTvWVC43Obw1Ukl + Lfuum46zUoI3F9GVPzGQ3N9tKN4H8BEvVEAYpXBDROKQ2tHc0GAYrwgVbLFsGLdaAShCu7lwWChkJJI7jyIKy0MwnUVKYvV7CQW1EGKoIu4aUwXK + sYXFFhxZyJhtOBw2Jo07jguZaVd7ikjx / hTXygPkhiRJGRwYoFatsZQ5PnL7Iu / + + Bzf2OdC1 / dcT8YoysySsn8qY76R4YpgfG5hhIOpVoZnjaVsGzJYE + etSN4T / mzDUycqbIQPeviwrydinm9jYq + Rrl8uQLvjq / ON7G0z852HGq3sx1Q1fdI33ACclQKaJMmNjTYcmFbG5zJcHsrj + HyPIo0gNq4yOTcrUMTmxGCMYbQuXLDFMFwFK458RF7eWSe1ju + + yiJG6DhiMkL3K5LQRoByybBjEEarQhKbP7cymFj0TC1peG3 + fIrpL8E0Jmb4rHCkT5DZE9tQighGhFJSolYboJSmHJhr88F / nOP9n17i4GxPh / goqJkTxueUg9Oe5Xb3a1ZxoadXyJhluArP3moZqoXY39lo4K5u06781Z5iZ / mZpebr0lrnbsk6r7502GHw3HxBEjOk8m4QwZ9qON0xu9T + <NUM_LIT> Hyj89VGp / PyU7nuU + GsNHEHy + <NUM_LIT> AfNt3vDfpfAMWm46xQcNQFYwp + A3yAbWF / xY1ROhw2tNKpIdhTa1n + <NUM_LIT> BKs + aYmvdkWRifd / GIcOU2qKaG77hc + POvKf / nbqXpfFEMnVjLaEWppXEMnyrOh9kji + <NUM_LIT> QXaKEfrBEZtdIbCqmuYbsYY21m3eTrzF / LPipGs3pmMUkBmOUSrVKWirRbrS4Z3 + DBw62 + O4rK3zf9RUGynnFaAi0tzrCwZkOgxVhtJ5QSi2qoQ17YL4tVjxbB6HZVBrehhYm5wqEEAs + + Y4KK9Bq + WvnOp0PLrf8S1HFWOHKMeW8epmhUh7zjg563gmDUNu72PTXJ2395ELL / Z9UO2 + tVCqPbNwHCzgrNei1O0rvr1qea61 + <NUM_LIT> ouqAyYXMvZPZSw3fZFB05sA5DGRxe12Hsj10kr9FAbFVi2cP2bYNmS4 + SLhxt2GWgqCYzCFf / Miy + / <NUM_LIT> c + HmiyxWYLScsbuu1FNThFXmW8LBhayHLe5WfeZklGpv + dXJ66cVay7iszGvFiGxCdV6nUq1jkP4u / uXecfH5vncnjbtnCwTijrRhaZyYLrD9LzDxZixqAEck4vK7Y97ltoWwa3tyzotOFGKV8 + PsvbG1aoqqtn / <NUM_LIT> / nmjcMfHfkbJgY + vFfMhWd79JQTRmXmS55axqeVNu3FkpoAA37K488ILzSq9MU / MasWaPorSccmDWc3Da0cpY0WO21 / Q1Yp9UFoz40KtWLPWKZawccmaRPNqoqPecPyr8wvcJv / Yaw1U7U6woToXltnJo3jO9nOF93us2p41On5EosS1ovV6nWqky28z4H7cu8N6 / mefBw6HeEQANxquqYXpJOTDpWGx5ljpwz37P3QdgoZnnTJ2NRu7xawoCkiePePw6TFwR0Uql9L7tg + Wry5XkTzDiAnmfj6vIeymB + nxnRAvFCKWEfbWE120fTL + / WpXH1v3xngRnrYBCuIHP35X + bbOdXF9K7FuNMCcoS23PE1OO8TlwzhesKAI + MnBPts26X4BD8HiJZp2Gbv550kMwbzzXnSe885UJ / + ymBMUzvhDioRoP7WJjr5aJtFkoWgKAMYZSqcRgfYBSmrB3OuO / fGqB3 / <NUM_LIT> MEpNzoWY18NweNdDJLEfmPPfu7zCxqOB98MbPIQa3Vx4NMFox3 + K9P38972WMObilXvpXQ / XKt1as + UIsJgvuRh7n7plCnoh2qiX7Ptql60aHKn + <NUM_LIT> mUnzZ7WA5njJRdK8aXfyfpN1rrRW / kiMZqhjruF5YkKZXXIrBikY9SeUlODv5SaK4IvJ2SayugarlkTDaYkYRIXEwEuvFN7 / OsMrr05ITcxsiARQ3j / <NUM_LIT> TGxwzUM31lKtDlCrV7EifPnxNu / <NUM_LIT> N89I4WrbZBsCHHVFzIE0aKkE43z / hs1KDH39WCY1AThjoZd8NC5u9fbGfv8N6vq9NBvSR3bBkuv6RaNq8vJfKI5n5nXiShUCnJF0aGzY1j9fTt27aZhVP9ZE + Fc0JAc7zgooEjLziv9KPVxLwwMdxqVMkUxueV / ZPBPwWioJ2YkQxiZboaiMDohn0QmkVlYmLv1 + D2qQ + + <NUM_LIT> hV + I8vM / zWGxKuf1YSTGW6PuNmb + / jq / vjmPsi7dGT2JRqbYBKrUrbCX9z1xI / <NUM_LIT> FZ7tzbJtc9IdEhX3HsdqSCnJUEkazyUw8zTbB62piBpvIrS859o9nx37veq43WKx / dMpBeXy / ZtybWzglQTmR8ZCD9kbF66aVlU75vve + <NUM_LIT> VpwRAfW + / W2qOrLe1z93V + n2T / xh + TtLZf6FEd1v8LSccmjWc2ja0en46E / mlmDXlzA4kOBz5vMr8wBNQEwq165OFjWxLDCatAqXbhV + <NUM_LIT> bWGd75C2T2SRPNWe3ZQV4yKFEPpkjerbbmTQa4t89zfYsp13slAAqstIpRTS31ggLSUMtHwfH5PM8SBo8UQQlKKy4M + ZtNq0TYMXV2ah9BC3yYTyT8HNNVevqj + bxec / <NUM_LIT> N7y9Zz3WMMY3RgdL7a4PpFfWyeUtKenWtnPypiJzWE + y0Cqj3jUsW2u6v7jiot915KHtgvpH9mKquK9TznveIv2Fn + c8GyunVpcS + V / DLoCw14YlJz8Rctmp4MY9nSZ7gkJu38d8uzAomuKiW0WBWoUGUX3yp4UNvtPyrbzXUS10 / NDd781gqRN83phSq5IK7dqNY4wcLHRNiFzrNG3blMdYYnBGhWq1Sr9cpldMuoyyKjyxlMbrorB0Uc / y6ClYbCAdS5CKk + J6kmflXNzN3z4Jz7zmqOrCeKw8ac3S4XvqN4WEztd7VnwpOi4B67 + utjnvvnsnk7v + <NUM_LIT> x / <NUM_LIT> gY1PwyITf + YXH / If3jLsvtb1 / <NUM_LIT> Xrf + <NUM_LIT> odsnjjeekvDJS4rmTlrzCqXpTZhrB3PGNh2YWClDxxIQpYPrcSTsU0DVu7WvK88fkJf / CmhJc + x2JNTDCIbx7IBolCnt / yfODS5gpFbv5aY0iTtCuDutpnPlu158mvK2fzw8c0dFSqzUzflWTu7iXvf3Bz1rd52FQBVVXjvX / jgQV // <NUM_LIT> cfde / <NUM_LIT> xiFX62RhngeiLHbgzsPZTV / <NUM_LIT> Zudz + + fcn6vqBeu91nU7q4 / deF7pDQOV7LuslbtUIVPlyLxyYEppNCFoRV9kHYEJJFBv1tFJw8RYZ14J49g + oPzsKwy3 / EDClbsFV3Q1sFGfeYyC8Xn + k + Qnx6ah0Lb57yv + Kqs8do7gRIvuda3JvWuD8 + aiRtv91XTLfWq + <NUM_LIT> bzqNK3ylLFpAqravnFyyX3u1r3Zn31lr7tgtpnfNR + D4eFnRBhfxtz2uHvDV / e1759c9u / <NUM_LIT> tfXe93rtte + <NUM_LIT> NidPr9Wlp9KLUcRoZnBgRnHkdmMrDecrL6rUdZYkB + <NUM_LIT> vY0aMnhzHkG8cu1u5Td + sMTPvlTYPuDw0fxyceK0RP / <NUM_LIT> OcenDK6H1GOsWKPvfjZKqonsa48E0tisb5CSOX0IB6R0EzboS / vSHLHbMfdMq06vJmr3ghsuICq6vDMsvtvdx7iS5971L3o4IKGwQeST2GOCW8F66iRllH2zlL / wqOdX3xg3N07u5y9XnV9tU8vEcmeuzP5bzsH0qvLif8tY10b8cw3lf0Tnql5JSM3NyPzq2vToEHIurHU3HTO46FWHN9zdcqH3pTyxhssVQtGw3B5j4 + mrZ6W6i455r9zD0 + <NUM_LIT> uIQyp8tvX + JvEH8zUG57fUtdLJ7Z7PsTevdZ6cDGy6gWZbd + HcPuR / fO0WqsV9sHvAPghkY05woIfYKyDtDdhzsGfcXfvZx / QvVU6u / u2DETN + <NUM_LIT> u / yfBg03VA2fFFUygZll2D + eMd9wBBUYqmG64wAIp + <NUM_LIT> xZm93g4fHjQTzNe9BBEGb5hFF9Z56Cj96s + F331jm5ku6NaEgRc1p5HbD6zfDqIlmtPaqz9M8muG0Qbv / Fe5F8bHzwojwPTq1z2o7 / r + <NUM_LIT> zH1 + pqXXn5H1PgU2fDfsnyb54Occtz7qyF0sU6Ti5Tk3WmT / GIlaRMEoODX848PC73w + Azob0rn7mt2VB577rPL3DiXuNQnZw6Kh3 + zRueiftntrS3rSu3IiSfK0L09e15nXchZEcW8qqNpiQG / u3p4 / <NUM_LIT> nn3K8v8 + vcLF20x5NRU1zfMW5o4zAZPQupWz / SUsZ2paUvrwsmb3j3yuRICisPjCr80zJCBludFDv3qVMf99pz3WzZs2RuADRfQRU / qSPjs457f / qJn34xijC + EtTtJimgWChZLagzfnDT8zheVr + wPVSIgGzr74ppn1f / P9vOrzx2oyFuN8fOCp9ERDszA4VlHlsX + rko0V7tF3WHRPZUzJ42wGYJF67j + fPjtNyb89HcmDFUlP65CsD0mTxRdFzYUK9 / xbPU2V8fG3I1wty3dPFtTODqKTzPv / l07c / cf7nS + b0MuuAHYcAG1QmI0dNlbait / dofwka8qC02DKaLqOdMmpMYwseD4g69mfPRuRzNzkWlVINvw4TQXiTSv3VF6 / <NUM_LIT> R8hWV1PxRIupQz1JT2TvlmVpwuJ5MwWD6RjM2j5n2JFKfPIpKVUrG8f3XCX / <NUM_LIT> surrhVKJr + aJzSn00As9XHSeCoRDgZDbt7mxf2991hBDQdn2P6JB + VfbsYa14MNF1AjJEWRs4RkgL2zyodvc3zq / hAPNGKx1uI9fPRuxx991TO + QPT7iHmiBti8 + YsXDciRG3aXfrRW5dvLqbk10rFMLzn2T3VYiD1lJQqj0OuTrv22SRFElyI2OlxVfvollt98Q8rzLgh9giSaXXKyM0OecVhd9z + VRRAstvw7dIGs1JCf7MUwtQRf3AtfOQDLLb1wQ5d8Ctjwgm0RmwguTmOmSG / rqOfrh4R7j3pedrml0fHc + pink88x8ISaO40NrQJPvunj3a7dVvraX6q + <NUM_LIT> KpJ94ZW5n + <NUM_LIT> dHzO144Ou + YXXZsH7KUSib03iVnnmE9Qqp4ink7Gs1 + VS7ZCr / <NUM_LIT> <NUM_LIT> hJfedzzh19yHJiJTc4igXSuGaSbgtzLWO / L4wuNerwIohbEs9iG + w8rTyyE6iTjPRXjLp5WHR47TX2HngwbLqBGfOpjW8ruvurmpbad8vcPdLpJpN2nxH / DOL44Vm / Tx7sBvF7EAX92 + LD / m8nUvW2549 / sVGqtTNk / <NUM_LIT> Rkqe8YGDWkCQZt2Kfti + XlW0glk6TihzqtoIltsxPHCi4WbLkj52F0dPn6HMt / OqaSee9X1EnICuNtS9BxG0ZOp + Jg9MzmLVMTwl3ByRX4gL4wQYnuS3AXJ36ebP51XG6kaMufYMyU8MhEaxAlgxXPeoHLZGGON2cZHVPXVpzv39lhsiombD54G4s08ZtcWI + qOMePExGoNi2ABt + katBe7dpmla3el794xmF47WOavRIKhOd + CJ6aUqXmN7GzeczaSvJIR / Ec4ad + <NUM_LIT> h / oPIZegTUuJ5003WX73h1K + <NUM_LIT> pIIvvYvYsx75RuHq2seL9zFSHtsdslWKNMdvn / vL9xb6WS19D7t3cm9nH8tHQPNCdwYM7z2UctDx1VskjUj1Xg23d5rt / u3YDV36tq9U1nWjhhU0xck + SpZSZkJhyzd1ZqzZws6j6c + <NUM_LIT> esKdVQHNcOGoeB97wyIx / yULTfaDV8dd7FaaXQqe / LYMwUI4ncxzeK4W / uo6aUM3N + ySOXnJsH4Q3vzzhFVfDH9zqeeBIrDvVOCw4794Qm1 + fvaH2k4TmKQVdQQsx9BA3NyaD4m8StKQxpOK5ZIvl2cNBm4Ym5oGkzLVrbqnMLMI94wmTi76wTGqJ5zmjyu66I7XmIWvlJ7cPlb94Ru7BKth4ExefEEkOHxson8juU9Ui7NI99WJthfdsJkl0Mrhs1HxOVZ + <NUM_LIT> Z9L96GLb / VLbsb3jHEdmoV7yjA0mVNK8X3J3TuiaoIQKGxW8OETzznyhQuWqXcIH / lmFzz6U8SdfUY4u5JZeb5LDOa8 + o9DFVNBYhK0SOiOO1Qxvel6JRIRvHiHMPxVl14Dj2l3CUDlqTs0n5SQQx2oIsNxWHp4QHp + <NUM_LIT> + NycNZ5Lhz2XDEEl0bZN7Pu3DiS / LCLNM3ojjsGGC2hJSPPCp27w / kmIjjgrJJ + JooSqjxZZC9iUPi9rgQT / <NUM_LIT> MNPzPqPzrfcuxqZ / <NUM_LIT> lOpuXFjrA8nTFUltBv1 + YTzfz6soGEopBa47S23Owz4vmuKwzfejF8 / BuWj97paGQ + tzXW732ecbleuYD8c + STukuJ8Opr4Q03mSCECtfshi89BjdfpOyoJ3FagA8Nw1WwGJBQ4eq98M1x5eEpoePCd2JQnlVXLhv11FMlScxspZq + YqRkbj / NH / <NUM_LIT> ksOE + <NUM_LIT> K4R8xfveqn9g6u243r9gtW3URDO7t / D71uG / dd3b7EvMMZ8dKPXt15cMGKmr9mR / sxFg + mNA6X0U3lT97mm8vhUxvSSj9ZUt4HZSQmOxKa / SjRXbWzEHa0QCBpFlcGS8sMvgA + <NUM_LIT> yXLzxRZDt8O9rkxAPQGO5QLWdAs2Cb0dImLBucDzng2 // <NUM_LIT> bDj99sGS4HRtsInDcq / OBzLTvrSQhJKaGDhloSFC8ZinBgxvCZPYb7xmOPY2Ck7Pj2Xcp125WBUihqd86PNJZbv390uv3CM3YLngSb9hW1Wv66 / <NUM_LIT> / + DHH8peMjnfy9nGpDPptqXMJ99sHWLpmp32Pa + q2 // <NUM_LIT> kpdItllr2wjsme5831KLW5pt9xwfzfiyNWwZtAyUiQSHLz5bSMY3PWwjhBxejpGbPNVwZUsPEV8QIQJ4Ee56Qvmj2zo8NG4Ki3dlb6FImUgY0nb9eYaf + PYSXh0inpmGYb7pI / EinDcMqT3xlshdEgM8MW + YauZstqfTgT / <NUM_LIT> cjt8n + RsajfDOPw / kg4KR44eoVRK2DK2LZ5PCsZywSj8xM3CTc + <NUM_LIT> qHiM75m6FvvPhPd2hX + qcZq4Yphddtx7BI4u5VYI1FLlOSOe8wdWaemSH2zq1Sh / llbLb99aNwefegecHmzqGaqq8sCh7Pv / <NUM_LIT> ya59 / uHN5I8vPy2iGROEcrDi + <NUM_LIT> yLzuddek / <NUM_LIT> kDeebDW / + u1l4 / HGttAfcv1 / ouHe0M0YgzH2plQzbBgylEnGAUT7F0MfTHnoFcS2WpoTJThC1ZtvBP9yv / PlXPdON + PdCPFfaLt9ynkQBzRAD00vCfGulgJbsiT3apxbQTg + TbboHRuQk8t8Fw + HDh0nLKWNj2xBRBiuGN94Ir7ouoWSjVQExYQPyFjZEXkPxRd2nAo0OPHgU9s0avA8HYyKei4bhksEszLE50eeKh0Zsnzpfwrx3y3Dpd4wxrTV8NZuC02LkqGrlHx5yP / <NUM_LIT> x + <NUM_LIT> zP3bnfjTg1oeO6CC + <NUM_LIT> zM5 / <NUM_LIT> X2bS + <NUM_LIT> QP4w + nvnHMYX / a7JhnvvUsv9SObE5JtpqAJbBoTExGEfMU7nC + EMWJvPWowMjhs / dJ + fa8L / vF35h3uzOEktdJCPRC + iyvW7DT / xQovzYZxE0KBuUzRo7lELofFzEAAfw2dw + PABkjRl5 / YdfPeV8MMvSBirxQOmSNCwkTiDPIc2ML1RQDE4dXxzEvZMCq1MCdUrnt115aotnloSrLUTn4JxBGPxBAmlgFYfIPNvPm / rwP9dw5ez4TitXsjCwsL23 / p69a8 + / VDnRa0MXn + <NUM_LIT> fPE / <NUM_LIT> lz6F8aYA6dzHZuFQ0v + pql5 / <NUM_LIT> GldvZCH9OoLJ4tg4bBWhLDTnlwPZq6QtFf9 + QQUgFNjEPk4QgNZUM8Og5 / <NUM_LIT> iXPV / f1aJgYP3zuecKPf3sCqhhRJpcNCy23YRr0j7 / c6bEOYt5rsU4TW7SF9zg6eZSbnp3wjldt5 + KtFEx / <NUM_LIT> Nqfd7kIMeBcTeaaMzyuHJmDuw + Hwcj59cZKjivGPFurufbWONf42GL1iG5qWHzf7uMCGMNft5uttz5758gZISxPa9OwwcHB8Uu2yb7XPjflmu1LtDudj59NwqmqFe + zH1pvx8HddfP1a3ba79w9nLyplrIfBYdhfB4OTGYsNCjMNFUXj8e1fQWCwcRKm9Ca13Y1gIdLtsJ7Xm149yst540JPtbFCRaXt3gVHzvpbySNu / Jz5CSZmmg7SjAlVZTtw55ffe0oH / p / t3Pp1nx + DXFxceAygI8at4gTBwNrtgG3PS7c9oSw0A5DjavWcf3WjJt3O7ZVtTuqIV7 + hK2fVHsItrzjYnTDFJznB2y5fPeh6eVfOHjw4GnJbOvFaR + eVDK6zVpDaoShSrKz2XG / <NUM_LIT> ZAv1hL52GZ26H4qeO9fdWTJ3fLgUXf5QNkfnmtl7xoq2T9eazZJfP6fT0xM / N10aeRnF1v + La2OVpuZ5chMRr0sbBmylOKd1x5tc / IXCZ3go3tHUXcau0IYlBdeEtIG // fdjr + <NUM_LIT> wzPfdEXsVNSsuGJ3A6 / VoMrX3u1DfOwXKCqoWIxAKfW87nrD655rqZXSIvjtVIq2mUpsPA5gTNfKwNLyngePKI9PCz4mhiTiuGgILh1VUtEVdeh51a0WCQurfL7CvA03M0T9ogcv5OHCuhjz47Y + <NUM_LIT> lXgk2u8SaeE0060 // <NUM_LIT> GuPz5kb79s3zQ9cO8DV28KxXkvln4ZqpbcYY75 + OtfjffOqhXb6gQeO + u / ZO + vDl6pQLxku3yJfP3 / Uv7lWKt263vc / <NUM_LIT> GhcOL + Qvm + h2f6BtlqT9 + IdrRlGByy2IC9i25R8k + QPF7 / <NUM_LIT> EJI8LUkagff83yN7yVQTM2eXIA // bLnyJLwE9 + q + WADppZhoaWFetk9bAoTt / t + PebfCUxcgHbH88dfbpNnNgU / PBBCIvDiS5Uf / baEnUNdTreYMp6vNQqdjxlB + aUd8OgUPHwUWr5bbLCrBleOOQZKitc8cy1ne + LPBXN8oq0eL1IIavw3fx / DvEU / oI3KB3ftMktP8XVvOE67Bk1T3RZ + EjLnQ4sQVRZbvGg5a315vtH + yEA5 + fnNNn1VdbTp9efvm3D / ds / RrNzxRAInmEeLbeXOw9lN + + fM5w / M + <NUM_LIT> / YPcA7jDH713qdXdXqXuD1hxc6L5lqyvsXGu65HpheDoOCx + rCcD1sYi9hdKGIA42SqytP0bybQ / zTip + <NUM_LIT> DKeCmwdgJ95ueHITMZSs6ebQ + yrW9DMhO8jPxRWmMBPkUvYPVDCPcxjtJdv8 / zYCxOu3R3GHHZNzeg39h5I0s1n1iggR + bgvqMw18oPCBhOHVeOObZWDVYjXdSTn7zCkTyJtYc / <NUM_LIT> znNeRWWdKzIH5uOe8 + <NUM_LIT> bfVDT / oGm4jTJqCqmi4vd37qjgndpTiMQC3N6b3IRnrsQsP / y04ne + <NUM_LIT> yO7ulmtoPisjyBq / DOud + <NUM_LIT> NGZ7JcfOqo7llpdjRIagEHwQkJIZGIZM / lY54cuHpNXTS5nt4xVzAeMMY21XnfXYPo5VX3B3jl + bH7JvWfZ6TavysQCzDYcW4dsaHxNvtG6m7mIJa65j1BPaRswscMSHgAAExpJREFUWLPMN7VwffOmLIqJBeJSaD3IR0FoYSo + GUJTOBuuZSzDNcePPM / ysqvLlIwPjHKh0SgEMX8sXDmUgAmGhabnnsNwZFFRtahAJfFcPpRxwZBiRREc3nTN65DU0av / TwKRDKI46BQr9u / xvGPHWPnek3 + jzcFpMXEXGp2XN1rZb2ROrnJquGvCM7XQ5qUXp8GKkBhq6LHtBE81TfbXqubnStb + xUaEYLxvXXNwwf7RnnF / <NUM_LIT> / hS9DlizFDUx6SBPPk87KI8WIBAycDl2 + ze80b0Z0cr6cfWuw5VHd0znb17ruV + KutIKfcB62Vh66AhTQJRkg / S7bK8HpP3QzrZi8VMJUFYbCmHpuMnFs / MsmG + BRDHLY5YrMlvs / T857tBiBOwuO2O4U + / <NUM_LIT> MYm8P3XGv75TWHgsmo3FJR35 + <NUM_LIT> mC + QhDkOud1sdeGjC8 + hU6E8FnsTABYPKFSOOtMgejceW + mIqW + + UuZNGD5mUWnufIm / eOZL + <NUM_LIT> xreYVOxqQKqqjunF5u / <NUM_LIT> + zw / YIYEcWrKGLDbfFejUFCp3enSEyd10iuGSPWKJXEfn6oZl8jp1hAu2 + <NUM_LIT> + eZ / eCz5wNYaOO + <NUM_LIT> aD / kVU0coOJVVWI7dlVRkzff86pWjCRGESNzr7kq2XKqh8ZUq3X11Ly9ZaaZvcJ7ExKNFIYqqmNDqaQGFB8rCgT1qJhAXXhPuHeA90 + xJaNWWmx4Ds2GHrEGw + RyGOybJ + bvHLBUSkrejrTQLD0s6LECGsTX4zzc84Tjx19ouWgsf31PcgG5KWlCJhM2CGoMOTl17JsS7jsK7Zg3K + LZXlGuGPMMleJzlWg8d9Mw8lauRb + + NVGNuUcslBJzaKBufq5q7f88G0rNYPPDLJPlxHyiZOVorxkR9KUGpz468bls5n6EEUS9U2PMbV7dz5yqcAJ89pvm / <NUM_LIT> / vSmMkq67zd + <NUM_LIT> S21dXV3dPasYtpkhMEACEthGBg / <NUM_LIT> ThektiWY4vYKI4jAVKC5ASzhoywAYvgeCQgioJjQyJsIyM7dkQi2SRhSHDYBAyYbVgM49l7eq2uvd49Jz / uu1Wvm8GeGdd0Den3zWjUU9Vd777X77xzzznf + Y53x6MGT + yM4Ahk3XxmwpvaJdhOCudVNRFmGoR7nwR + uN1oEQl + <NUM_LIT> fWMhuGLG8b0R9aNB79XCPBa / HTAbJOwa9Jgts4w7JhHbqbpkT1TrQ8UMCIEWuB79uqz / UgoIniksG5EY + MasgoSimPmj3LBobsyXbhklDtGxgNu + X0fp4yqrsYwx39A6A6rAhu7rXavCeNAhfFfrxGe2StoGQCIkPcNzlvBOH81MBy4HI7rw + UFc28ojnlxqGE8h32dBB1j1sxU2vfO1qJt1Rafc1Qf1Gcc0xiUbCfzN5n5gfkWrm22W1eykVx3i2PdZHfL082jEaCJJjIeXV / Ke / f062lWZ + V7JPjJGxGefAv48NmE9aMM0808Ujwpi + A0fT3SaIjgp68Bj + <NUM_LIT> iKAjKWdFEFAA44lh0MeLS0oPM / NAv5vjKuRZfV29LKRKFiQpjrmYwWvSQDxcli4C3JSDf + da0tcLAZ5w4RpieF1Qbtg47ktdYPw7kswSPgSAnyGc05qpiHxDusUW9nBGhV87oFXYMPAFMYiaNsyGn7ZSch6MAzDcVXtjP2FOJPS0BGWVwWomwbghWDbIbeyd4vV36nzu / RNfUETfGLgpCoVBvdd6vOtETc / XmN4YywV8rNZjBScASJYmUUhUA1882Gv / oG9zabPOnhLSyGj3OKxAgDE1iMr66V2W964pKHeznOjQij0iDhFBpC777tODkksJHzxSUsoTI9aeKFaXWJHh6d4T / eJ0RRdTdpilCXzxoEjHv8 / Zqle / b1zI3zzfMpS0orxEBe2cM8qHCaAEI3FEJsfIhAKZFpPve80ycNAgA19A8Okwo5jTKQ0Ahi27cxvEuQhNQLmoUssB0lVBrSVf0WsSqEvTI + eje4G4Njs64sKwdGylptA1jxwHGG9OCiO119ZTBCQVgY8kg0HZzvKDc1EXilbfVbo8yYlv0OWTDCa / alCva7c4nZqqtG0v54J5BUFGXlElUymZ / Xi5kP1MoZD / ga3liweVkltDT24t5tbmUD / <NUM_LIT> YJADrQHrnYimyv5ZuzBn / <NUM_LIT> KOOhlxmGCZ7S8D0PE / OCO / <NUM_LIT> wo9fEXQiu0l0A321UhpAXw3UoVBQ + zaM + l84ZcS / YDSDRz2yvNlaW7BrymC6wrYwKAa9badZRApy5AGx / FdSto3LnjZIAN8jFHPuu1RMoxN4sYFBgMAjrCox1pRtb6ZrbrMlGlvyUQSEmnH2KgVmm811kqGWl6u722ED4M0pxkOvCHZMAYY1FCmszEa4cA1w1igj1JZZZMOeo9uu / rqwkw7sObYNr6y3zd0HZ1s / rbX5vKVey5LXQQGgGNCjInJBpWEuaXX4FigpZn31lULo3RFvi48JNCnP1galyxElWOWHx3drPLuXsflUws7ZCK8etINhrSJEL8mhnItAK3Os1gkApbx6SkQu2lulSyoNvmW2JScKNKZqYssyOWCo4DZ + <NUM_LIT> TZtQUsb4BImdmCTi7UT7W8ug2rTTmCCpQZ2K5kAwUPGZ6wbJ1RqGtM1 + z3Oc548yjh9XBBqAsgA0pNUsxGj3aYerBKe3wfMNnsJqGJgsKFksDZvI2zEU83tT7tzG4yRAr3dgYDQFjnfzLf + d3qufY8 / <NUM_LIT> P3VkFITS7GGgRgoAEeJu + / gwYM / yo2ODuWVOubFYKXYFyKobgxDcVnF3ghtBn7yqkFP4BiJ77MJCJtcIQDBMZdjiePTbzPzv + <NUM_LIT> qyVUztc5VzY7KsRD2zzPmWoKxIY2sp1xuLearWsPrUfB6lLluG1j84HFdIRJzewGT6EWxULGdDOU0cpkIMzXBCmPwm2sVShm2fAOhxM / <NUM_LIT> WujqTcbPDgB7Ku7YBqEGNgwLTiw6UTSJS23JXMQxLTD8aiS29C7IZ0A3OuZSrkS7AXx5KZYxMAN1GB8fnwcwvxTHCqA8gllgcN0vu / Qwd3u4or17z1oA9TpPlkwvSSk1D2BLg / nefRW + babKn2yCqBUp7Jlm5APCWBHwPavfmySGu1OzXtPd9r1kjS2TRCAouCZrm9k2UGQnsSFB8VOkMD4kGB3W0GLs9YjzNjYppGCEYYzCjglgx1RPg88D44SiYOMIEKrkGhJt1HELDjmq3SCdqMsf2W2IQKl / J + <NUM_LIT> fPVZULy / VEgZuoEsM31LlIhvnwEpeJp / X3Yoade + V + A1Ct0hrbXTJBc2ySr0J4A / nO7J5 / <NUM_LIT> z09Zmm + S1DRNW2oD4JjGQZpYIHpbFQtUGcZ + p1LbsYEhK3rsVIpkp6IxltHElilfQAY3 / GlX8IYKsGBCPAzhngpQMGjci1jjFWZIDTyoxSmBDSdA9D6l39bsKQ3CL7fRW7VyA + zW48kNwy9RJHIiCF50VwzdqR8MfHajXvhGVloFpDO3O0BHM6ZCKie78kqXW9gARk1fAHpjg45NM2EXnPgbr5k6ma + fJcU8aZNCbrBvOtCCN5wlBOw444iCUo4z5SOCUCIOFpk7lCdYjXeiUWm5yCrUU6 / xLzdydrwPP7DKYbcXJIGHnPYNOoYEVWoJQ1TPu3e5EX8XOBnsukPnvPQ3yY22JI75hOkxegCU + rLSuH / W8RUaefKzlcLCsDHQmN14Htze91jhxqD5W4g90vTxxJTaHa4Z1EtHOJl78A8Q3zDyLyvX3zvGWi1r683lZBh4H9FWCubjBWJGSDpMFZ42LSR9wKas8 + bttKJM5ACvU28Pxexr55O0WcBAi0walF4ORhwFOuFS25JRkskk0vAJL1ImigycBdOQpuHSnR7CDWt2BZywUisur726Ov / OAFc + lLB8S35EMCuT4qEjimAtknuxApikcQig6UWVWQu09aWb3uzg + PVQZ9Pkkw8xm7Zjtfm6jLhyK2W0uIYCjDKBc9BFotcEi / VAXkHdBteYvvmk6k8PoUY8dBWIX2 + PWTCoyNJSD04rIMJTRv + + <NUM_LIT> VjwS9A0ucoe82v8R7eBH1I6P56hNL2TcGtcoklpWBOsxU + dz7n + Xbf / BidPFkncgZqH3Ci4CEyLbBCSkr0rNhFb1y7lp9 + TUXqUcGvPx3hIjQTL31samm / pvJumx082AIBiM5hXJeg5TLtR6Zfm / CwYAB7JphvHAAaLQdSwgYywpOHxGUwgRjyI1zoB53djAGmjTOZBjTfe1prbwvrR7xty350n4JlqWBAvZm / tle + YP7nzO3 / eer0foW2zyllc9hYquLIyeVo86HNoRbf / e9dNO6o2gzGwSYOZxpRn + + v4Ib5lo8jFi53lPAWFEhn1G9DOXhetI4EpisM17YJ5hq9DLaeY9x2ojB6kJMMogh7t8kJdF1LR0u + pbF7cWYVj7FrYn2MsuNa0cz / <NUM_LIT> S8EOSTWLYG6iAimQdfMlc + + JK55qndXBYmgQKVcxof30TPfOJMddma0tKqPPQLzLx6T9XcPFvnz1Va4oFsv2YuUCjnCblQxUoGgFBMcnBtd0kZFaVQbzFePAC8NeNiUcAng1NHgJOHBL4y3XqhuIy3WBYUJ8smwCKDWxyXLk4pu15dWvQw6VZp469lkTG / LQ2 / <NUM_LIT> HCEmoLa6g37t4 / bMtZxiWVvoA4T1erqux4PH3nsDbO + zYauvzj42w + e5l1PRO1Br + <NUM_LIT> XRa3dPm + yRlsnquaCjrgEDyGfURgragTa3beJvs9YvKvDjNcmgNcmgU7Cv5xQYGwcEeQ8S0sIA // <NUM_LIT> HyHEK5qReZj4pS / uneYEypH15BtBld6 / <NUM_LIT> UWFnt3j9QB0rSFwNMCdUs74g3us7pbZfeAgVNEQy + x1z1M73iACBHuJ + CG1SPZt47RJe8bUgNN4J + fi16YbeKMp16foY + eld / <NUM_LIT> bNzx228eaQQEVVtm8 / sq / BXp5s4wbAtKBAB5bxGKW / rlUmHs2sWePEAUOv07vVyBtg0EqEUWt + ltXpZe / TFsYLf1Y + tNDsfb7bM1o7BOjfzM + HneqJcQI / hkMica0UNX3l3lof0rXGjBUQkmKp2LjNGboiYV / Tm0rgMe3wEOxUPiYg3wTNQjyml / nLVcPD4MbzUfcWSkuWPd2R8GRMR + ErhlHJwYaXe + rdahz8pRyZce1yCiHgo9L6zYczfdHKZbilnpWa1fwhTVYNfTHZQqVsG0EwdeOQN4KndCrU2IFDIacE544wLVjFKAUFrVEJPXT1e9M5NGicAFDP + v6ih4Ox8qL / uE3ViRuUC44RQPMlNuiUbDXDo0feymcxZY8P + tc444 / W3x4aCOwMJfiPUuE0pqbmaqnO5dmsey3TGde74jbc84I9Wl8IL303GCaQetAtmzv7wVZ7YNYf89jdn6KoPlFAKOgIFFHy9bSjnX6WUembQ6 + wXGiKnzNX4q3vmOp / qGNv / KiJogbBjErZPVxSUYqwvMk4tCTwwiCDa198taO / afP5XC7u1WnxOvd2 + q9HB + <NUM_LIT> ebbavKAg01JO + p75ULgb / czjrn67ziVG7dVNk5LNCKp4ZHaelHENJYZ6IbqfGzNbVq1cvuSJfP / Cu9wx9RFERQhGBUgRmF + coqnbo4v2V1hPzzc63mHntoBfaD2SJfr6qoD999orwt0dzaru2LgfNKCbOA1iTN7h4bYTTygYeCQJfby8N6c0ri8FnD8c4ASAM1bOlQnjRSMG7PPQx3VMPYpAIPFK7fKU / t2IkvOBwjRMAyjm1c0Up + <NUM_LIT> ee0ucp0ENdPpIARGIU0T1BxKevKWVufrcaJ5AaKACgXucTqvVoqw / <NUM_LIT> RBhZjxC6xAlZDqoY6PmGfH6y2nmp3oxuYOb8oNfdD / g + bVs / <NUM_LIT> p2 / rkRXDGcwoSRCKQu8d1WEc1YY5DyBTzSVzagrx4r + e3LB4RuRAxGZbODdPVoIzyxk9X2 + AmvCvK + <NUM_LIT> LdSe3TReCr99tCWOFSPhs6vL4e94Ch9RCs8BtI2Uft + acuYLg5TL7BeW9RZXRDIzjc4X221zrbAqRqLwxJ6ODIdCZ4xpCFmhMAFBmIVUnCYUllzgvVXIeTdoovsHqYjfT8zN8eh0u3OjIrnC1 / Ahwhnfu7eU19erPvY / tpkv7DQab + bz + b5qHz / <NUM_LIT> MPe5s2b + XisZx4tlq2Bttvt8yot / k6rI6dCAKVAAgWOlfxsPY + FoAlkwAJRRHHSkISUncdTCOmBfMa / <NUM_LIT> N06me1QmKw0Txfmv8jlvG / kg + C4nDy9XLBsDVREvFrTfL7Rjm7qRLLKtrZosLDomPYnQkKxsbKIKLJtxWARInQ8z / t7PeRtKfdBcTBFikNh2Rqog4gMz9X5ulanfaURyrL0ht8xEHtTWF4uKSICPC2PZYn + rFAI / <NUM_LIT> kdVMcn1j2SSIimivl9bXFMNyU8ekBRWDbgCzxaB8FiZWRA08OZn267K6vhe9PjTNFigGg3uaLJirNx / dMNXjPdIP3Trdk / <NUM_LIT> QjqtQ635yfn1856PWlSLHsISJ6rh5dOjHb3j1Zi56rt9sXDXpNKVKkWARmzoqIP + h1pEiRIkWKFClSpEiRIkWKFClSpEiRIkWKFClSpEiRIkWKFClSpEiRIkWKFClSpDgu8X + fjdb1aQwPygAAAABJRU5ErkJggg == ` , <EOL> } <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> x : <NUM_LIT> - <NUM_LIT> , <EOL> y : <NUM_LIT> - <NUM_LIT> , <EOL> w : <NUM_LIT> , <EOL> h : <NUM_LIT> , <EOL> type : '<STR_LIT>' , <EOL> desc : { <EOL> svg : '<STR_LIT>' , <EOL> } <EOL> } ] <EOL> } ; <EOL> export function getData ( ) { <EOL> return data ; <EOL> } </s>
<s> import { <EOL> ComponentFixture , <EOL> TestBed <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MatomoModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MediaComponent <EOL> } from '<STR_LIT>' ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> let component ; <EOL> let fixture ; <EOL> beforeEach ( async ( ) = > { <EOL> await TestBed . configureTestingModule ( { <EOL> imports : [ MatomoModule . forRoot ( { } ) ] , <EOL> declarations : [ MediaComponent ] , <EOL> } ) . compileComponents ( ) ; <EOL> } ) ; <EOL> beforeEach ( ( ) = > { <EOL> fixture = TestBed . createComponent ( MediaComponent ) ; <EOL> component = fixture . componentInstance ; <EOL> fixture . detectChanges ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> expect ( component ) . toBeTruthy ( ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> IAggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseParamType <EOL> } from '<STR_LIT>' ; <EOL> export class JsonParamType extends BaseParamType { <EOL> constructor ( config ) { <EOL> super ( config ) ; <EOL> this . name = config . name | | '<STR_LIT>' ; <EOL> if ( ! config . write ) { <EOL> this . write = ( aggConfig , output ) = > { <EOL> let paramJson ; <EOL> const param = aggConfig . params [ this . name ] ; <EOL> if ( ! param ) { <EOL> return ; <EOL> } <EOL> try { <EOL> paramJson = JSON . parse ( param ) ; <EOL> } catch ( err ) { <EOL> return ; <EOL> } <EOL> function filteredCombine ( srcA , srcB ) { <EOL> function mergeObjs ( a , b ) { <EOL> return _ ( a ) . keys ( ) . union ( _ . keys ( b ) ) . transform ( function ( dest , key ) { <EOL> const val = compare ( a [ key ] , b [ key ] ) ; <EOL> if ( val != = undefined ) dest [ key ] = val ; <EOL> } , { } ) . value ( ) ; <EOL> } <EOL> function mergeArrays ( a , b ) { <EOL> return _ . times ( Math . max ( a . length , b . length ) , function ( i ) { <EOL> return compare ( a [ i ] , b [ i ] ) ; <EOL> } ) ; <EOL> } <EOL> function compare ( a , b ) { <EOL> if ( _ . isPlainObject ( a ) & & _ . isPlainObject ( b ) ) return mergeObjs ( a , b ) ; <EOL> if ( Array . isArray ( a ) & & Array . isArray ( b ) ) return mergeArrays ( a , b ) ; <EOL> if ( b == = null ) return undefined ; <EOL> if ( b != = undefined ) return b ; <EOL> return a ; <EOL> } <EOL> return compare ( srcA , srcB ) ; <EOL> } <EOL> output . params = filteredCombine ( output . params , paramJson ) ; <EOL> return ; <EOL> } ; <EOL> } <EOL> } <EOL> } </s>
<s> import { <EOL> Diagnostic , <EOL> DiagnosticSeverity , <EOL> languages , <EOL> Range , <EOL> window , <EOL> workspace <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> Processor <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> TextDocument , <EOL> TextLine , <EOL> DiagnosticCollection <EOL> } from '<STR_LIT>' ; <EOL> export default class Diagnostics { <EOL> processor   ? : Processor ; <EOL> collection : DiagnosticCollection ; <EOL> constructor ( processor   ? ) { <EOL> this . processor = processor ; <EOL> this . collection = languages . createDiagnosticCollection ( '<STR_LIT>' ) ; <EOL> } <EOL> register ( ) { <EOL> if ( this . processor ) { <EOL> if ( window . activeTextEditor ) this . update ( window . activeTextEditor . document ) ; <EOL> return [ this . collection , window . onDidChangeActiveTextEditor ( editor = > { <EOL> if ( editor ) this . update ( editor . document ) ; <EOL> } ) , workspace . onDidChangeTextDocument ( editor = > this . update ( editor . document ) ) , workspace . onDidCloseTextDocument ( doc = > this . collection . delete ( doc . uri ) ) , ] ; <EOL> } <EOL> return [ ] ; <EOL> } <EOL> update ( doc ) { <EOL> const diagnostics = [ ] ; <EOL> for ( let lineIndex = <NUM_LIT> ; lineIndex < doc . lineCount ; lineIndex + + ) { <EOL> const lineOfText = doc . lineAt ( lineIndex ) ; <EOL> const seperator = '<STR_LIT>' ; <EOL> if ( lineOfText . text . includes ( seperator ) ) { <EOL> const diag = _createDiagnostic ( doc , lineOfText , lineIndex , seperator , DiagnosticSeverity . Error , '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> if ( diag != = undefined ) { <EOL> diagnostics . push ( diag ) ; <EOL> } <EOL> } else { <EOL> const match = lineOfText . text . match ( / ( ? <= [ ^ / * ] \ s @ apply \ s * ) \ S ( . * ) ( ? = \ s * ; ) / ) ; <EOL> if ( match & & match . index & & this . processor ) { <EOL> const utilities = match [ <NUM_LIT> ] . replace ( / ! important $ / , '<STR_LIT>' ) ; <EOL> for ( const utility of this . processor . validate ( utilities ) . ignored ) { <EOL> const range = new Range ( lineIndex , match . index + utility . start , lineIndex , match . index + utility . end ) ; <EOL> const diagnostic = new Diagnostic ( range ,   ` $ { utility . className } is not valid windi css class ` , DiagnosticSeverity . Error ) ; <EOL> diagnostic . code = '<STR_LIT>' ; <EOL> diagnostics . push ( diagnostic ) ; <EOL> } <EOL> } <EOL> } <EOL> } <EOL> this . collection . set ( doc . uri , diagnostics ) ; <EOL> } <EOL> } <EOL> function _createDiagnostic ( doc , lineOfText , lineIndex , word , severity , description , code ) { <EOL> const startIndex = lineOfText . text . indexOf ( word ) ; <EOL> const range = new Range ( lineIndex , startIndex , lineIndex , startIndex + word . length ) ; <EOL> const diagnostic = new Diagnostic ( range , description , severity ) ; <EOL> diagnostic . code = code ; <EOL> return diagnostic ; <EOL> } </s>
<s> import { <EOL> library <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> faGithub , <EOL> faMediumM <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> faPaintBrush , <EOL> faStream , <EOL> faWindowMaximize <EOL> } from '<STR_LIT>' ; <EOL> export function fontawesomeImports ( ) { <EOL> library . add ( faStream , faPaintBrush , faWindowMaximize , faGithub , faMediumM ) ; <EOL> } </s>
<s> import { <EOL> Ipv4Address <EOL> } from '<STR_LIT>' ; <EOL> const NUM_BITS = <NUM_LIT> ; <EOL> function throwError ( mask ) { <EOL> throw Error ( '<STR_LIT>' + mask ) ; <EOL> } <EOL> export class CidrMask { <EOL> public readonly initialAddress : Ipv4Address ; <EOL> public readonly prefixLength : number ; <EOL> constructor ( mask ) { <EOL> const splits = mask . split ( '<STR_LIT>' ) ; <EOL> if ( splits . length != = <NUM_LIT> ) { <EOL> throwError ( mask ) ; <EOL> } <EOL> this . initialAddress = new Ipv4Address ( splits [ <NUM_LIT> ] ) ; <EOL> this . prefixLength = Number ( splits [ <NUM_LIT> ] ) ; <EOL> if ( isNaN ( this . prefixLength ) | | this . prefixLength < <NUM_LIT> | | this . prefixLength > NUM_BITS ) { <EOL> throwError ( mask ) ; <EOL> } <EOL> } <EOL> public getRange ( ) { <EOL> const variableBits = NUM_BITS - this . prefixLength ; <EOL> const fromAddress = ( ( this . initialAddress . valueOf ( ) >> variableBits ) << variableBits ) >> > <NUM_LIT> ; <EOL> const numAddresses = Math . pow ( <NUM_LIT> , variableBits ) ; <EOL> return { <EOL> from : new Ipv4Address ( fromAddress ) . toString ( ) , <EOL> to : new Ipv4Address ( fromAddress + numAddresses - <NUM_LIT> ) . toString ( ) , <EOL> } ; <EOL> } <EOL> public toString ( ) { <EOL> return this . initialAddress . toString ( ) + '<STR_LIT>' + this . prefixLength ; <EOL> } <EOL> } </s>
<s> import { <EOL> TypeElementAttrs <EOL> } from '<STR_LIT>' ; <EOL> import is from '<STR_LIT>' ; <EOL> function attrs ( attrs ) { <EOL> const { <EOL> x , <EOL> y , <EOL> w , <EOL> h , <EOL> angle <EOL> } = attrs ; <EOL> if ( ! ( is . x ( x ) & & is . y ( y ) & & is . w ( w ) & & is . h ( h ) & & is . angle ( angle ) ) ) { <EOL> return false ; <EOL> } <EOL> if ( ! ( angle >= - <NUM_LIT> & & angle <= <NUM_LIT> ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> function box ( desc = { } ) { <EOL> const { <EOL> borderColor , <EOL> borderRadius , <EOL> borderWidth <EOL> } = desc ; <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . color ( borderColor ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . number ( borderRadius ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . number ( borderWidth ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> function rectDesc ( desc ) { <EOL> const { <EOL> bgColor <EOL> } = desc ; <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . color ( bgColor ) ) { <EOL> return false ; <EOL> } <EOL> if ( ! box ( desc ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> function circleDesc ( desc ) { <EOL> const { <EOL> bgColor , <EOL> borderColor , <EOL> borderWidth <EOL> } = desc ; <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . color ( bgColor ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . color ( borderColor ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . number ( borderWidth ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> function imageDesc ( desc ) { <EOL> const { <EOL> src <EOL> } = desc ; <EOL> if ( ! is . imageSrc ( src ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> function svgDesc ( desc ) { <EOL> const { <EOL> svg <EOL> } = desc ; <EOL> if ( ! is . svg ( svg ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> function htmlDesc ( desc ) { <EOL> const { <EOL> html <EOL> } = desc ; <EOL> if ( ! is . html ( html ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> function textDesc ( desc ) { <EOL> const { <EOL> text , <EOL> color , <EOL> fontSize , <EOL> lineHeight , <EOL> fontFamily , <EOL> textAlign , <EOL> fontWeight , <EOL> bgColor , <EOL> strokeWidth , <EOL> strokeColor <EOL> } = desc ; <EOL> if ( ! is . text ( text ) ) { <EOL> return false ; <EOL> } <EOL> if ( ! is . color ( color ) ) { <EOL> return false ; <EOL> } <EOL> if ( ! is . fontSize ( fontSize ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . color ( bgColor ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . fontWeight ( fontWeight ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . lineHeight ( lineHeight ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . fontFamily ( fontFamily ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . textAlign ( textAlign ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . strokeWidth ( strokeWidth ) ) { <EOL> return false ; <EOL> } <EOL> if ( desc . hasOwnProperty ( '<STR_LIT>' ) & &   ! is . color ( strokeColor ) ) { <EOL> return false ; <EOL> } <EOL> if ( ! box ( desc ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> const check = { <EOL> attrs , <EOL> textDesc , <EOL> rectDesc , <EOL> circleDesc , <EOL> imageDesc , <EOL> svgDesc , <EOL> htmlDesc , <EOL> } ; <EOL> type TypeCheck = { <EOL> attrs : ( value : any ) = > boolean ; rectDesc : ( value : any ) = > boolean ; circleDesc : ( value : any ) = > boolean ; imageDesc : ( value : any ) = > boolean ; svgDesc : ( value : any ) = > boolean ; htmlDesc : ( value : any ) = > boolean ; textDesc : ( value : any ) = > boolean ; <EOL> } ; <EOL> export { <EOL> TypeCheck <EOL> } ; <EOL> export default check ; </s>
<s> import { <EOL> SavedObjectsClientContract , <EOL> SimpleSavedObject <EOL> } from '<STR_LIT>' ; <EOL> export async function getTitle ( client , indexPatternId ) { <EOL> const savedObject = ( await client . get ( '<STR_LIT>' , indexPatternId ) ) as SimpleSavedObject < any > ; <EOL> if ( savedObject . error ) { <EOL> throw new Error ( ` Unable to get index - pattern title :   $ { savedObject . error . message } ` ) ; <EOL> } <EOL> return savedObject . attributes . title ; <EOL> } </s>
<s> import { <EOL> useEffect , <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Task <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> api <EOL> } from '<STR_LIT>' ; <EOL> export function useTask ( taskId ) { <EOL> const [ task , setTask ] = useState < Task | null > ( null ) ; <EOL> return [ task , setTask ] as <EOL> const ; <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> type Props = { <EOL> as   ? : string | React . ElementType ; size   ? : number ; className   ? : string ; <EOL> } ; <EOL> export const Centered = ( { <EOL> as : Component = '<STR_LIT>' , <EOL> size = <NUM_LIT> , <EOL> children , <EOL> ... rest <EOL> } ) = > { <EOL> return ( < Component style = { <EOL> { <EOL> margin :   ` <NUM_LIT> auto ` , <EOL> maxWidth :   ` $ { size } rem ` , <EOL> } <EOL> } { <EOL> ... rest <EOL> } > { <EOL> children <EOL> } < / Component > ) ; } ; </s>
<s> import { <EOL> get , <EOL> isUndefined <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getPhraseScript <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getFields <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getTimeZoneFromSettings <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getFullFieldNameNode <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> KueryNode , <EOL> IFieldType <EOL> } from '<STR_LIT>' ; <EOL> import * as ast from '<STR_LIT>' ; <EOL> import * as literal from '<STR_LIT>' ; <EOL> import * as wildcard from '<STR_LIT>' ; <EOL> export function buildNodeParams ( fieldName , value , isPhrase = false ) { <EOL> if ( isUndefined ( fieldName ) ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> if ( isUndefined ( value ) ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> const fieldNode = typeof fieldName == = '<STR_LIT>'   ? ast . fromLiteralExpression ( fieldName ) : literal . buildNode ( fieldName ) ; <EOL> const valueNode = typeof value == = '<STR_LIT>'   ? ast . fromLiteralExpression ( value ) : literal . buildNode ( value ) ; <EOL> const isPhraseNode = literal . buildNode ( isPhrase ) ; <EOL> return { <EOL> arguments : [ fieldNode , valueNode , isPhraseNode ] , <EOL> } ; <EOL> } <EOL> export function toOpenSearchQuery ( node , indexPattern   ? , config = { } , context = { } ) { <EOL> const { <EOL> arguments : [ fieldNameArg , valueArg , isPhraseArg ] , <EOL> } = node ; <EOL> const fullFieldNameArg = getFullFieldNameNode ( fieldNameArg , indexPattern , context ? . nested   ? context . nested . path : undefined ) ; <EOL> const fieldName = ast . toOpenSearchQuery ( fullFieldNameArg ) ; <EOL> const value =   ! isUndefined ( valueArg )   ? ast . toOpenSearchQuery ( valueArg ) : valueArg ; <EOL> const type = isPhraseArg . value   ? '<STR_LIT>' : '<STR_LIT>' ; <EOL> if ( fullFieldNameArg . value == = null ) { <EOL> if ( valueArg . type == = '<STR_LIT>' ) { <EOL> return { <EOL> query_string : { <EOL> query : wildcard . toQueryStringQuery ( valueArg ) , <EOL> } , <EOL> } ; <EOL> } <EOL> return { <EOL> multi_match : { <EOL> type , <EOL> query : value , <EOL> lenient : true , <EOL> } , <EOL> } ; <EOL> } <EOL> const fields = indexPattern   ? getFields ( fullFieldNameArg , indexPattern ) : [ ] ; <EOL> if ( fields & & fields . length == = <NUM_LIT> ) { <EOL> fields . push ( { <EOL> name : ( ast . toOpenSearchQuery ( fullFieldNameArg ) as unknown ) as string , <EOL> scripted : false , <EOL> type : '<STR_LIT>' , <EOL> } ) ; <EOL> } <EOL> const isExistsQuery = valueArg . type == = '<STR_LIT>' & & ( value as any ) == = '<STR_LIT>' ; <EOL> const isAllFieldsQuery = ( fullFieldNameArg . type == = '<STR_LIT>' & & ( ( fieldName as unknown ) as string ) == = '<STR_LIT>' ) | | ( fields & & indexPattern & & fields . length == = indexPattern . fields . length ) ; <EOL> const isMatchAllQuery = isExistsQuery & & isAllFieldsQuery ; <EOL> if ( isMatchAllQuery ) { <EOL> return { <EOL> match_all : { } <EOL> } ; <EOL> } <EOL> const queries = fields ! . reduce ( ( accumulator , field ) = > { <EOL> const wrapWithNestedQuery = ( query ) = > { <EOL> if ( ! ( fullFieldNameArg . type == = '<STR_LIT>' ) | |   ! get ( field , '<STR_LIT>' ) | | context ? . nested ) { <EOL> return query ; <EOL> } else { <EOL> return { <EOL> nested : { <EOL> path : field . subType ! . nested ! . path , <EOL> query , <EOL> score_mode : '<STR_LIT>' , <EOL> } , <EOL> } ; <EOL> } <EOL> } ; <EOL> if ( field . scripted ) { <EOL> if ( ! isExistsQuery ) { <EOL> return [ ... accumulator , { <EOL> script : { <EOL> ... getPhraseScript ( field , value as any ) , <EOL> } , <EOL> } , ] ; <EOL> } <EOL> } else if ( isExistsQuery ) { <EOL> return [ ... accumulator , wrapWithNestedQuery ( { <EOL> exists : { <EOL> field : field . name , <EOL> } , <EOL> } ) , ] ; <EOL> } else if ( valueArg . type == = '<STR_LIT>' ) { <EOL> return [ ... accumulator , wrapWithNestedQuery ( { <EOL> query_string : { <EOL> fields : [ field . name ] , <EOL> query : wildcard . toQueryStringQuery ( valueArg ) , <EOL> } , <EOL> } ) , ] ; <EOL> } else if ( field . type == = '<STR_LIT>' ) { <EOL> const timeZoneParam = config . dateFormatTZ   ? { <EOL> time_zone : getTimeZoneFromSettings ( config ! . dateFormatTZ ) <EOL> } : { } ; <EOL> return [ ... accumulator , wrapWithNestedQuery ( { <EOL> range : { <EOL> [ field . name ] : { <EOL> gte : value , <EOL> lte : value , <EOL> ... timeZoneParam , <EOL> } , <EOL> } , <EOL> } ) , ] ; <EOL> } else { <EOL> const queryType = type == = '<STR_LIT>'   ? '<STR_LIT>' : '<STR_LIT>' ; <EOL> return [ ... accumulator , wrapWithNestedQuery ( { <EOL> [ queryType ] : { <EOL> [ field . name ] : value , <EOL> } , <EOL> } ) , ] ; <EOL> } <EOL> } , [ ] ) ; <EOL> return { <EOL> bool : { <EOL> should : queries | | [ ] , <EOL> minimum_should_match : <NUM_LIT> , <EOL> } , <EOL> } ; <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parentPipelineAggHelper <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> makeNestedLabel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggConfigSerialized , <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsMovingAvg extends BaseAggParams { <EOL> buckets_path : string ; window   ? : number ; script   ? : string ; customMetric   ? : AggConfigSerialized ; metricAgg   ? : string ; <EOL> } <EOL> const movingAvgTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const movingAvgLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export const getMovingAvgMetricAgg = ( ) = > { <EOL> const { <EOL> subtype , <EOL> params , <EOL> getSerializedFormat <EOL> } = parentPipelineAggHelper ; <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . MOVING_FN , <EOL> dslName : '<STR_LIT>' , <EOL> title : movingAvgTitle , <EOL> makeLabel : ( agg ) = > makeNestedLabel ( agg , movingAvgLabel ) , <EOL> subtype , <EOL> getSerializedFormat , <EOL> params : [ ... params ( ) , { <EOL> name : '<STR_LIT>' , <EOL> default : <NUM_LIT> , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> default : '<STR_LIT>' , <EOL> } , ] , <EOL> getValue ( agg , bucket ) { <EOL> / ** <EOL> * The previous implementation using   ` moving_avg ` did not <EOL> * return any bucket in case there are no documents or empty window . <EOL> * The   ` moving_fn ` aggregation returns buckets with the value null if the <EOL> * window is empty or doesn ' t return any value if the sibiling metric <EOL> * is null . Since our generic MetricAggType . getValue implementation <EOL> * would return the value <NUM_LIT> for null buckets , we need a specific <EOL> * implementation here , that preserves the null value . <EOL> * / <EOL> return bucket [ agg . id ]   ? bucket [ agg . id ] . value : null ; <EOL> } , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> buildRangeFilter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggTypesDependencies <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IBucketAggConfig <EOL> } from '<STR_LIT>' ; <EOL> internal <EOL> export const createFilterRange = ( getFieldFormatsStart ) = > { <EOL> return ( aggConfig , params ) = > { <EOL> const { <EOL> deserialize <EOL> } = getFieldFormatsStart ( ) ; <EOL> return buildRangeFilter ( aggConfig . params . field , params , aggConfig . getIndexPattern ( ) , deserialize ( aggConfig . toSerializedFieldFormat ( ) ) . convert ( params ) ) ; <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> is <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseElement <EOL> } from '<STR_LIT>' ; <EOL> import BaseRenderer from '<STR_LIT>' ; <EOL> import inherits from '<STR_LIT>' ; <EOL> import { <EOL> append as svgAppend , <EOL> create as svgCreate <EOL> } from '<STR_LIT>' ; <EOL> import Robot from '<STR_LIT>' ; <EOL> class RobotTaskRenderer { <EOL>         $ inject : string [ ] ; eventBus : any ; bpmnRenderer : any ; constructor ( eventBus , bpmnRenderer ) { <EOL> this . $ inject = [ ] ; <EOL> this . eventBus = eventBus ; <EOL> this . bpmnRenderer = bpmnRenderer ; <EOL> BaseRenderer . call ( this , eventBus , <NUM_LIT> ) ; <EOL> } <EOL> canRender ( element ) { <EOL> return is ( element , '<STR_LIT>' ) & & element . id . match ( / robot / i ) ; <EOL> } <EOL> drawShape ( parent , element ) { <EOL> this . bpmnRenderer . handlers [ '<STR_LIT>' ] ( parent , element ) ; <EOL> const gfx = svgCreate ( '<STR_LIT>' , { <EOL> x : - <NUM_LIT> , <EOL> y : - <NUM_LIT> , <EOL> width : <NUM_LIT> , <EOL> height : <NUM_LIT> , <EOL> href : Robot , <EOL> } ) ; <EOL> svgAppend ( parent , gfx ) ; <EOL> return gfx ; <EOL> } <EOL> } <EOL> const factory = ( eventBus , bpmnRenderer ) = > { <EOL> const instance = new RobotTaskRenderer ( eventBus , bpmnRenderer ) ; <EOL> inherits ( instance , BaseRenderer ) ; <EOL> instance . $ inject = [ '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> return instance ; <EOL> } ; <EOL> export default factory ; </s>
<s> import { <EOL> constant , <EOL> noop , <EOL> identity <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ISearchSource <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SerializedFieldFormat <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> RequestAdapter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> initParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IAggConfigs <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseParamType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggParamType <EOL> } from '<STR_LIT>' ; <EOL> export interface AggTypeConfig < TAggConfig extends AggConfig = AggConfig , TParam extends AggParamType < TAggConfig > = AggParamType < TAggConfig > > { <EOL> name : string ; title : string ; createFilter   ? : ( aggConfig : TAggConfig , key : any , params   ? : any ) = > any ; type   ? : string ; dslName   ? : string ; expressionName   ? : string ; makeLabel   ? : ( ( aggConfig : TAggConfig ) = > string ) | ( ( ) = > string ) ; ordered   ? : any ; hasNoDsl   ? : boolean ; params   ? : Array < Partial < TParam > > ; getRequestAggs   ? : ( ( aggConfig : TAggConfig ) = > TAggConfig [ ] ) | ( ( ) = > TAggConfig [ ] | void ) ; getResponseAggs   ? : ( ( aggConfig : TAggConfig ) = > TAggConfig [ ] ) | ( ( ) = > TAggConfig [ ] | void ) ; customLabels   ? : boolean ; json   ? : boolean ; decorateAggConfig   ? : ( ) = > any ; postFlightRequest   ? : ( resp : any , aggConfigs : IAggConfigs , aggConfig : TAggConfig , searchSource : ISearchSource , inspectorRequestAdapter : RequestAdapter , abortSignal   ? : AbortSignal ) = > Promise < any > ; getSerializedFormat   ? : ( agg : TAggConfig ) = > SerializedFieldFormat ; getValue   ? : ( agg : TAggConfig , bucket : any ) = > any ; getKey   ? : ( bucket : any , key : any , agg : TAggConfig ) = > any ; <EOL> } <EOL> export type IAggType = AggType ; <EOL> export class AggType < TAggConfig extends AggConfig = AggConfig , TParam extends AggParamType < TAggConfig > = AggParamType < TAggConfig > > { <EOL> property type { <EOL> string <EOL> } <EOL> name : string ; type : string ; subtype   ? : string ; property type { <EOL> string <EOL> } <EOL> dslName : string ; property type { <EOL> string <EOL> } <EOL> expressionName   ? : string ; property type { <EOL> string <EOL> } <EOL> title : string ; method param { <EOL> AggConfig <EOL> } <EOL> aggConfig returns { <EOL> string <EOL> } <EOL> makeLabel : ( ( aggConfig : TAggConfig ) = > string ) | ( ( ) = > string ) ; property type { <EOL> object | undefined <EOL> } <EOL> ordered : any ; type { <EOL> Boolean <EOL> } <EOL> hasNoDsl : boolean ; param { <EOL> object <EOL> } <EOL> aggConfig param { <EOL> mixed <EOL> } <EOL> key returns { <EOL> object <EOL> } <EOL> createFilter : ( ( aggConfig : TAggConfig , key : any , params   ? : any ) = > any ) | undefined ; property type { <EOL> AggParams <EOL> } <EOL> params : TParam [ ] ; method returns { <EOL> array [ AggConfig ] <EOL> } <EOL> getRequestAggs : ( ( aggConfig : TAggConfig ) = > TAggConfig [ ] ) | ( ( ) = > TAggConfig [ ] | void ) ; method returns { <EOL> array [ AggConfig ] | undefined <EOL> } <EOL> getResponseAggs : ( ( aggConfig : TAggConfig ) = > TAggConfig [ ] ) | ( ( ) = > TAggConfig [ ] | void ) ; <EOL> / ** <EOL> * A function that will be called each time an aggConfig of this type <EOL> * is created , giving the agg type a chance to modify the agg config <EOL> * / <EOL> decorateAggConfig : ( ) = > any ; param aggConfigs param aggConfig param searchSourceAggs param resp param nestedSearchSource <EOL> return { <EOL> Promise <EOL> } <EOL> postFlightRequest : ( resp : any , aggConfigs : IAggConfigs , aggConfig : TAggConfig , searchSource : ISearchSource , inspectorRequestAdapter : RequestAdapter , abortSignal   ? : AbortSignal ) = > Promise < any > ; param { <EOL> agg <EOL> } <EOL> agg <EOL> return { <EOL> SerializedFieldFormat <EOL> } <EOL> getSerializedFormat : ( agg : TAggConfig ) = > SerializedFieldFormat ; getValue : ( agg : TAggConfig , bucket : any ) = > any ; getKey   ? : ( bucket : any , key : any , agg : TAggConfig ) = > any ; paramByName = ( name ) = > { <EOL> return this . params . find ( ( p ) = > p . name == = name ) ; <EOL> } ; class private param { <EOL> object <EOL> } <EOL> config constructor ( config ) { <EOL> this . name = config . name ; <EOL> this . type = config . type | | '<STR_LIT>' ; <EOL> this . dslName = config . dslName | | config . name ; <EOL> this . expressionName = config . expressionName ; <EOL> this . title = config . title ; <EOL> this . makeLabel = config . makeLabel | | constant ( this . name ) ; <EOL> this . ordered = config . ordered ; <EOL> this . hasNoDsl =   ! ! config . hasNoDsl ; <EOL> if ( config . createFilter ) { <EOL> this . createFilter = config . createFilter ; <EOL> } <EOL> if ( config . params & & config . params . length & & config . params [ <NUM_LIT> ] instanceof BaseParamType ) { <EOL> this . params = config . params as TParam [ ] ; <EOL> } else { <EOL> const params = config . params   ? [ ... config . params ] : [ ] ; <EOL> if ( config . json != = false ) { <EOL> params . push ( { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> advanced : true , <EOL> } ) ; <EOL> } <EOL> if ( config . customLabels != = false ) { <EOL> params . push ( { <EOL> name : '<STR_LIT>' , <EOL> displayName : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> write : noop , <EOL> } ) ; <EOL> } <EOL> this . params = initParams ( params ) ; <EOL> } <EOL> this . getRequestAggs = config . getRequestAggs | | noop ; <EOL> this . getResponseAggs = config . getResponseAggs | | ( ( ) = > { } ) ; <EOL> this . decorateAggConfig = config . decorateAggConfig | | ( ( ) = > ( { } ) ) ; <EOL> this . postFlightRequest = config . postFlightRequest | | identity ; <EOL> this . getSerializedFormat = config . getSerializedFormat | | ( ( agg ) = > { <EOL> return agg . params . field   ? agg . aggConfigs . indexPattern . getFormatterForField ( agg . params . field ) . toJSON ( ) : { } ; <EOL> } ) ; <EOL> this . getValue = config . getValue | | ( ( agg , bucket ) = > { } ) ; <EOL> } <EOL> } </s>
<s> const namesParts = < const > [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" ] ; export const toFullyQualifiedName = ( namePart ) = >   ` [ [ $ { namePart } ] ] ` ; type FullyQualifiedName < N extends string > =   ` [ [ $ { N } ] ] ` ; type valuesOf < T extends readonly string [ ] > = T [ number ] ; export const intrinsic = namesParts . reduce ( ( names , namePart ) = > ( ( names [ namePart ] = toFullyQualifiedName ( namePart ) ) , names ) , { } as { [ key in valuesOf < typeof namesParts > ] : FullyQualifiedName < key > ; } ) ; </s>
<s> import { <EOL> groupBy , <EOL> has <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> buildQueryFromKuery <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> buildQueryFromFilters <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> buildQueryFromLucene <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Query <EOL> } from '<STR_LIT>' ; <EOL> export interface OpenSearchQueryConfig { <EOL> allowLeadingWildcards : boolean ; queryStringOptions : Record < string , <EOL> any > ; ignoreFilterIfFieldNotInIndex : boolean ; dateFormatTZ   ? : string ; <EOL> } <EOL> param indexPattern param queries param filters param config <EOL> export function buildOpenSearchQuery ( indexPattern , queries , filters , config = { <EOL> allowLeadingWildcards : false , <EOL> queryStringOptions : { } , <EOL> ignoreFilterIfFieldNotInIndex : false , <EOL> } ) { <EOL> queries = Array . isArray ( queries )   ? queries : [ queries ] ; <EOL> filters = Array . isArray ( filters )   ? filters : [ filters ] ; <EOL> const validQueries = queries . filter ( ( query ) = > has ( query , '<STR_LIT>' ) ) ; <EOL> const queriesByLanguage = groupBy ( validQueries , '<STR_LIT>' ) ; <EOL> const kueryQuery = buildQueryFromKuery ( indexPattern , queriesByLanguage . kuery , config . allowLeadingWildcards , config . dateFormatTZ ) ; <EOL> const luceneQuery = buildQueryFromLucene ( queriesByLanguage . lucene , config . queryStringOptions , config . dateFormatTZ ) ; <EOL> const filterQuery = buildQueryFromFilters ( filters , indexPattern , config . ignoreFilterIfFieldNotInIndex ) ; <EOL> return { <EOL> bool : { <EOL> must : [ ... kueryQuery . must , ... luceneQuery . must , ... filterQuery . must ] , <EOL> filter : [ ... kueryQuery . filter , ... luceneQuery . filter , ... filterQuery . filter ] , <EOL> should : [ ... kueryQuery . should , ... luceneQuery . should , ... filterQuery . should ] , <EOL> must_not : [ ... kueryQuery . must_not , ... luceneQuery . must_not , ... filterQuery . must_not ] , <EOL> } , <EOL> } ; <EOL> } </s>
<s> import { <EOL> Component , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SettingsFacade <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Observable , <EOL> zip <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormGroup <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SettingModel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CommonSettingsService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UntilDestroy , <EOL> untilDestroyed <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SnackbarService <EOL> } from '<STR_LIT>' ; <EOL> @ UntilDestroy ( ) @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> providers : [ CommonSettingsService ] <EOL> } ) export class CommonSettingsComponent { <EOL> settings $ : Observable < SettingModel [ ] > ; form : FormGroup ; constructor ( private settingsFacade , private formService , private snackbarService ) { <EOL> this . settings $ = this . settingsFacade . settingModelCollection $ ; <EOL> this . settingsFacade . getSettingModelCollection ( ) ; <EOL> this . settings $ . pipe ( untilDestroyed ( this ) ) . subscribe ( settings = > ( this . form = this . formService . getFormGroupFromSettings ( settings ) ) ) ; <EOL> } <EOL> translate ( key ) { <EOL> return this . formService . getSettingTranslation ( key ) ; <EOL> } <EOL> submit ( ) { <EOL> const toUpdate = this . formService . getSettingsToUpdate ( this . form ) ; <EOL> if ( toUpdate . length > <NUM_LIT> ) { <EOL> this . settingsFacade . updateSettingModel ( { <EOL> patch : toUpdate <EOL> } ) . subscribe ( ( ) = > this . snackbarService . open ( '<STR_LIT>' ) , ( ) = > this . snackbarService . open ( '<STR_LIT>' ) ) ; <EOL> } <EOL> } <EOL> } </s>
<s> import { <EOL> Filter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getExistsFilterField , <EOL> isExistsFilter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getGeoBoundingBoxFilterField , <EOL> isGeoBoundingBoxFilter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getGeoPolygonFilterField , <EOL> isGeoPolygonFilter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getPhraseFilterField , <EOL> isPhraseFilter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getPhrasesFilterField , <EOL> isPhrasesFilter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getRangeFilterField , <EOL> isRangeFilter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getMissingFilterField , <EOL> isMissingFilter <EOL> } from '<STR_LIT>' ; <EOL> export const getFilterField = ( filter ) = > { <EOL> if ( isExistsFilter ( filter ) ) { <EOL> return getExistsFilterField ( filter ) ; <EOL> } <EOL> if ( isGeoBoundingBoxFilter ( filter ) ) { <EOL> return getGeoBoundingBoxFilterField ( filter ) ; <EOL> } <EOL> if ( isGeoPolygonFilter ( filter ) ) { <EOL> return getGeoPolygonFilterField ( filter ) ; <EOL> } <EOL> if ( isPhraseFilter ( filter ) ) { <EOL> return getPhraseFilterField ( filter ) ; <EOL> } <EOL> if ( isPhrasesFilter ( filter ) ) { <EOL> return getPhrasesFilterField ( filter ) ; <EOL> } <EOL> if ( isRangeFilter ( filter ) ) { <EOL> return getRangeFilterField ( filter ) ; <EOL> } <EOL> if ( isMissingFilter ( filter ) ) { <EOL> return getMissingFilterField ( filter ) ; <EOL> } <EOL> return ; <EOL> } ; </s>
<s> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter , <EOL> isExistsFilter , <EOL> FILTERS <EOL> } from '<STR_LIT>' ; <EOL> export const mapExists = ( filter ) = > { <EOL> if ( isExistsFilter ( filter ) ) { <EOL> return { <EOL> type : FILTERS . EXISTS , <EOL> value : FILTERS . EXISTS , <EOL> key : get ( filter , '<STR_LIT>' ) , <EOL> } ; <EOL> } <EOL> throw filter ; <EOL> } ; </s>
<s> import EmitterSubscriberBase from "<STR_LIT>" ; <EOL> import * as V from "<STR_LIT>" ; <EOL> import * as logger from "<STR_LIT>" ; <EOL> import * as ReVIEW from "<STR_LIT>" ; <EOL> import * as path from "<STR_LIT>" ; <EOL> import * as fs from "<STR_LIT>" ; <EOL> import * as PrhValidator from "<STR_LIT>" ; <EOL> class SingleFileAnalyzer extends ReVIEW . DefaultAnalyzer { <EOL> inline_chap ( builder ) { <EOL> this . inlineDecorationSyntax ( builder , "<STR_LIT>" ) ; <EOL> } <EOL> inline_title ( builder ) { <EOL> this . inlineDecorationSyntax ( builder , "<STR_LIT>" ) ; <EOL> } <EOL> inline_chapref ( builder ) { <EOL> this . inlineDecorationSyntax ( builder , "<STR_LIT>" ) ; <EOL> } <EOL> } <EOL> class SingleFileHTMLBuilder extends ReVIEW . HtmlBuilder { <EOL> inline_chap ( process , _node ) { <EOL> process . out ( "<STR_LIT>" ) ; <EOL> return false ; <EOL> } <EOL> inline_title ( process , _node ) { <EOL> process . out ( "<STR_LIT>" ) ; <EOL> return false ; <EOL> } <EOL> inline_chapref ( process , _node ) { <EOL> process . out ( "<STR_LIT>" ) ; <EOL> return false ; <EOL> } <EOL> } <EOL> export default class ReVIEWRunner extends EmitterSubscriberBase { <EOL> private watcher : ContentWatcher ; <EOL> editor : AtomCore . IEditor ; <EOL> lastAcceptableSyntaxes : ReVIEW . AcceptableSyntaxes ; <EOL> lastSymbols : ReVIEW . Symbol [ ] ; <EOL> lastReports : ReVIEW . ProcessReport [ ] ; <EOL> lastBook : ReVIEW . Book ; <EOL> constructor ( params ) { <EOL> super ( ) ; <EOL> this . editor = params . editor ; <EOL> if ( this . editor ) { <EOL> this . watcher = new EditorContentWatcher ( this , this . editor ) ; <EOL> } else { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> } <EOL> startWatching ( ) { <EOL> logger . log ( ) ; <EOL> this . watcher . startWatching ( ) ; <EOL> } <EOL> stopWatching ( ) { <EOL> logger . log ( ) ; <EOL> this . watcher . stopWatching ( ) ; <EOL> } <EOL> activate ( ) { <EOL> logger . log ( ) ; <EOL> this . watcher . activate ( ) ; <EOL> } <EOL> deactivate ( ) { <EOL> logger . log ( ) ; <EOL> this . watcher . deactivate ( ) ; <EOL> } <EOL> on ( eventNames , callback ) ; <EOL> on ( eventNames , callback ) ; <EOL> on ( eventNames , callback ) ; <EOL> on ( eventNames , callback ) ; <EOL> on ( eventNames , callback ) ; <EOL> on ( eventNames , callback ) ; <EOL> on ( eventNames , handler ) ; <EOL> on ( _eventNames , _handler ) { <EOL> throw new Error ( ) ; <EOL> } <EOL> doCompile ( ) { <EOL> logger . log ( ) ; <EOL> this . emit ( "<STR_LIT>" ) ; <EOL> let currentPath = this . watcher . getFilePath ( ) | | "<STR_LIT>" ; <EOL> let basePath = path . isAbsolute ( currentPath )   ? path . dirname ( currentPath ) : undefined ; <EOL> let filename = path . basename ( currentPath ) ; <EOL> setTimeout ( ( ) = > { <EOL> let files = { } ; <EOL> files [ filename ] = this . watcher . getContent ( ) ; <EOL> let result = { } ; <EOL> let validators = [ new ReVIEW . DefaultValidator ( ) , ] ; <EOL> let dirName ; <EOL> if ( this . editor ) { <EOL> dirName = this . editor . getBuffer ( ) . file . getParent ( ) . getPath ( ) ; <EOL> } <EOL> let prhFilePath = path . join ( dirName , "<STR_LIT>" ) ; <EOL> if ( fs . existsSync ( prhFilePath ) ) { <EOL> try { <EOL> validators . push ( new PrhValidator . TextValidator ( prhFilePath ) ) ; <EOL> } catch ( e ) { <EOL> atom . notifications . addWarning ( "<STR_LIT>" + e ) ; <EOL> } <EOL> } <EOL> ReVIEW . start ( review = > { <EOL> review . initConfig ( { <EOL> basePath : basePath , <EOL> read : path = > Promise . resolve ( files [ path ] ) , <EOL> write : ( path , content ) = > { <EOL> result [ path ] = content ; <EOL> return Promise . resolve < void > ( null ) ; <EOL> } , <EOL> listener : { <EOL> onAcceptables : acceptableSyntaxes = > { <EOL> logger . log ( acceptableSyntaxes ) ; <EOL> this . lastAcceptableSyntaxes = acceptableSyntaxes ; <EOL> this . emit ( "<STR_LIT>" , acceptableSyntaxes ) ; <EOL> } , <EOL> onSymbols : symbols = > { <EOL> logger . log ( symbols ) ; <EOL> this . lastSymbols = symbols ; <EOL> this . emit ( "<STR_LIT>" , symbols ) ; <EOL> } , <EOL> onReports : reports = > { <EOL> logger . log ( reports ) ; <EOL> this . lastReports = reports ; <EOL> this . emit ( "<STR_LIT>" , reports ) ; <EOL> } , <EOL> onCompileSuccess : book = > { <EOL> logger . log ( book ) ; <EOL> this . lastBook = book ; <EOL> this . emit ( "<STR_LIT>" , book ) ; <EOL> } , <EOL> onCompileFailed : book = > { <EOL> logger . log ( ) ; <EOL> this . lastBook = null ; <EOL> this . emit ( "<STR_LIT>" , book ) ; <EOL> } , <EOL> } , <EOL> analyzer : new SingleFileAnalyzer ( ) , <EOL> validators : validators , <EOL> builders : [ new SingleFileHTMLBuilder ( false ) ] , <EOL> book : { <EOL> contents : [ filename , ] , <EOL> } , <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; <EOL> } <EOL> getContent ( ) { <EOL> return this . watcher . getContent ( ) ; <EOL> } <EOL> getFilePath ( ) { <EOL> return this . watcher . getFilePath ( ) ; <EOL> } <EOL> } <EOL> ReVIEWRunner . emissarified ( ) ; <EOL> interface ContentWatcher { <EOL> startWatching ( ) : void ; <EOL> stopWatching ( ) : void ; <EOL> activate ( ) : void ; <EOL> deactivate ( ) : void ; <EOL> getContent ( ) : string ; <EOL> getFilePath ( ) : string ; <EOL> } <EOL> class EditorContentWatcher extends EmitterSubscriberBase implements ContentWatcher { <EOL> buffer : TextBuffer . ITextBuffer ; grammarChangeSubscription : AtomCore . IDisposable ; wasAlreadyActivated : boolean ; bufferSubscriptions : AtomCore . IDisposable [ ] = [ ] ; lastKeyHitTimeoutId : any ; static IN_EDIT_COMPILE_TIMEOUT : number = <NUM_LIT> ; constructor ( public runner , public editor ) { <EOL> super ( ) ; <EOL> this . buffer = this . editor . getBuffer ( ) ; <EOL> } <EOL> startWatching ( ) { <EOL> logger . log ( ) ; <EOL> if ( this . grammarChangeSubscription ) { <EOL> return ; <EOL> } <EOL> this . configureRunner ( ) ; <EOL> this . grammarChangeSubscription = this . editor . onDidChangeGrammar ( ( ) = > this . configureRunner ( ) ) ; <EOL> } <EOL> stopWatching ( ) { <EOL> logger . log ( ) ; <EOL> if ( ! this . grammarChangeSubscription ) { <EOL> return ; <EOL> } <EOL> this . grammarChangeSubscription . dispose ( ) ; <EOL> this . grammarChangeSubscription = null ; <EOL> } <EOL> configureRunner ( ) { <EOL> let scopeName = this . editor . getGrammar ( ) . scopeName ; <EOL> logger . log ( "<STR_LIT>" + scopeName ) ; <EOL> if ( V . reviewScopeName == = scopeName ) { <EOL> this . activate ( ) ; <EOL> } else { <EOL> this . deactivate ( ) ; <EOL> } <EOL> } <EOL> triggerCompile ( withDelay = false ) { <EOL> if ( this . lastKeyHitTimeoutId ) { <EOL> clearTimeout ( this . lastKeyHitTimeoutId ) ; <EOL> } <EOL> if ( withDelay ) { <EOL> this . lastKeyHitTimeoutId = setTimeout ( ( ) = > { <EOL> this . lastKeyHitTimeoutId = null ; <EOL> this . runner . doCompile ( ) ; <EOL> } , EditorContentWatcher . IN_EDIT_COMPILE_TIMEOUT ) ; <EOL> } else { <EOL> this . lastKeyHitTimeoutId = null ; <EOL> this . runner . doCompile ( ) ; <EOL> } <EOL> } <EOL> activate ( ) { <EOL> logger . log ( ) ; <EOL> if ( ! this . wasAlreadyActivated ) { <EOL> this . emit ( "<STR_LIT>" ) ; <EOL> } <EOL> this . wasAlreadyActivated = true ; <EOL> this . runner . doCompile ( ) ; <EOL> if ( this . bufferSubscriptions . length != = <NUM_LIT> ) { <EOL> return ; <EOL> } <EOL> this . bufferSubscriptions . push ( this . buffer . onDidChange ( ( ) = > this . triggerCompile ( true ) ) ) ; <EOL> this . bufferSubscriptions . push ( this . buffer . onDidSave ( ( ) = > this . triggerCompile ( ) ) ) ; <EOL> this . bufferSubscriptions . push ( this . buffer . onDidReload ( ( ) = > this . triggerCompile ( ) ) ) ; <EOL> } <EOL> deactivate ( ) { <EOL> logger . log ( ) ; <EOL> this . stopWatching ( ) ; <EOL> this . bufferSubscriptions . forEach ( subscription = > subscription . dispose ( ) ) ; <EOL> this . bufferSubscriptions = [ ] ; <EOL> this . runner . emit ( "<STR_LIT>" ) ; <EOL> } <EOL> getContent ( ) { <EOL> return this . editor . buffer . getText ( ) ; <EOL> } <EOL> getFilePath ( ) { <EOL> return this . buffer . getUri ( ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> ParameterType <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> unique <EOL> } from "<STR_LIT>" ; <EOL> const preloadParameterTypes = < const > [ ParameterType . AUDIO , ParameterType . IMAGE , ParameterType . VIDEO , ] ; type PreloadType = typeof preloadParameterTypes [ number ] ; export class MediaAPI { constructor ( private useWebaudio , private webaudioContext   ? ) { } private video_buffers = { } ; getVideoBuffer ( videoID ) { return this . video_buffers [ videoID ] ; } private context = null ; private audio_buffers = [ ] ; initAudio ( ) { this . context = this . useWebaudio   ? this . webaudioContext : null ; } audioContext ( ) { if ( this . context != = null ) { if ( this . context . state != = "<STR_LIT>" ) { this . context . resume ( ) ; } } return this . context ; } getAudioBuffer ( audioID ) { return new Promise ( ( resolve , reject ) = > { if ( typeof this . audio_buffers [ audioID ] == "<STR_LIT>" | | this . audio_buffers [ audioID ] == "<STR_LIT>" ) { this . preloadAudio ( [ audioID ] , ( ) = > { resolve ( this . audio_buffers [ audioID ] ) ; } , ( ) = > { } , ( e ) = > { reject ( e . error ) ; } ) ; } else { resolve ( this . audio_buffers [ audioID ] ) ; } } ) ; } private preload_requests = [ ] ; private img_cache = { } ; preloadAudio ( files , callback_complete = ( ) = > { } , callback_load = ( filepath ) = > { } , callback_error = ( error_msg ) = > { } ) { files = unique ( files . flat ( ) ) ; let n_loaded = <NUM_LIT> ; if ( files . length == <NUM_LIT> ) { callback_complete ( ) ; return ; } const load_audio_file_webaudio = ( source , count = <NUM_LIT> ) = > { const request = new XMLHttpRequest ( ) ; request . open ( "<STR_LIT>" , source , true ) ; request . responseType = "<STR_LIT>" ; request . onload = ( ) = > { this . context . decodeAudioData ( request . response , ( buffer ) = > { this . audio_buffers [ source ] = buffer ; n_loaded + + ; callback_load ( source ) ; if ( n_loaded == files . length ) { callback_complete ( ) ; } } , ( e ) = > { callback_error ( { source : source , error : e } ) ; } ) ; } ; request . onerror = function ( e ) { let err = e ; if ( this . status == <NUM_LIT> ) { err = "<STR_LIT>" ; } callback_error ( { source : source , error : err } ) ; } ; request . onloadend = function ( e ) { if ( this . status == <NUM_LIT> ) { callback_error ( { source : source , error : "<STR_LIT>" } ) ; } } ; request . send ( ) ; this . preload_requests . push ( request ) ; } ; const load_audio_file_html5audio = ( source , count = <NUM_LIT> ) = > { const audio = new Audio ( ) ; const handleCanPlayThrough = ( ) = > { this . audio_buffers [ source ] = audio ; n_loaded + + ; callback_load ( source ) ; if ( n_loaded == files . length ) { callback_complete ( ) ; } audio . removeEventListener ( "<STR_LIT>" , handleCanPlayThrough ) ; } ; audio . addEventListener ( "<STR_LIT>" , handleCanPlayThrough ) ; audio . addEventListener ( "<STR_LIT>" , function handleError ( e ) { callback_error ( { source : audio . src , error : e } ) ; audio . removeEventListener ( "<STR_LIT>" , handleError ) ; } ) ; audio . addEventListener ( "<STR_LIT>" , function handleAbort ( e ) { callback_error ( { source : audio . src , error : e } ) ; audio . removeEventListener ( "<STR_LIT>" , handleAbort ) ; } ) ; audio . src = source ; this . preload_requests . push ( audio ) ; } ; for ( const file of files ) { if ( typeof this . audio_buffers [ file ] != = "<STR_LIT>" ) { n_loaded + + ; callback_load ( file ) ; if ( n_loaded == files . length ) { callback_complete ( ) ; } } else { this . audio_buffers [ file ] = "<STR_LIT>" ; if ( this . audioContext ( ) != = null ) { load_audio_file_webaudio ( file ) ; } else { load_audio_file_html5audio ( file ) ; } } } } preloadImages ( images , callback_complete = ( ) = > { } , callback_load = ( filepath ) = > { } , callback_error = ( error_msg ) = > { } ) { images = unique ( images . flat ( ) ) ; var n_loaded = <NUM_LIT> ; if ( images . length == = <NUM_LIT> ) { callback_complete ( ) ; return ; } for ( var i = <NUM_LIT> ; i < images . length ; i + + ) { var img = new Image ( ) ; img . onload = function ( ) { n_loaded + + ; callback_load ( img . src ) ; if ( n_loaded == = images . length ) { callback_complete ( ) ; } } ; img . onerror = function ( e ) { callback_error ( { source : img . src , error : e } ) ; } ; img . src = images [ i ] ; this . img_cache [ images [ i ] ] = img ; this . preload_requests . push ( img ) ; } } preloadVideo ( videos , callback_complete = ( ) = > { } , callback_load = ( filepath ) = > { } , callback_error = ( error_msg ) = > { } ) { videos = unique ( videos . flat ( ) ) ; let n_loaded = <NUM_LIT> ; if ( videos . length == = <NUM_LIT> ) { callback_complete ( ) ; return ; } for ( const video of videos ) { const video_buffers = this . video_buffers ; const request = new XMLHttpRequest ( ) ; request . open ( "<STR_LIT>" , video , true ) ; request . responseType = "<STR_LIT>" ; request . onload = function ( ) { if ( this . status == = <NUM_LIT> | | this . status == = <NUM_LIT> ) { const videoBlob = this . response ; video_buffers [ video ] = URL . createObjectURL ( videoBlob ) ; n_loaded + + ; callback_load ( video ) ; if ( n_loaded == = videos . length ) { callback_complete ( ) ; } } } ; request . onerror = function ( e ) { let err = e ; if ( this . status == <NUM_LIT> ) { err = "<STR_LIT>" ; } callback_error ( { source : video , error : err } ) ; } ; request . onloadend = function ( e ) { if ( this . status == <NUM_LIT> ) { callback_error ( { source : video , error : "<STR_LIT>" } ) ; } } ; request . send ( ) ; this . preload_requests . push ( request ) ; } } private preloadMap = new Map < string , Record < string , PreloadType > > ( ) ; getAutoPreloadList ( timeline_description ) { / ** Map each preload parameter type to a set of paths to be preloaded * / const preloadPaths = Object . fromEntries ( preloadParameterTypes . map ( ( type ) = > [ type , new Set < string > ( ) ] ) ) ; const traverseTimeline = ( node , inheritedTrialType   ? ) = > { const isTimeline = typeof node . timeline != = "<STR_LIT>" ; if ( isTimeline ) { for ( const childNode of node . timeline ) { traverseTimeline ( childNode , node . type   ? ? inheritedTrialType ) ; } } else if ( ( node . type   ? ? inheritedTrialType )   ? . info ) { const { name : pluginName , parameters } = ( node . type   ? ? inheritedTrialType ) . info ; if (   ! this . preloadMap . has ( pluginName ) ) { this . preloadMap . set ( pluginName , Object . fromEntries ( Object . entries < any > ( parameters ) . filter ( ( [ _name , { type , preload } ] ) = > preloadParameterTypes . includes ( type ) & & ( preload   ? ? true ) ) . map ( ( [ name , { type } ] ) = > [ name , type ] ) ) ) ; } for ( const [ parameterName , parameterType ] of Object . entries ( this . preloadMap . get ( pluginName ) ) ) { const parameterValue = node [ parameterName ] ; const elements = preloadPaths [ parameterType ] ; if ( typeof parameterValue == = "<STR_LIT>" ) { elements . add ( parameterValue ) ; } else if ( Array . isArray ( parameterValue ) ) { for ( const element of parameterValue . flat ( ) ) { if ( typeof element == = "<STR_LIT>" ) { elements . add ( element ) ; } } } } } } ; traverseTimeline ( { timeline : timeline_description } ) ; return { images : [ ... preloadPaths [ ParameterType . IMAGE ] ] , audio : [ ... preloadPaths [ ParameterType . AUDIO ] ] , video : [ ... preloadPaths [ ParameterType . VIDEO ] ] , } ; } cancelPreloads ( ) { for ( const request of this . preload_requests ) { request . onload = ( ) = > { } ; request . onerror = ( ) = > { } ; request . oncanplaythrough = ( ) = > { } ; request . onabort = ( ) = > { } ; } this . preload_requests = [ ] ; } private microphone_recorder : MediaRecorder = null ; initializeMicrophoneRecorder ( stream ) { const recorder = new MediaRecorder ( stream ) ; this . microphone_recorder = recorder ; } getMicrophoneRecorder ( ) { return this . microphone_recorder ; } } </s>
<s> import _ from '<STR_LIT>' ; <EOL> returns { <EOL> object <EOL> } <EOL> param userInput <EOL> export function fromUser ( userInput ) { <EOL> const matchAll = '<STR_LIT>' ; <EOL> if ( _ . isEmpty ( userInput ) ) { <EOL> return '<STR_LIT>' ; <EOL> } <EOL> if ( _ . isObject ( userInput ) ) { <EOL> return userInput ; <EOL> } <EOL> userInput = userInput | | '<STR_LIT>' ; <EOL> if ( typeof userInput == = '<STR_LIT>' ) { <EOL> const trimmedUserInput = userInput . trim ( ) ; <EOL> if ( trimmedUserInput . length == = <NUM_LIT> ) { <EOL> return matchAll ; <EOL> } <EOL> if ( trimmedUserInput [ <NUM_LIT> ] == = '<STR_LIT>' ) { <EOL> try { <EOL> return JSON . parse ( trimmedUserInput ) ; <EOL> } catch ( e ) { <EOL> return userInput ; <EOL> } <EOL> } else { <EOL> return userInput ; <EOL> } <EOL> } <EOL> } </s>
<s> import { <EOL> SearchResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FetchHandlers , <EOL> SearchRequest <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> defaultSearchStrategy <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ISearchOptions <EOL> } from '<STR_LIT>' ; <EOL> export function callClient ( searchRequests , requestsOptions = [ ] , fetchHandlers ) { <EOL> const requestOptionEntries = searchRequests . map ( ( request , i ) = > [ request , requestsOptions [ i ] ] ) ; <EOL> const requestOptionsMap = new Map < SearchRequest , <EOL> ISearchOptions > ( requestOptionEntries ) ; <EOL> const requestResponseMap = new Map < SearchRequest , <EOL> Promise < SearchResponse < any > > > ( ) ; <EOL> const { <EOL> searching , <EOL> abort <EOL> } = defaultSearchStrategy . search ( { <EOL> searchRequests , <EOL> ... fetchHandlers , <EOL> } ) ; <EOL> searchRequests . forEach ( ( request , i ) = > { <EOL> const response = searching . then ( ( results ) = > fetchHandlers . onResponse ( request , results [ i ] ) ) ; <EOL> const { <EOL> abortSignal = null <EOL> } = requestOptionsMap . get ( request ) | | { } ; <EOL> if ( abortSignal ) abortSignal . addEventListener ( '<STR_LIT>' , abort ) ; <EOL> requestResponseMap . set ( request , response ) ; <EOL> } ) ; <EOL> return searchRequests . map ( ( request ) = > requestResponseMap . get ( request )   ! ) ; <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldFormat <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TextContextTypeConvert , <EOL> FIELD_FORMAT_IDS <EOL> } from '<STR_LIT>' ; <EOL> export class IpFormat extends FieldFormat { <EOL> static id = FIELD_FORMAT_IDS . IP ; <EOL> static title = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> static fieldType = OSD_FIELD_TYPES . IP ; <EOL> textConvert : TextContextTypeConvert = ( val ) = > { <EOL> if ( val == = undefined | | val == = null ) return '<STR_LIT>' ; <EOL> if ( ! isFinite ( val ) ) return val ; <EOL> return [ val >> > <NUM_LIT> , ( val >> > <NUM_LIT> ) & <NUM_LIT> , ( val >> > <NUM_LIT> ) & <NUM_LIT> , val & <NUM_LIT> ] . join ( '<STR_LIT>' ) ; <EOL> } ; <EOL> } </s>
<s> import { <EOL> EventEmitter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isEqual <EOL> } from '<STR_LIT>' ; <EOL> import ResizeObserver from '<STR_LIT>' ; <EOL> function getSize ( el ) { <EOL> return [ el . clientWidth , el . clientHeight ] ; <EOL> } <EOL> / ** <EOL> * ResizeChecker receives an element and emits a "<STR_LIT>" event every time it changes size . <EOL> * / <EOL> export class ResizeChecker extends EventEmitter { <EOL> private destroyed : boolean = false ; <EOL> private el : HTMLElement | null ; <EOL> private observer : ResizeObserver | null ; <EOL> private expectedSize : [ number , number ] | null = null ; <EOL> constructor ( el , args = { } ) { <EOL> super ( ) ; <EOL> this . el = el ; <EOL> this . observer = new ResizeObserver ( ( ) = > { <EOL> if ( this . expectedSize ) { <EOL> const sameSize = isEqual ( getSize ( el ) , this . expectedSize ) ; <EOL> this . expectedSize = null ; <EOL> if ( sameSize ) { <EOL> return ; <EOL> } <EOL> } <EOL> this . emit ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> if ( ! args . disabled ) { <EOL> this . enable ( ) ; <EOL> } <EOL> } <EOL> public enable ( ) { <EOL> if ( this . destroyed ) { <EOL> return ; <EOL> } <EOL> this . expectedSize = getSize ( this . el ! ) ; <EOL> this . observer ! . observe ( this . el ! ) ; <EOL> } <EOL> / ** <EOL> * Run a function and ignore all resizes that occur <EOL> * while it ' s running . <EOL> * / <EOL> public modifySizeWithoutTriggeringResize ( block ) { <EOL> try { <EOL> block ( ) ; <EOL> } finally { <EOL> if ( this . el ) { <EOL> this . expectedSize = getSize ( this . el ) ; <EOL> } <EOL> } <EOL> } <EOL> / ** <EOL> * Tell the ResizeChecker to shutdown , stop listenings , and never <EOL> * emit another resize event . <EOL> * <EOL> * Cleans up it ' s listeners and timers . <EOL> * / <EOL> public destroy ( ) { <EOL> if ( this . destroyed ) { <EOL> return ; <EOL> } <EOL> this . destroyed = true ; <EOL> this . observer ! . disconnect ( ) ; <EOL> this . observer = null ; <EOL> this . expectedSize = null ; <EOL> this . el = null ; <EOL> this . removeAllListeners ( ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Count , <EOL> CountSchema , <EOL> Filter , <EOL> FilterExcludingWhere , <EOL> repository , <EOL> Where , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> get , <EOL> getModelSchemaRef , <EOL> param , <EOL> post , <EOL> requestBody <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CONTENT_TYPE , <EOL> OPERATION_SECURITY_SPEC , <EOL> STATUS_CODE , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> authenticate , <EOL> STRATEGY <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> authorize <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PermissionKey <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuditLog <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuditLogRepository <EOL> } from '<STR_LIT>' ; <EOL> const basePath = '<STR_LIT>' ; <EOL> export class AuditController { <EOL> constructor ( @ repository ( AuditLogRepository ) public auditLogRepository ) { } <EOL> @ authenticate ( STRATEGY . BEARER ) @ authorize ( { <EOL> permissions : [ PermissionKey . CreateAudit ] <EOL> } ) @ post ( basePath , { <EOL> security : OPERATION_SECURITY_SPEC , <EOL> responses : { <EOL> [ STATUS_CODE . OK ] : { <EOL> description : '<STR_LIT>' , <EOL> content : { <EOL> [ CONTENT_TYPE . JSON ] : { <EOL> schema : getModelSchemaRef ( AuditLog ) <EOL> } <EOL> } , <EOL> } , <EOL> } , <EOL> } ) async create ( @ requestBody ( { <EOL> content : { <EOL> [ CONTENT_TYPE . JSON ] : { <EOL> schema : getModelSchemaRef ( AuditLog , { <EOL> title : '<STR_LIT>' , <EOL> exclude : [ '<STR_LIT>' ] , <EOL> } ) , <EOL> } , <EOL> } , <EOL> } ) auditLog ) { <EOL> return this . auditLogRepository . create ( auditLog ) ; <EOL> } <EOL> @ authenticate ( STRATEGY . BEARER ) @ authorize ( { <EOL> permissions : [ PermissionKey . ViewAudit ] <EOL> } ) @ get ( ` $ { basePath } / count ` , { <EOL> security : OPERATION_SECURITY_SPEC , <EOL> responses : { <EOL> [ STATUS_CODE . OK ] : { <EOL> description : '<STR_LIT>' , <EOL> content : { <EOL> [ CONTENT_TYPE . JSON ] : { <EOL> schema : CountSchema <EOL> } <EOL> } , <EOL> } , <EOL> } , <EOL> } ) async count ( @ param . where ( AuditLog ) where   ? ) { <EOL> return this . auditLogRepository . count ( where ) ; <EOL> } <EOL> @ authenticate ( STRATEGY . BEARER ) @ authorize ( { <EOL> permissions : [ PermissionKey . ViewAudit ] <EOL> } ) @ get ( basePath , { <EOL> security : OPERATION_SECURITY_SPEC , <EOL> responses : { <EOL> [ STATUS_CODE . OK ] : { <EOL> description : '<STR_LIT>' , <EOL> content : { <EOL> [ CONTENT_TYPE . JSON ] : { <EOL> schema : { <EOL> type : '<STR_LIT>' , <EOL> items : getModelSchemaRef ( AuditLog , { <EOL> includeRelations : true <EOL> } ) , <EOL> } , <EOL> } , <EOL> } , <EOL> } , <EOL> } , <EOL> } ) async find ( @ param . filter ( AuditLog ) filter   ? ) { <EOL> return this . auditLogRepository . find ( filter ) ; <EOL> } <EOL> @ authenticate ( STRATEGY . BEARER ) @ authorize ( { <EOL> permissions : [ PermissionKey . ViewAudit ] <EOL> } ) @ get ( ` $ { basePath } / { id } ` , { <EOL> security : OPERATION_SECURITY_SPEC , <EOL> responses : { <EOL> [ STATUS_CODE . OK ] : { <EOL> description : '<STR_LIT>' , <EOL> content : { <EOL> [ CONTENT_TYPE . JSON ] : { <EOL> schema : getModelSchemaRef ( AuditLog , { <EOL> includeRelations : true <EOL> } ) , <EOL> } , <EOL> } , <EOL> } , <EOL> } , <EOL> } ) async findById ( @ param . path . string ( '<STR_LIT>' ) id , @ param . filter ( AuditLog , { <EOL> exclude : '<STR_LIT>' <EOL> } ) filter   ? ) { <EOL> return this . auditLogRepository . findById ( id , filter ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> createFeatureSelector , <EOL> createSelector <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> REVIEWERSTATISTICS_FEATURE_KEY , <EOL> ReviewerStatisticsState <EOL> } from '<STR_LIT>' ; <EOL> const getReviewerStatisticsState = createFeatureSelector < ReviewerStatisticsState > ( REVIEWERSTATISTICS_FEATURE_KEY ) ; <EOL> const getReviewerStatisticsResponse = createSelector ( getReviewerStatisticsState , state = > state . reviewerStatisticsResponse ) ; <EOL> const getReviewerStatisticsResponseLoading = createSelector ( getReviewerStatisticsState , state = > state . reviewerStatisticsResponseLoading ) ; <EOL> const getReviewerStatisticsResponseLoadError = createSelector ( getReviewerStatisticsState , state = > state . reviewerStatisticsResponseLoadError ) ; <EOL> const getReviewerStatisticsSelectedRepositories = createSelector ( getReviewerStatisticsState , state = > state . reviewerStatisticsSelectedRepositories ) ; <EOL> export const reviewerStatisticsQuery = { <EOL> getReviewerStatisticsResponse : getReviewerStatisticsResponse , <EOL> getReviewerStatisticsResponseLoading : getReviewerStatisticsResponseLoading , <EOL> getReviewerStatisticsResponseLoadError : getReviewerStatisticsResponseLoadError , <EOL> getReviewerStatisticsSelectedRepositories : getReviewerStatisticsSelectedRepositories <EOL> } ; </s>
<s> import { <EOL> blake2b256 <EOL> } from "<STR_LIT>" ; <EOL> export function newFilter ( bits , k ) { <EOL> const nBits = bits . length * <NUM_LIT> ; <EOL> return { <EOL> contains ( key ) { <EOL> let hash = blake2b256 ( key ) . readUInt32BE ( <NUM_LIT> ) ; <EOL> const delta = ( hash >> > <NUM_LIT> ) | ( hash << <NUM_LIT> >> > <NUM_LIT> ) ; <EOL> for ( let i = <NUM_LIT> ; i < k ; i + + ) { <EOL> const bitPos = hash % nBits ; <EOL> const index = bitPos >> > <NUM_LIT> ; <EOL> const bit = <NUM_LIT> << ( bitPos % <NUM_LIT> ) ; <EOL> if ( ! ( bits [ index ] & bit ) ) { <EOL> return false ; <EOL> } <EOL> hash = ( hash + delta ) >> > <NUM_LIT> ; <EOL> } <EOL> return true ; <EOL> } <EOL> } ; <EOL> } </s>
<s> import { <EOL> Config <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> findConfigFile , <EOL> findPackageJsonFile , <EOL> readJson <EOL> } from '<STR_LIT>' ; <EOL> export interface ConfigFromFileResult { <EOL> usedConfigFile : boolean ; usedPackageJson : boolean ; config : Partial < Config > ; <EOL> } <EOL> export function readConfigFromFile ( opts ) { <EOL> const configFile = opts . configFile | | findConfigFile ( process . cwd ( ) ) ; <EOL> const packageJsonFile = findPackageJsonFile ( process . cwd ( ) ) ; <EOL> const configByConfigFile =   ! configFile   ? { } : readJson ( configFile ) ; <EOL> const configByPackageJson =   ! packageJsonFile   ? { } : readJson ( packageJsonFile ) . tsToOpenAPI ; <EOL> const config = Object . assign ( { } , configByConfigFile , configByPackageJson ) ; <EOL> return { <EOL> usedConfigFile :   ! ! configFile , <EOL> usedPackageJson :   ! ! packageJsonFile , <EOL> config , <EOL> } ; <EOL> } </s>
<s> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TabbedAggResponseWriter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TabifyBuckets <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TabbedResponseWriterOptions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggResponseBucket <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggGroupNames , <EOL> IAggConfigs <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * Sets up the ResponseWriter and kicks off bucket collection . <EOL> * / <EOL> export function tabifyAggResponse ( aggConfigs , opensearchResponse , respOpts   ? ) { <EOL> / ** <EOL> * read an aggregation from a bucket , which * might * be found at key ( if <EOL> * the response came in object form ) , and will recurse down the aggregation <EOL> * tree and will pass the read values to the ResponseWriter . <EOL> * / <EOL> function collectBucket ( aggs , write , bucket , key , aggScale ) { <EOL> const column = write . columns . shift ( ) ; <EOL> if ( column ) { <EOL> const agg = column . aggConfig ; <EOL> const aggInfo = agg . write ( aggs ) ; <EOL> aggScale *= aggInfo . metricScale | | <NUM_LIT> ; <EOL> switch ( agg . type . type ) { <EOL> case AggGroupNames . Buckets : <EOL> const aggBucket = get ( bucket , agg . id ) ; <EOL> const tabifyBuckets = new TabifyBuckets ( aggBucket , agg . params , respOpts ? . timeRange ) ; <EOL> if ( tabifyBuckets . length ) { <EOL> tabifyBuckets . forEach ( ( subBucket , tabifyBucketKey ) = > { <EOL> const bucketValue = agg . getKey ( subBucket , tabifyBucketKey ) ; <EOL> const hasBucketValue = typeof bucketValue != = '<STR_LIT>' ; <EOL> if ( hasBucketValue ) { <EOL> write . bucketBuffer . push ( { <EOL> id : column . id , <EOL> value : bucketValue <EOL> } ) ; <EOL> } <EOL> collectBucket ( aggs , write , subBucket , agg . getKey ( subBucket , tabifyBucketKey ) , aggScale ) ; <EOL> if ( hasBucketValue ) { <EOL> write . bucketBuffer . pop ( ) ; <EOL> } <EOL> } ) ; <EOL> } else if ( respOpts ? . partialRows ) { <EOL> write . columns . unshift ( column ) ; <EOL> passEmptyBuckets ( aggs , write , bucket , key , aggScale ) ; <EOL> write . columns . shift ( ) ; <EOL> } else { <EOL> write . row ( ) ; <EOL> } <EOL> break ; <EOL> case AggGroupNames . Metrics : <EOL> let value = agg . getValue ( bucket ) ; <EOL> if ( aggScale != = <NUM_LIT> ) { <EOL> value *= aggScale ; <EOL> } <EOL> write . metricBuffer . push ( { <EOL> id : column . id , <EOL> value <EOL> } ) ; <EOL> if ( ! write . columns . length ) { <EOL> write . row ( ) ; <EOL> } else { <EOL> collectBucket ( aggs , write , bucket , key , aggScale ) ; <EOL> } <EOL> write . metricBuffer . pop ( ) ; <EOL> break ; <EOL> } <EOL> write . columns . unshift ( column ) ; <EOL> } <EOL> } <EOL> function passEmptyBuckets ( aggs , write , bucket , key , aggScale ) { <EOL> const column = write . columns . shift ( ) ; <EOL> if ( column ) { <EOL> const agg = column . aggConfig ; <EOL> switch ( agg . type . type ) { <EOL> case AggGroupNames . Metrics : <EOL> write . columns . unshift ( column ) ; <EOL> collectBucket ( aggs , write , bucket , key , aggScale ) ; <EOL> return ; <EOL> case AggGroupNames . Buckets : <EOL> passEmptyBuckets ( aggs , write , bucket , key , aggScale ) ; <EOL> } <EOL> write . columns . unshift ( column ) ; <EOL> } <EOL> } <EOL> const write = new TabbedAggResponseWriter ( aggConfigs , respOpts | | { } ) ; <EOL> const topLevelBucket = { <EOL> ... opensearchResponse . aggregations , <EOL> doc_count : opensearchResponse . hits . total , <EOL> } ; <EOL> collectBucket ( aggConfigs , write , topLevelBucket , '<STR_LIT>' , <NUM_LIT> ) ; <EOL> return write . response ( ) ; <EOL> } </s>
<s> import { <EOL> AfterViewInit , <EOL> Component , <EOL> EventEmitter , <EOL> HostListener , <EOL> Input , <EOL> OnDestroy , <EOL> Output , <EOL> Renderer2 <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> EventHandler <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> EventService <EOL> } from "<STR_LIT>" ; <EOL> @ Component ( { <EOL> selector : "<STR_LIT>" , <EOL> templateUrl : "<STR_LIT>" , <EOL> styleUrls : [ "<STR_LIT>" ] <EOL> } ) export class MatPlayButtonComponent implements AfterViewInit , OnDestroy { <EOL> @ Input ( ) video : HTMLVideoElement ; <EOL> @ Input ( ) play = false ; <EOL> @ Output ( ) playChanged = new EventEmitter < boolean > ( ) ; <EOL> @ Input ( ) keyboard = true ; <EOL> private events : EventHandler [ ] ; <EOL> constructor ( private renderer , private evt ) { } <EOL> ngAfterViewInit ( ) { <EOL> this . events = [ { <EOL> element : this . video , <EOL> name : "<STR_LIT>" , <EOL> callback : event = > this . setVideoPlayback ( true ) , <EOL> dispose : null <EOL> } , { <EOL> element : this . video , <EOL> name : "<STR_LIT>" , <EOL> callback : event = > this . setVideoPlayback ( false ) , <EOL> dispose : null <EOL> } , { <EOL> element : this . video , <EOL> name : "<STR_LIT>" , <EOL> callback : event = > this . setVideoPlayback ( false ) , <EOL> dispose : null <EOL> } , { <EOL> element : this . video , <EOL> name : "<STR_LIT>" , <EOL> callback : event = > this . setVideoPlayback ( false ) , <EOL> dispose : null <EOL> } , { <EOL> element : this . video , <EOL> name : "<STR_LIT>" , <EOL> callback : event = > this . toggleVideoPlayback ( ) , <EOL> dispose : null <EOL> } ] ; <EOL> this . evt . addEvents ( this . renderer , this . events ) ; <EOL> } <EOL> ngOnDestroy ( ) { <EOL> this . evt . removeEvents ( this . events ) ; <EOL> } <EOL> setVideoPlayback ( value ) { <EOL> if ( this . play != = value ) { <EOL> this . toggleVideoPlayback ( ) ; <EOL> } <EOL> } <EOL> toggleVideoPlayback ( ) { <EOL> this . play =   ! this . play ; <EOL> this . updateVideoPlayback ( ) ; <EOL> } <EOL> updateVideoPlayback ( ) { <EOL> this . play   ? this . video . play ( ) : this . video . pause ( ) ; <EOL> this . playChanged . emit ( this . play ) ; <EOL> } <EOL> @ HostListener ( "<STR_LIT>" , [ "<STR_LIT>" ] ) onPlayKey ( event ) { <EOL> if ( this . keyboard ) { <EOL> this . toggleVideoPlayback ( ) ; <EOL> event . preventDefault ( ) ; <EOL> } <EOL> } <EOL> } </s>
<s> import type { <EOL> CustomIntegration <EOL> } from '<STR_LIT>' ; <EOL> export const integrations = [ { <EOL> id : '<STR_LIT>' , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> description : '<STR_LIT>' , <EOL> isBeta : false , <EOL> shipper : '<STR_LIT>' , <EOL> icons : [ { <EOL> type : '<STR_LIT>' , <EOL> src : '<STR_LIT>' , <EOL> } , ] , <EOL> title : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> eprOverlap : '<STR_LIT>' , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> description : '<STR_LIT>' , <EOL> isBeta : false , <EOL> shipper : '<STR_LIT>' , <EOL> icons : [ { <EOL> type : '<STR_LIT>' , <EOL> src : '<STR_LIT>' , <EOL> } , ] , <EOL> title : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> eprOverlap : '<STR_LIT>' , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> description : '<STR_LIT>' , <EOL> isBeta : false , <EOL> shipper : '<STR_LIT>' , <EOL> icons : [ { <EOL> type : '<STR_LIT>' , <EOL> src : '<STR_LIT>' , <EOL> } , ] , <EOL> title : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> eprOverlap : '<STR_LIT>' , <EOL> } , ] ; </s>
<s> import { <EOL> PageStrategy <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> extractStaticData , <EOL> File <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> FileHandler , <EOL> FindPages <EOL> } from '<STR_LIT>' ; <EOL> export class DefaultPageStrategy extends PageStrategy { <EOL> constructor ( opts = { } ) { <EOL> const { <EOL> extraFindPages , <EOL> fileHandler = defaultFileHandler <EOL> } = opts ; <EOL> super ( ( pagesDir , helpersFromParent ) = > { <EOL> const helpers = this . createHelpers ( fileHandler ) ; <EOL> helpers . watchFiles ( pagesDir , '<STR_LIT>' ) ; <EOL> if ( typeof extraFindPages == = '<STR_LIT>' ) { <EOL> extraFindPages ( pagesDir , helpers ) ; <EOL> } <EOL> } ) ; <EOL> } <EOL> } <EOL> / ** <EOL> * The defaultFileHandler return the result to caller , <EOL> * instead of directly setting the pageData object . <EOL> * so that it is more useful to users . <EOL> * / <EOL> export const defaultFileHandler = async ( file , api ) = > { <EOL> const pagePublicPath = getPagePublicPath ( file . relative ) ; <EOL> return { <EOL> pageId : pagePublicPath , <EOL> dataPath : file . path , <EOL> staticData : await extractStaticData ( file ) , <EOL> } ; <EOL> } ; <EOL> / ** <EOL> * turn   ` sub - path / page2 / index . tsx ` into   ` / sub - path / page2 ` <EOL> * / <EOL> export function getPagePublicPath ( relativePageFilePath ) { <EOL> let pagePublicPath = relativePageFilePath . replace ( / \ $ \ . ( md | mdx | js | jsx | ts | tsx ) $ / , '<STR_LIT>' ) ; <EOL> pagePublicPath = pagePublicPath . replace ( / index $ / , '<STR_LIT>' ) ; <EOL> pagePublicPath = pagePublicPath . replace ( / \ / $ / , '<STR_LIT>' ) ; <EOL> pagePublicPath =   ` / $ { pagePublicPath } ` ; <EOL> pagePublicPath = pagePublicPath . replace ( / \ [ ( . * ? ) \ ] / g , ( _ , paramName ) = >   ` : $ { paramName } ` ) ; <EOL> return pagePublicPath ; <EOL> } </s>
<s> import { <EOL> DomainEvents <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IHandle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UserLoggedInEvent <EOL> } from '<STR_LIT>' ; <EOL> export class AfterUserLoggedIn implements IHandle < UserLoggedInEvent > { <EOL> constructor ( ) { <EOL> this . setupSubscriptions ( ) ; <EOL> } <EOL> setupSubscriptions ( ) { <EOL> DomainEvents . register ( this . onUserLoggedInEvent . bind ( this ) , UserLoggedInEvent . name ) ; <EOL> } <EOL> private async onUserLoggedInEvent ( event ) { <EOL> const { <EOL> user <EOL> } = event ; <EOL> console . log ( '<STR_LIT>' , user ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> NextApiRequest <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> UserCredentials <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ironSession , <EOL> Session <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> env <EOL> } from "<STR_LIT>" ; <EOL> export type NextApiRequestWithSession = NextApiRequest & { <EOL> session : Session ; <EOL> } ; <EOL> export type CookieSchema = { <EOL> googleUserId : string ; authState   ? : string ; temporaryRegistration   ? : { <EOL> credentials : UserCredentials ; <EOL> } ; <EOL> } ; <EOL> export const withSession = ( ) = > { <EOL> return ironSession ( { <EOL> cookieName : "<STR_LIT>" , <EOL> password : env . SESSION_COOKIE_SECRET , <EOL> cookieOptions : { <EOL> secure : process . env . NODE_ENV == = "<STR_LIT>" , <EOL> sameSite : "<STR_LIT>" , <EOL> httpOnly : true <EOL> } <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> Application , <EOL> ApplicationCacheConfigAndExecutorImpl , <EOL> ApplicationImpl , <EOL> DatetimeProjectItemImpl , <EOL> DescriptionGetter , <EOL> Group , <EOL> GroupName , <EOL> NohupShellExecutor , <EOL> Platform , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> readFile <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isEmpty , <EOL> isNil , <EOL> unique <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> existsOrNot <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Context <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> generatePinyinIndex <EOL> } from '<STR_LIT>' ; <EOL> const JETBRAINS = '<STR_LIT>' ; <EOL> export class JetBrainsProjectItemImpl extends DatetimeProjectItemImpl { } <EOL> / ** <EOL> * JetBrains 系列应用实现 <EOL> * / <EOL> export class JetBrainsApplicationImpl extends ApplicationCacheConfigAndExecutorImpl < JetBrainsProjectItemImpl > { <EOL> constructor ( id , name , icon , platform = [ Platform . win32 , Platform . darwin , Platform . linux ] , description = '<STR_LIT>' , beta = false , configFilename = '<STR_LIT>' ) { <EOL> super ( id , name , icon , JETBRAINS , platform , Group [ GroupName . jetbrains ] , description , beta , configFilename ) ; <EOL> } <EOL> override defaultConfigPath ( ) { <EOL> return '<STR_LIT>' ; <EOL> } <EOL> override defaultExecutorPath ( ) { <EOL> return '<STR_LIT>' ; <EOL> } <EOL> async generateCacheProjectItems ( context ) { <EOL> let items = [ ] ; <EOL> let buffer = await readFile ( this . config ) ; <EOL> if ( ! isNil ( buffer ) ) { <EOL> let content = buffer . toString ( ) ; <EOL> let domParser = new DOMParser ( ) . parseFromString ( content , '<STR_LIT>' ) ; <EOL> domParser . querySelectorAll ( '<STR_LIT>' ) . forEach ( ( element , index ) = > { <EOL> let path = element . getAttribute ( '<STR_LIT>' )   ? ? '<STR_LIT>' ; <EOL> let datetime = element . querySelector ( '<STR_LIT>' ) ? . getAttribute ( '<STR_LIT>' )   ? ? <NUM_LIT> ; <EOL> if ( ! isEmpty ( path ) ) { <EOL> path = path . replace ( '<STR_LIT>' , utools . getPath ( '<STR_LIT>' ) ) ; <EOL> let parseObj = parse ( path ) ; <EOL> let { <EOL> exists , <EOL> description , <EOL> icon <EOL> } = existsOrNot ( path , { <EOL> description : path , <EOL> icon : this . icon , <EOL> } ) ; <EOL> items . push ( { <EOL> id : '<STR_LIT>' , <EOL> title : parseObj . name , <EOL> description : description , <EOL> icon : icon , <EOL> searchKey : unique ( [ ... generatePinyinIndex ( context , parseObj . name ) , parseObj . name , path ] ) , <EOL> exists : exists , <EOL> command : new NohupShellExecutor ( this . executor , path ) , <EOL> datetime : parseInt ( ` $ { datetime } ` ) , <EOL> } ) ; <EOL> } <EOL> } ) ; <EOL> } <EOL> return items ; <EOL> } <EOL> } <EOL> export const applications = [ new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , [ Platform . darwin ] ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , undefined , undefined , undefined , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , new JetBrainsApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) , ] ; </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import * as ReactDOM from '<STR_LIT>' ; <EOL> import { <EOL> Menu , <EOL> MenuButton , <EOL> MenuList , <EOL> MenuItem <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> function App ( ) { <EOL> const logged = true ; <EOL> return ( < Menu > < MenuButton className = "<STR_LIT>" > Menu < / MenuButton > < MenuList > < MenuItem onSelect = { ( ) = > console . log ( '<STR_LIT>' ) } > Item One < / MenuItem > < MenuItem onSelect = { ( ) = > console . log ( '<STR_LIT>' ) } > Item Two < / MenuItem > { logged & & < AuthenticatedMenuItems / > } < / MenuList > < / Menu > ) ; } function AuthenticatedMenuItems ( ) { return ( < > < MenuItem onSelect = { ( ) = > console . log ( '<STR_LIT>' ) } > Item Three < / MenuItem > < MenuItem onSelect = { ( ) = > console . log ( '<STR_LIT>' ) } > Item Four < / MenuItem > < / > ) ; } ReactDOM . render ( < App / > , document . getElementById ( '<STR_LIT>' ) ) ; </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IMetricAggConfig , <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsTopHit extends BaseAggParams { <EOL> field : string ; aggregate : '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' ; sortField   ? : string ; size   ? : number ; sortOrder   ? : '<STR_LIT>' | '<STR_LIT>' ; <EOL> } <EOL> const isNumericFieldSelected = ( agg ) = > { <EOL> const field = agg . getParam ( '<STR_LIT>' ) ; <EOL> return field & & field . type & & field . type == = OSD_FIELD_TYPES . NUMBER ; <EOL> } ; <EOL> export const getTopHitMetricAgg = ( ) = > { <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . TOP_HITS , <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> makeLabel ( aggConfig ) { <EOL> const lastPrefixLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const firstPrefixLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> let prefix = aggConfig . getParam ( '<STR_LIT>' ) . value == = '<STR_LIT>'   ? lastPrefixLabel : firstPrefixLabel ; <EOL> const size = aggConfig . getParam ( '<STR_LIT>' ) ; <EOL> if ( size != = <NUM_LIT> ) { <EOL> prefix +=   `   $ { size } ` ; <EOL> } <EOL> const field = aggConfig . getParam ( '<STR_LIT>' ) ; <EOL> return   ` $ { prefix }   $ { field   ? field . displayName : '<STR_LIT>' } ` ; <EOL> } , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> onlyAggregatable : false , <EOL> filterFieldTypes : Object . values ( OSD_FIELD_TYPES ) . filter ( ( type ) = > type != = OSD_FIELD_TYPES . HISTOGRAM ) , <EOL> write ( agg , output ) { <EOL> const field = agg . getParam ( '<STR_LIT>' ) ; <EOL> output . params = { } ; <EOL> if ( field . scripted ) { <EOL> output . params . script_fields = { <EOL> [ field . name ] : { <EOL> script : { <EOL> source : field . script , <EOL> lang : field . lang , <EOL> } , <EOL> } , <EOL> } ; <EOL> } else { <EOL> if ( field . readFromDocValues ) { <EOL> output . params . docvalue_fields = [ { <EOL> field : field . name , <EOL> ... ( field . type == = OSD_FIELD_TYPES . DATE & & { <EOL> format : '<STR_LIT>' <EOL> } ) , <EOL> } , ] ; <EOL> } <EOL> output . params . _source = field . name == = '<STR_LIT>'   ? true : field . name ; <EOL> } <EOL> } , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> options : [ { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> isCompatible : isNumericFieldSelected , <EOL> disabled : true , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> isCompatible : isNumericFieldSelected , <EOL> disabled : true , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> isCompatible : isNumericFieldSelected , <EOL> disabled : true , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> isCompatible : isNumericFieldSelected , <EOL> disabled : true , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> isCompatible ( aggConfig ) { <EOL> return _ . get ( aggConfig . params , '<STR_LIT>' , '<STR_LIT>' ) == = '<STR_LIT>' ; <EOL> } , <EOL> disabled : true , <EOL> value : '<STR_LIT>' , <EOL> } , ] , <EOL> write : _ . noop , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> default : <NUM_LIT> , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : [ OSD_FIELD_TYPES . NUMBER , OSD_FIELD_TYPES . DATE , OSD_FIELD_TYPES . IP , OSD_FIELD_TYPES . STRING , ] , <EOL> default ( agg ) { <EOL> return agg . getIndexPattern ( ) . timeFieldName ; <EOL> } , <EOL> write : _ . noop , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> default : '<STR_LIT>' , <EOL> options : [ { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> value : '<STR_LIT>' , <EOL> } , ] , <EOL> write ( agg , output ) { <EOL> const sortField = agg . params . sortField ; <EOL> const sortOrder = agg . params . sortOrder ; <EOL> if ( sortField . scripted ) { <EOL> output . params . sort = [ { <EOL> _script : { <EOL> script : { <EOL> source : sortField . script , <EOL> lang : sortField . lang , <EOL> } , <EOL> type : sortField . type , <EOL> order : sortOrder . value , <EOL> } , <EOL> } , ] ; <EOL> } else { <EOL> output . params . sort = [ { <EOL> [ sortField . name ] : { <EOL> order : sortOrder . value , <EOL> } , <EOL> } , ] ; <EOL> } <EOL> } , <EOL> } , ] , <EOL> getValue ( agg , bucket ) { <EOL> const hits = _ . get ( bucket ,   ` $ { agg . id } . hits . hits ` ) ; <EOL> if ( ! hits | |   ! hits . length ) { <EOL> return null ; <EOL> } <EOL> const path = agg . getParam ( '<STR_LIT>' ) . name ; <EOL> let values = _ . flatten ( hits . map ( ( hit ) = > path == = '<STR_LIT>'   ? hit . _source : agg . getIndexPattern ( ) . flattenHit ( hit , true ) [ path ] ) ) ; <EOL> if ( values . length == = <NUM_LIT> ) { <EOL> values = values [ <NUM_LIT> ] ; <EOL> } <EOL> if ( Array . isArray ( values ) ) { <EOL> if ( ! _ . compact ( values ) . length ) { <EOL> return null ; <EOL> } <EOL> const aggregate = agg . getParam ( '<STR_LIT>' ) ; <EOL> switch ( aggregate . value ) { <EOL> case '<STR_LIT>' : <EOL> return _ . max ( values ) ; <EOL> case '<STR_LIT>' : <EOL> return _ . min ( values ) ; <EOL> case '<STR_LIT>' : <EOL> return _ . sum ( values ) ; <EOL> case '<STR_LIT>' : <EOL> return _ . sum ( values ) / values . length ; <EOL> } <EOL> } <EOL> return values ; <EOL> } , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> write <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> convert <EOL> } from "<STR_LIT>" ; <EOL> async function convertBlob ( tsInterface , tsName , jsonFormat   ? ) { <EOL> const path = await write ( tsInterface , { <EOL> extension : '<STR_LIT>' <EOL> } ) ; <EOL> return convert ( { <EOL> path , <EOL> asComment : false , <EOL> types : [ tsName ] , <EOL> jsonFormat <EOL> } ) ; <EOL> } <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const yaml = await convertBlob ( "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> expect ( yaml ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const json = await convertBlob ( "<STR_LIT>" , "<STR_LIT>" , true ) ; <EOL> expect ( json ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const yaml = await convertBlob ( "<STR_LIT>" , "<STR_LIT>" ) ; <EOL> expect ( yaml ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const yaml = await convertBlob ( ` <EOL> export type Foo = number | { <EOL> foo : string | boolean ; <EOL> bar : string [ ] | { baz ? : number } | { baz : boolean } ; <EOL> } <EOL> 	 	 	 	 ` , "<STR_LIT>" ) ; <EOL> expect ( yaml ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> buildRangeFilter , <EOL> RangeFilterParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggTypesDependencies <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IBucketAggConfig <EOL> } from '<STR_LIT>' ; <EOL> internal <EOL> export const createFilterHistogram = ( getFieldFormatsStart ) = > { <EOL> return ( aggConfig , key ) = > { <EOL> const { <EOL> deserialize <EOL> } = getFieldFormatsStart ( ) ; <EOL> const value = parseInt ( key , <NUM_LIT> ) ; <EOL> const params = { <EOL> gte : value , <EOL> lt : value + aggConfig . params . interval <EOL> } ; <EOL> return buildRangeFilter ( aggConfig . params . field , params , aggConfig . getIndexPattern ( ) , deserialize ( aggConfig . toSerializedFieldFormat ( ) ) . convert ( key ) ) ; <EOL> } ; <EOL> } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> Action , <EOL> ActionContext as Context , <EOL> ActionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Presentable , <EOL> PresentableGrouping <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> uiToReactComponent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ActionType <EOL> } from '<STR_LIT>' ; <EOL> internal <EOL> export class ActionInternal < A extends ActionDefinition = ActionDefinition > implements Action < Context < A > > , Presentable < Context < A > > { <EOL> constructor ( public readonly definition ) { } <EOL> public readonly id : string = this . definition . id ; public readonly type : ActionType = this . definition . type | | '<STR_LIT>' ; public readonly order : number = this . definition . order | | <NUM_LIT> ; public readonly MenuItem   ? = this . definition . MenuItem ; public readonly ReactMenuItem   ? = this . MenuItem   ? uiToReactComponent ( this . MenuItem ) : undefined ; public readonly grouping   ? : PresentableGrouping < Context < A > > = this . definition . grouping ; public execute ( context ) { <EOL> return this . definition . execute ( context ) ; <EOL> } <EOL> public getIconType ( context ) { <EOL> if ( ! this . definition . getIconType ) return undefined ; <EOL> return this . definition . getIconType ( context ) ; <EOL> } <EOL> public getDisplayName ( context ) { <EOL> if ( ! this . definition . getDisplayName ) return   ` Action :   $ { this . id } ` ; <EOL> return this . definition . getDisplayName ( context ) ; <EOL> } <EOL> public getDisplayNameTooltip ( context ) { <EOL> if ( ! this . definition . getDisplayNameTooltip ) return '<STR_LIT>' ; <EOL> return this . definition . getDisplayNameTooltip ( context ) ; <EOL> } <EOL> public async isCompatible ( context ) { <EOL> if ( ! this . definition . isCompatible ) return true ; <EOL> return await this . definition . isCompatible ( context ) ; <EOL> } <EOL> public async getHref ( context ) { <EOL> if ( ! this . definition . getHref ) return undefined ; <EOL> return await this . definition . getHref ( context ) ; <EOL> } <EOL> public async shouldAutoExecute ( context ) { <EOL> if ( ! this . definition . shouldAutoExecute ) return false ; <EOL> return this . definition . shouldAutoExecute ( context ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> configureStore , <EOL> createReducer , <EOL> createAction <EOL> } from '<STR_LIT>' ; <EOL> const initialState = { <EOL> count : <NUM_LIT> <EOL> } ; <EOL> const increment = createAction ( '<STR_LIT>' ) ; <EOL> const decrement = createAction ( '<STR_LIT>' ) ; <EOL> const counterReducer = createReducer ( initialState , { <EOL> [ increment ] : ( state , action ) = > { <EOL> return { <EOL> ... state , <EOL> count : state . count + <NUM_LIT> <EOL> } ; <EOL> } , <EOL> [ decrement ] : ( state , action ) = > { <EOL> return { <EOL> ... state , <EOL> count : state . count - <NUM_LIT> <EOL> } ; <EOL> } , <EOL> } ) ; <EOL> const store = configureStore ( { <EOL> reducer : { <EOL> counterState : counterReducer , <EOL> } , <EOL> } ) ; <EOL> store . subscribe ( ( ) = > { <EOL> console . log ( store . getState ( ) ) ; <EOL> } ) ; <EOL> store . dispatch ( increment ( ) ) ; <EOL> store . dispatch ( increment ( ) ) ; <EOL> store . dispatch ( increment ( ) ) ; </s>
<s> </s>
<s> import { <EOL> override <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Log <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseListViewCommandSet , <EOL> Command , <EOL> IListViewCommandSetListViewUpdatedParameters , <EOL> IListViewCommandSetExecuteEventParameters <EOL> } from '<STR_LIT>' ; <EOL> import * as reactDom from '<STR_LIT>' ; <EOL> import { <EOL> EditImage <EOL> } from '<STR_LIT>' ; <EOL> import * as strings from '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> import { <EOL> ThemeProvider , <EOL> ThemeChangedEventArgs , <EOL> IReadonlyTheme <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * If your command set uses the ClientSideComponentProperties JSON input , <EOL> * it will be deseria lized into the BaseExtension . properties object . <EOL> * You can define an interface to describe it . <EOL> * / <EOL> export interface IImageEditorCommandSetProperties { <EOL> sampleTextOne : string ; <EOL> } <EOL> const LOG_SOURCE = '<STR_LIT>' ; <EOL> export default class ImageEditorCommandSet extends BaseListViewCommandSet < IImageEditorCommandSetProperties > { <EOL> private _container = document . createElement ( '<STR_LIT>' ) ; private showPanel : boolean = false ; private _themeProvider : ThemeProvider ; private _themeVariant : IReadonlyTheme | undefined ; @ override public onInit ( ) { <EOL> Log . info ( LOG_SOURCE , '<STR_LIT>' ) ; <EOL> this . _themeProvider = this . context . serviceScope . consume ( ThemeProvider . serviceKey ) ; <EOL> this . _themeVariant = this . _themeProvider . tryGetTheme ( ) ; <EOL> return Promise . resolve ( ) ; <EOL> } <EOL> @ override public onListViewUpdated ( event ) { <EOL> const editImageCommand = this . tryGetCommand ( '<STR_LIT>' ) ; <EOL> if ( editImageCommand ) { <EOL> if ( event . selectedRows . length == = <NUM_LIT> ) { <EOL> const _field = event . selectedRows [ <NUM_LIT> ] ; <EOL> const _fileType = _field . _values . get ( '<STR_LIT>' ) ; <EOL> if ( _fileType == = '<STR_LIT>' | | _fileType == = '<STR_LIT>' | | _fileType == = '<STR_LIT>' ) { <EOL> editImageCommand . visible = true ; <EOL> } <EOL> } else { <EOL> editImageCommand . visible = false ; <EOL> } <EOL> } <EOL> } <EOL> @ override public onExecute ( event ) { <EOL> const _imageUrl =   ` $ { this . context . pageContext . list . serverRelativeUrl } / $ { event . selectedRows [ <NUM_LIT> ] . getValueByName ( '<STR_LIT>' ) } ` ; <EOL> const _fileName = event . selectedRows [ <NUM_LIT> ] . getValueByName ( '<STR_LIT>' ) ; <EOL> Log . info ( LOG_SOURCE ,   ` Load Image Editor for   $ { _fileName } ` ) ; <EOL> switch ( event . itemId ) { <EOL> case '<STR_LIT>' : <EOL> document . body . appendChild ( this . _container ) ; <EOL> this . showPanel = true ; <EOL> let _renderImage = React . createElement ( EditImage , { <EOL> imageUrl : _imageUrl , <EOL> fileName : _fileName , <EOL> showPanel : this . showPanel , <EOL> themeVariant : this . _themeVariant <EOL> } ) ; <EOL> reactDom . render ( _renderImage , this . _container ) ; <EOL> break ; <EOL> default : <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> } <EOL> } </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order Infinity <EOL> * / <EOL> export const opacity = ( ) = > [ <EOL> [ / ^ opacity - ( ? < value > ( [ <NUM_LIT> - <NUM_LIT> ] ? \ d | <NUM_LIT> ) ) $ / , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> value <EOL> } = groups as { <EOL> value : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` opacity :   $ { Number ( ( Number ( value ) / <NUM_LIT> ) . toFixed ( <NUM_LIT> ) ) } ` , ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> export const environment = { <EOL> production : false <EOL> } ; </s>
<s> import { <EOL> SavedObject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> IndexPatternAttributes <EOL> } from '<STR_LIT>' ; <EOL> export function getFromSavedObject ( savedObject ) { <EOL> if ( get ( savedObject , '<STR_LIT>' ) == = undefined ) { <EOL> return ; <EOL> } <EOL> return { <EOL> id : savedObject . id , <EOL> fields : JSON . parse ( savedObject . attributes . fields ! ) , <EOL> title : savedObject . attributes . title , <EOL> } ; <EOL> } </s>
<s> import { <EOL> PluginInitializerContext , <EOL> CoreSetup , <EOL> CoreStart , <EOL> Plugin <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionsService , <EOL> ExpressionsServiceSetup , <EOL> ExpressionsServiceStart , <EOL> ExecutionContext , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> setRenderersRegistry , <EOL> setNotifications , <EOL> setExpressionsService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ReactExpressionRenderer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionLoader , <EOL> loader <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> render , <EOL> ExpressionRenderHandler <EOL> } from '<STR_LIT>' ; <EOL> export type ExpressionsSetup = ExpressionsServiceSetup ; <EOL> export interface ExpressionsStart extends ExpressionsServiceStart { <EOL> ExpressionLoader : typeof ExpressionLoader ; ExpressionRenderHandler : typeof ExpressionRenderHandler ; loader : typeof loader ; ReactExpressionRenderer : typeof ReactExpressionRenderer ; render : typeof render ; <EOL> } <EOL> export class ExpressionsPublicPlugin implements Plugin < ExpressionsSetup , ExpressionsStart > { <EOL> private readonly expressions : ExpressionsService = new ExpressionsService ( ) ; constructor ( initializerContext ) { } <EOL> private configureExecutor ( core ) { <EOL> const { <EOL> executor <EOL> } = this . expressions ; <EOL> const getSavedObject = async ( type , id ) = > { <EOL> const [ start ] = await core . getStartServices ( ) ; <EOL> return start . savedObjects . client . get ( type , id ) ; <EOL> } ; <EOL> executor . extendContext ( { <EOL> environment : '<STR_LIT>' , <EOL> getSavedObject , <EOL> } ) ; <EOL> } <EOL> public setup ( core ) { <EOL> this . configureExecutor ( core ) ; <EOL> const { <EOL> expressions <EOL> } = this ; <EOL> const { <EOL> renderers <EOL> } = expressions ; <EOL> setRenderersRegistry ( renderers ) ; <EOL> setExpressionsService ( expressions ) ; <EOL> const setup = expressions . setup ( ) ; <EOL> return Object . freeze ( setup ) ; <EOL> } <EOL> public start ( core ) { <EOL> setNotifications ( core . notifications ) ; <EOL> const { <EOL> expressions <EOL> } = this ; <EOL> const start = { <EOL> ... expressions . start ( ) , <EOL> ExpressionLoader , <EOL> ExpressionRenderHandler , <EOL> loader , <EOL> ReactExpressionRenderer , <EOL> render , <EOL> } ; <EOL> return Object . freeze ( start ) ; <EOL> } <EOL> public stop ( ) { <EOL> this . expressions . stop ( ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> map , <EOL> pick , <EOL> zipObject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionTypeDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PointSeries , <EOL> PointSeriesColumn <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionValueRender <EOL> } from '<STR_LIT>' ; <EOL> type State = string | number | boolean | null | undefined | SerializableState ; <EOL> internal <EOL> export interface SerializableState { <EOL> [ key ] : State | State [ ] ; <EOL> } <EOL> const name = '<STR_LIT>' ; <EOL> param datatable <EOL> export const isDatatable = ( datatable ) : datatable is Datatable = >   ! ! datatable & & typeof datatable == = '<STR_LIT>' & & ( datatable as any ) . type == = '<STR_LIT>' ; <EOL> / ** <EOL> * This type represents the   ` type ` of any   ` DatatableColumn ` in a   ` Datatable ` . <EOL> * / <EOL> export type DatatableColumnType = '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' ; <EOL> / ** <EOL> * This type represents a row in a   ` Datatable ` . <EOL> * / <EOL> export type DatatableRow = Record < string , any > ; <EOL> export interface DatatableColumnMeta { <EOL> type : DatatableColumnType ; field   ? : string ; index   ? : string ; params   ? : SerializableState ; source   ? : string ; sourceParams   ? : SerializableState ; <EOL> } <EOL> / ** <EOL> * This type represents the shape of a column in a   ` Datatable ` . <EOL> * / <EOL> export interface DatatableColumn { <EOL> id : string ; name : string ; meta : DatatableColumnMeta ; <EOL> } <EOL> / ** <EOL> * A   ` Datatable ` in Canvas is a unique structure that represents tabulated data . <EOL> * / <EOL> export interface Datatable { <EOL> type : typeof name ; columns : DatatableColumn [ ] ; rows : DatatableRow [ ] ; <EOL> } <EOL> export interface SerializedDatatable extends Datatable { <EOL> rows : string [ ] [ ] ; <EOL> } <EOL> interface RenderedDatatable { <EOL> datatable : Datatable ; paginate : boolean ; perPage : number ; showHeader : boolean ; <EOL> } <EOL> export const datatable = { <EOL> name , <EOL> validate : ( table ) = > { <EOL> if ( ! table . columns ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> if ( ! table . rows ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> } , <EOL> serialize : ( table ) = > { <EOL> const { <EOL> columns , <EOL> rows <EOL> } = table ; <EOL> return { <EOL> ... table , <EOL> rows : rows . map ( ( row ) = > { <EOL> return columns . map ( ( column ) = > row [ column . name ] ) ; <EOL> } ) , <EOL> } ; <EOL> } , <EOL> deserialize : ( table ) = > { <EOL> const { <EOL> columns , <EOL> rows <EOL> } = table ; <EOL> return { <EOL> ... table , <EOL> rows : rows . map ( ( row ) = > { <EOL> return zipObject ( map ( columns , '<STR_LIT>' ) , row ) ; <EOL> } ) , <EOL> } ; <EOL> } , <EOL> from : { <EOL> null : ( ) = > ( { <EOL> type : name , <EOL> meta : { } , <EOL> rows : [ ] , <EOL> columns : [ ] , <EOL> } ) , <EOL> pointseries : ( value ) = > ( { <EOL> type : name , <EOL> meta : { } , <EOL> rows : value . rows , <EOL> columns : map ( value . columns , ( val , colName ) = > { <EOL> return { <EOL> id : colName , <EOL> name : colName , <EOL> meta : { <EOL> type : val . type <EOL> } <EOL> } ; <EOL> } ) , <EOL> } ) , <EOL> } , <EOL> to : { <EOL> render : ( table ) : ExpressionValueRender < RenderedDatatable > = > ( { <EOL> type : '<STR_LIT>' , <EOL> as : '<STR_LIT>' , <EOL> value : { <EOL> datatable : table , <EOL> paginate : true , <EOL> perPage : <NUM_LIT> , <EOL> showHeader : true , <EOL> } , <EOL> } ) , <EOL> pointseries : ( table ) : PointSeries = > { <EOL> const validFields = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> const columns = table . columns . filter ( ( column ) = > validFields . includes ( column . id ) ) ; <EOL> const rows = table . rows . map ( ( row ) = > pick ( row , validFields ) ) ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> columns : columns . reduce < Record < string , <EOL> PointSeries [ '<STR_LIT>' ] > > ( ( acc , column ) = > { <EOL> acc [ column . name ] = { <EOL> type : column . meta . type , <EOL> expression : column . name , <EOL> role : '<STR_LIT>' , <EOL> } ; <EOL> return acc ; <EOL> } , { } ) , <EOL> rows , <EOL> } ; <EOL> } , <EOL> } , <EOL> } ; </s>
<s> import { <EOL> UnexpectedCalls , <EOL> UnmetExpectations <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpectationRepository <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getAllMocks , <EOL> getMockState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Mock <EOL> } from '<STR_LIT>' ; <EOL> export const verifyRepo = ( repository ) = > { <EOL> const unmetExpectations = repository . getUnmet ( ) ; <EOL> if ( unmetExpectations . length ) { <EOL> throw new UnmetExpectations ( unmetExpectations ) ; <EOL> } <EOL> const callStats = repository . getCallStats ( ) ; <EOL> if ( callStats . unexpected . size ) { <EOL> throw new UnexpectedCalls ( callStats . unexpected , unmetExpectations ) ; <EOL> } <EOL> } ; <EOL> throws throws example <EOL> export const verify = < T > ( mock ) : void = > { const { repository } = getMockState ( mock ) ; verifyRepo ( repository ) ; } ; see verify export const verifyAll = ( ) : void = > { getAllMocks ( ) . forEach ( ( [ mock ] ) = > { verify ( mock ) ; } ) ; } ; </s>
<s> import { <EOL> Component , <EOL> Input , <EOL> ChangeDetectionStrategy <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GameService <EOL> } from "<STR_LIT>" ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class TileComponent { <EOL> @ Input ( ) index ; <EOL> @ Input ( ) styles ; <EOL> @ Input ( ) type ; <EOL> @ Input ( ) sprite ; <EOL> constructor ( private game ) { } <EOL> getStyles ( ) { <EOL> return Object . assign ( { } , this . styles , { <EOL> left : this . index . x * this . game . tileSize + "<STR_LIT>" , <EOL> top : this . index . y * this . game . tileSize + "<STR_LIT>" , <EOL> width : this . game . tileSize + "<STR_LIT>" , <EOL> height : this . game . tileSize + "<STR_LIT>" <EOL> } ) ; <EOL> } <EOL> } </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> import { <EOL> JUSTIFY_CONTENT_ENUM_STR <EOL> } from '<STR_LIT>' ; <EOL> export const justifyContent = ( ) = > [ <EOL> [ new RegExp ( ` ^ justify - content - ( ? < justify > $ { JUSTIFY_CONTENT_ENUM_STR } ) $ ` ) , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> justify <EOL> } = groups as { <EOL> justify : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` justify - content :   $ { justify } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import moment from '<STR_LIT>' ; <EOL> import { <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeRange <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeBuckets <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> toAbsoluteDates <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> autoInterval <EOL> } from '<STR_LIT>' ; <EOL> export function getCalculateAutoTimeExpression ( getConfig ) { <EOL> return function calculateAutoTimeExpression ( range ) { <EOL> const dates = toAbsoluteDates ( range ) ; <EOL> if ( ! dates ) { <EOL> return ; <EOL> } <EOL> const buckets = new TimeBuckets ( { <EOL> '<STR_LIT>' : getConfig ( UI_SETTINGS . HISTOGRAM_MAX_BARS ) , <EOL> '<STR_LIT>' : getConfig ( UI_SETTINGS . HISTOGRAM_BAR_TARGET ) , <EOL> dateFormat : getConfig ( '<STR_LIT>' ) , <EOL> '<STR_LIT>' : getConfig ( '<STR_LIT>' ) , <EOL> } ) ; <EOL> buckets . setInterval ( autoInterval ) ; <EOL> buckets . setBounds ( { <EOL> min : moment ( dates . from ) , <EOL> max : moment ( dates . to ) , <EOL> } ) ; <EOL> return buckets . getInterval ( ) . expression ; <EOL> } ; <EOL> } </s>
<s> import debug from "<STR_LIT>" ; <EOL> import { <EOL> when <EOL> } from "<STR_LIT>" ; <EOL> import RootStore from "<STR_LIT>" ; <EOL> const log = debug ( "<STR_LIT>" ) ; <EOL> export const openStats = ( { <EOL> ui , <EOL> room <EOL> } ) = > ( ) = > { <EOL> log ( "<STR_LIT>" ) ; <EOL> ui . isStatsOpen = true ; <EOL> const timer = setInterval ( async ( ) = > { <EOL> const pc = room . getPeerConnection ( ) ; <EOL> if ( pc == = null ) { <EOL> return ; <EOL> } <EOL> pc . getStats ( ) . then ( ( statsReport ) = > ( room . rtcStats = statsReport ) ) . catch ( ( err ) = > log ( "<STR_LIT>" , err ) ) ; <EOL> } , <NUM_LIT> ) ; <EOL> when ( ( ) = >   ! ui . isStatsOpen , ( ) = > { <EOL> log ( "<STR_LIT>" ) ; <EOL> clearInterval ( timer ) ; <EOL> room . rtcStats = null ; <EOL> } ) ; <EOL> } ; <EOL> export const closeStats = ( { <EOL> ui <EOL> } ) = > ( ) = > { <EOL> log ( "<STR_LIT>" ) ; <EOL> ui . isStatsOpen = false ; <EOL> } ; </s>
<s> export const environment = { <EOL> production : false , <EOL> matomoConfig : { <EOL> scriptUrl : '<STR_LIT>' , <EOL> trackers : [ { <EOL> trackerUrl : '<STR_LIT>' , <EOL> siteId : <NUM_LIT> , <EOL> } , ] , <EOL> requireConsent : true , <EOL> routeTracking : { <EOL> enable : true , <EOL> } , <EOL> } , <EOL> } ; </s>
<s> import { <EOL> find <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IResponseAggConfig <EOL> } from '<STR_LIT>' ; <EOL> export const getPercentileValue = < TAggConfig extends IResponseAggConfig > ( agg , bucket ) = > { const { values } = bucket [ agg . parentId ] ; const percentile = find ( values , ( { key } ) = > key == = agg . key ) ; return percentile   ? percentile . value : NaN ; } ; </s>
<s> import React , { <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Image , <EOL> ScrollView , <EOL> StyleSheet , <EOL> Text , <EOL> TextStyle , <EOL> TouchableOpacity , <EOL> View , <EOL> ViewStyle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Button , <EOL> ButtonProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ModalHalfScreen , <EOL> ModalHalfScreenProps <EOL> } from '<STR_LIT>' ; <EOL> const closeIcon = require ( '<STR_LIT>' ) ; <EOL> const styles = StyleSheet . create ( { <EOL> button : { <EOL> margin : <NUM_LIT> <EOL> } , <EOL> modalHeader : { <EOL> flexDirection : '<STR_LIT>' , <EOL> alignItems : '<STR_LIT>' <EOL> } , <EOL> modalTitle : { <EOL> flexGrow : <NUM_LIT> , <EOL> textAlign : '<STR_LIT>' , <EOL> fontSize : <NUM_LIT> , <EOL> paddingVertical : <NUM_LIT> <EOL> } , <EOL> closeBtn : { <EOL> position : '<STR_LIT>' , <EOL> right : <NUM_LIT> <EOL> } , <EOL> closeIcon : { <EOL> margin : <NUM_LIT> , <EOL> width : <NUM_LIT> , <EOL> height : <NUM_LIT> <EOL> } <EOL> } ) ; <EOL> export interface NestingButtonsProps { <EOL> showMoreTitle : string ; buttonsProps : ButtonProps [ ] ; <EOL> default maxCount   ? : number ; showMoreButtonProps   ? : Omit < ButtonProps , <EOL> '<STR_LIT>' | '<STR_LIT>' > ; containerStyle   ? : ViewStyle ; modalContainerStyle   ? : ViewStyle ; modalTitle   ? : string ; modalTitleStyle   ? : TextStyle ; modalProps   ? : Omit < ModalHalfScreenProps , <EOL> '<STR_LIT>' | '<STR_LIT>' > ; <EOL> } <EOL> export const NestingButtons = React . memo ( props = > { <EOL> const [ modalVisible , setModalVisibile ] = useState < boolean > ( false ) ; <EOL> const toggleModal = ( ) = > setModalVisibile ( ! modalVisible ) ; <EOL> const { <EOL> buttonsProps , <EOL> showMoreTitle , <EOL> showMoreButtonProps , <EOL> modalProps , <EOL> containerStyle , <EOL> maxCount = <NUM_LIT> , <EOL> modalTitle , <EOL> modalTitleStyle , <EOL> modalContainerStyle <EOL> } = props ; <EOL> const buttons = buttonsProps . map ( ( buttonProps , index ) = > ( < Button key = { index } { ... buttonProps } style = { [ styles . button , buttonProps . style ] } / > ) ) ; <EOL> if ( buttons . length <= maxCount ) { <EOL> return ( < View style = { containerStyle } > { buttons } < / View > ) ; } return ( < View style = { containerStyle } > < Button { ... showMoreButtonProps } onPress = { toggleModal } title = { showMoreTitle } style = { [ styles . button , showMoreButtonProps   ? . style ] } / > < ModalHalfScreen visible = { modalVisible } onRequestClose = { toggleModal } { ... modalProps } > < ScrollView style = { modalContainerStyle } > < View style = { styles . modalHeader } > < Text style = { [ styles . modalTitle , modalTitleStyle ] } > { modalTitle } < / Text > < TouchableOpacity onPress = { toggleModal } style = { styles . closeBtn } > < Image source = { closeIcon } style = { styles . closeIcon } / > < / TouchableOpacity > < / View > { buttons } < / ScrollView > < / ModalHalfScreen > < / View > ) ; } ) ; </s>
<s> import { <EOL> filter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter , <EOL> compareFilters , <EOL> COMPARE_ALL_OPTIONS <EOL> } from '<STR_LIT>' ; <EOL> const isEnabled = ( f ) = > f & & f . meta & &   ! f . meta . disabled ; <EOL> returns { <EOL> bool <EOL> } <EOL> export const onlyDisabledFiltersChanged = ( newFilters   ? , oldFilters   ? ) = > { <EOL> const newEnabledFilters = filter ( newFilters | | [ ] , isEnabled ) ; <EOL> const oldEnabledFilters = filter ( oldFilters | | [ ] , isEnabled ) ; <EOL> return compareFilters ( oldEnabledFilters , newEnabledFilters , COMPARE_ALL_OPTIONS ) ; <EOL> } ; </s>
<s> import { <EOL> Stream , <EOL> MemoryStream <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DOMSource , <EOL> VNode , <EOL> div <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HistoryInput , <EOL> Location <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> resolve <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> pluck <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GithubSource <EOL> } from '<STR_LIT>' ; <EOL> export interface Sources { <EOL> dom : DOMSource ; history : MemoryStream < Location > ; github : GithubSource ; <EOL> } <EOL> export interface Sinks { <EOL> dom : Stream < VNode > ; history : Stream < HistoryInput | string > ; github : Stream < string > ; <EOL> } <EOL> const xs = Stream ; <EOL> export const App = ( sources ) : Sinks = > { <EOL> const app $ = sources . history . map ( location = > resolve ( location . pathname ) ) . map ( ( { <EOL> getComponent , <EOL> getLayout , <EOL> ... resolution <EOL> } ) = > xs . fromPromise ( getComponent ( ) . then ( Component = > Component ( { <EOL> ... sources , <EOL> ... ( resolution . sources | | { } ) <EOL> } ) ) . then ( component = >   ! getLayout   ? Promise . resolve ( component ) : getLayout ( ) . then ( Layout = > Layout ( { <EOL> ... sources , <EOL> component <EOL> } ) ) ) ) ) . flatten ( ) ; <EOL> return { <EOL> dom : pluck ( app $ , app $ = > app $ . dom ) , <EOL> history : pluck ( app $ , app $ = > app $ . history ) , <EOL> github : pluck ( app $ , app $ = > app $ . github ) <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createEntityAdapter , <EOL> EntityAdapter , <EOL> EntityState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ReviewerStatistics <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fromUserActions <EOL> } from '<STR_LIT>' ; <EOL> export const REVIEWERS_FEATURE_KEY = '<STR_LIT>' ; <EOL> export interface ReviewersStatisticsEntityState extends EntityState < ReviewerStatistics > { } <EOL> export interface ReviewersStatisticsPartialState { <EOL> readonly [ REVIEWERS_FEATURE_KEY ] : UserState ; <EOL> } <EOL> export const adapter = createEntityAdapter < ReviewerStatistics > ( ) ; <EOL> export interface UserState { <EOL> reviewersStatisticsCollection : ReviewersStatisticsEntityState ; reviewersStatisticsCollectionLoading : boolean ; reviewersStatisticsCollectionLoadError : HttpErrorResponse | null ; <EOL> } <EOL> export const initialState = { <EOL> reviewersStatisticsCollection : adapter . getInitialState ( ) , <EOL> reviewersStatisticsCollectionLoading : false , <EOL> reviewersStatisticsCollectionLoadError : null <EOL> } ; <EOL> export function reviewersReducer ( state = initialState , action ) { <EOL> switch ( action . type ) { <EOL> case fromUserActions . Types . GetReviewersStatisticsCollection : { <EOL> state = { <EOL> ... state , <EOL> reviewersStatisticsCollection : adapter . getInitialState ( ) , <EOL> reviewersStatisticsCollectionLoading : true , <EOL> reviewersStatisticsCollectionLoadError : null <EOL> } ; <EOL> break ; <EOL> } <EOL> case fromUserActions . Types . GetReviewersStatisticsCollectionFail : { <EOL> state = { <EOL> ... state , <EOL> reviewersStatisticsCollection : adapter . getInitialState ( ) , <EOL> reviewersStatisticsCollectionLoading : false , <EOL> reviewersStatisticsCollectionLoadError : action . payload <EOL> } ; <EOL> break ; <EOL> } <EOL> case fromUserActions . Types . GetReviewersStatisticsCollectionSuccess : { <EOL> state = { <EOL> ... state , <EOL> reviewersStatisticsCollection : adapter . addAll ( action . payload , state . reviewersStatisticsCollection ) , <EOL> reviewersStatisticsCollectionLoading : false , <EOL> reviewersStatisticsCollectionLoadError : null <EOL> } ; <EOL> break ; <EOL> } <EOL> } <EOL> return state ; <EOL> } <EOL> export const { <EOL> selectAll <EOL> } = adapter . getSelectors ( ) ; </s>
<s> import * as coreClient from "<STR_LIT>" ; <EOL> import * as coreAuth from "<STR_LIT>" ; <EOL> import { <EOL> SystemAssignedIdentitiesImpl , <EOL> OperationsImpl , <EOL> UserAssignedIdentitiesImpl <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> SystemAssignedIdentities , <EOL> Operations , <EOL> UserAssignedIdentities <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ManagedServiceIdentityClientOptionalParams <EOL> } from "<STR_LIT>" ; <EOL> export class ManagedServiceIdentityClient extends coreClient . ServiceClient { <EOL>         $ host : string ; apiVersion : string ; subscriptionId : string ; param credentials param subscriptionId param options constructor ( credentials , subscriptionId , options   ? ) { <EOL> if ( credentials == = undefined ) { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> if ( subscriptionId == = undefined ) { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> if ( ! options ) { <EOL> options = { } ; <EOL> } <EOL> const defaults = { <EOL> requestContentType : "<STR_LIT>" , <EOL> credential : credentials <EOL> } ; <EOL> const packageDetails =   ` azsdk - js - msi - resource - manager / <NUM_LIT> <NUM_LIT> - beta <NUM_LIT> ` ; <EOL> const userAgentPrefix = options . userAgentOptions & & options . userAgentOptions . userAgentPrefix   ?   ` $ { options . userAgentOptions . userAgentPrefix }   $ { packageDetails } ` :   ` $ { packageDetails } ` ; <EOL> const optionsWithDefaults = { <EOL> ... defaults , <EOL> ... options , <EOL> userAgentOptions : { <EOL> userAgentPrefix <EOL> } , <EOL> baseUri : options . endpoint | | "<STR_LIT>" <EOL> } ; <EOL> super ( optionsWithDefaults ) ; <EOL> this . subscriptionId = subscriptionId ; <EOL> this . $ host = options . $ host | | "<STR_LIT>" ; <EOL> this . apiVersion = options . apiVersion | | "<STR_LIT>" ; <EOL> this . systemAssignedIdentities = new SystemAssignedIdentitiesImpl ( this ) ; <EOL> this . operations = new OperationsImpl ( this ) ; <EOL> this . userAssignedIdentities = new UserAssignedIdentitiesImpl ( this ) ; <EOL> } <EOL> systemAssignedIdentities : SystemAssignedIdentities ; operations : Operations ; userAssignedIdentities : UserAssignedIdentities ; <EOL> } </s>
<s> import { <EOL> BarcodeFormat <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MultiFormatReader <EOL> } from '<STR_LIT>' ; <EOL> import AbstractBlackBoxSpec from '<STR_LIT>' ; <EOL> / ** <EOL> * Tests PDF417Reader against more sample images . <EOL> class PDF417BlackBox3Spec extends AbstractBlackBoxSpec { public constructor ( ) { super ( '<STR_LIT>' , new MultiFormatReader ( ) , BarcodeFormat . PDF_417 ) ; this . addTestWithMax ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; this . addTestWithMax ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; } } describe ( '<STR_LIT>' , ( ) = > { it ( '<STR_LIT>' , async ( ) = > { const test = new PDF417BlackBox3Spec ( ) ; await test . testBlackBox ( ) ; } ) ; } ) ; </s>
<s> import { <EOL> strict as assert <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> stringToBuffer <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ISnapshotTree <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> IDocumentStorageService <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ChannelStorageService <EOL> } from "<STR_LIT>" ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const tree = { <EOL> blobs : { } , <EOL> commits : { } , <EOL> trees : { } <EOL> } ; <EOL> const storage = { <EOL> readBlob : async ( id ) = > { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> } ; <EOL> const ss = new ChannelStorageService ( tree , storage ) ; <EOL> assert . strictEqual ( await ss . contains ( "<STR_LIT>" ) , false ) ; <EOL> assert . deepStrictEqual ( await ss . list ( "<STR_LIT>" ) , [ ] ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const tree = { <EOL> blobs : { <EOL> foo : "<STR_LIT>" <EOL> } , <EOL> commits : { } , <EOL> trees : { } <EOL> } ; <EOL> const storage = { <EOL> readBlob : async ( id ) = > { <EOL> return stringToBuffer ( id , "<STR_LIT>" ) ; <EOL> } <EOL> } ; <EOL> const ss = new ChannelStorageService ( tree , storage ) ; <EOL> assert . strictEqual ( await ss . contains ( "<STR_LIT>" ) , true ) ; <EOL> assert . deepStrictEqual ( await ss . list ( "<STR_LIT>" ) , [ "<STR_LIT>" ] ) ; <EOL> assert . deepStrictEqual ( await ss . readBlob ( "<STR_LIT>" ) , stringToBuffer ( "<STR_LIT>" , "<STR_LIT>" ) ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const tree = { <EOL> blobs : { } , <EOL> commits : { } , <EOL> trees : { <EOL> nested : { <EOL> blobs : { <EOL> foo : "<STR_LIT>" <EOL> } , <EOL> commits : { } , <EOL> trees : { } <EOL> } <EOL> } <EOL> } ; <EOL> const storage = { <EOL> readBlob : async ( id ) = > { <EOL> return stringToBuffer ( id , "<STR_LIT>" ) ; <EOL> } <EOL> } ; <EOL> const ss = new ChannelStorageService ( tree , storage ) ; <EOL> assert . strictEqual ( await ss . contains ( "<STR_LIT>" ) , true ) ; <EOL> assert . deepStrictEqual ( await ss . list ( "<STR_LIT>" ) , [ "<STR_LIT>" ] ) ; <EOL> assert . deepStrictEqual ( await ss . readBlob ( "<STR_LIT>" ) , stringToBuffer ( "<STR_LIT>" , "<STR_LIT>" ) ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import Context from '<STR_LIT>' ; <EOL> import util from '<STR_LIT>' ; <EOL> import { <EOL> getData <EOL> } from '<STR_LIT>' ; <EOL> const { <EOL> deepClone <EOL> } = util . data ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> const options = { <EOL> width : <NUM_LIT> , <EOL> height : <NUM_LIT> , <EOL> contextWidth : <NUM_LIT> , <EOL> contextHeight : <NUM_LIT> , <EOL> devicePixelRatio : <NUM_LIT> <EOL> } ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const data = getData ( ) ; <EOL> ctx . clearRect ( <NUM_LIT> , <NUM_LIT> , opts . contextWidth , opts . contextHeight ) ; <EOL> ctx . setFillStyle ( '<STR_LIT>' ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , opts . contextWidth , opts . contextHeight ) ; <EOL> data . elements . forEach ( ele = > { <EOL> ctx . setFillStyle ( ele . desc . color ) ; <EOL> ctx . fillRect ( ele . x , ele . y , ele . w , ele . h ) ; <EOL> } ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> expect ( ctx . getSize ( ) ) . toStrictEqual ( opts ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const newOpts = { <EOL> width : <NUM_LIT> , <EOL> height : <NUM_LIT> , <EOL> contextWidth : <NUM_LIT> , <EOL> contextHeight : <NUM_LIT> , <EOL> devicePixelRatio : <NUM_LIT> , <EOL> } ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . resetSize ( newOpts ) ; <EOL> expect ( ctx . getSize ( ) ) . toStrictEqual ( newOpts ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const num = <NUM_LIT> ; <EOL> expect ( ctx . calcDeviceNum ( num ) ) . toStrictEqual ( opts . devicePixelRatio * num ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const num = <NUM_LIT> ; <EOL> expect ( ctx . calcScreenNum ( num ) ) . toStrictEqual ( num / opts . devicePixelRatio ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const transform = { <EOL> scale : <NUM_LIT> , <EOL> scrollX : <NUM_LIT> , <EOL> scrollY : - <NUM_LIT> , <EOL> } ; <EOL> ctx . setTransform ( deepClone ( transform ) ) ; <EOL> expect ( ctx . getTransform ( ) ) . toStrictEqual ( deepClone ( transform ) ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> expect ( ctx . getTransform ( ) ) . toStrictEqual ( { <EOL> scale : <NUM_LIT> , <EOL> scrollX : <NUM_LIT> , <EOL> scrollY : <NUM_LIT> , <EOL> } ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const color = '<STR_LIT>' ; <EOL> ctx . setFillStyle ( color ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , opts . contextWidth , opts . contextHeight ) ; <EOL> expect ( ctx2d . fillStyle ) . toStrictEqual ( color ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . arc ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Math . PI * <NUM_LIT> , true ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . rect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . clearRect ( <NUM_LIT> , <NUM_LIT> , opts . contextWidth , opts . contextHeight ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . beginPath ( ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . closePath ( ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . lineTo ( <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . moveTo ( <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . arcTo ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , Math . PI * <NUM_LIT> ) ; <EOL> ctx . fill ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const lineWidth = <NUM_LIT> ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . setLineWidth ( lineWidth ) ; <EOL> expect ( ctx2d . lineWidth ) . toStrictEqual ( lineWidth * opts . devicePixelRatio ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const lineDash = [ <NUM_LIT> , <NUM_LIT> ] ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . setLineDash ( lineDash ) ; <EOL> expect ( ctx2d . getLineDash ( ) ) . toStrictEqual ( lineDash . map ( n = > n * opts . devicePixelRatio ) ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const color = '<STR_LIT>' ; <EOL> ctx . setStrokeStyle ( color ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , opts . contextWidth , opts . contextHeight ) ; <EOL> expect ( ctx2d . strokeStyle ) . toStrictEqual ( color ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const x = <NUM_LIT> ; <EOL> const y = <NUM_LIT> ; <EOL> const w = <NUM_LIT> ; <EOL> const h = <NUM_LIT> ; <EOL> ctx . beginPath ( ) ; <EOL> ctx . moveTo ( x , y ) ; <EOL> ctx . lineTo ( x + w , y ) ; <EOL> ctx . lineTo ( x + w , y + h ) ; <EOL> ctx . lineTo ( x , y + h ) ; <EOL> ctx . lineTo ( x , y ) ; <EOL> ctx . closePath ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( ctx . isPointInPath ( <NUM_LIT> , <NUM_LIT> ) ) . toStrictEqual ( ctx2d . isPointInPath ( <NUM_LIT> * opts . devicePixelRatio , <NUM_LIT> * opts . devicePixelRatio ) ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . setTransform ( { <EOL> scale : <NUM_LIT> , <EOL> scrollX : <NUM_LIT> , <EOL> scrollY : <NUM_LIT> , <EOL> } ) ; <EOL> ctx . beginPath ( ) ; <EOL> ctx . rect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . closePath ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( ctx . isPointInPathWithoutScroll ( <NUM_LIT> , <NUM_LIT> ) ) . toStrictEqual ( ctx2d . isPointInPath ( <NUM_LIT> * opts . devicePixelRatio , <NUM_LIT> * opts . devicePixelRatio ) ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const color = '<STR_LIT>' ; <EOL> ctx . setStrokeStyle ( color ) ; <EOL> expect ( ctx2d . strokeStyle ) . toStrictEqual ( color ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . rect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . stroke ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const x = <NUM_LIT> ; <EOL> const y = <NUM_LIT> ; <EOL> ctx . translate ( x , y ) ; <EOL> ctx . rect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . stroke ( ) ; <EOL> ctx . translate ( - x , - y ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const radian = Math . PI / <NUM_LIT> ; <EOL> ctx . rotate ( radian ) ; <EOL> ctx . rect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . stroke ( ) ; <EOL> ctx . rotate ( - radian ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const img = new Image ( ) ; <EOL> const dx = <NUM_LIT> ; <EOL> const dy = <NUM_LIT> ; <EOL> const dw = <NUM_LIT> ; <EOL> const dh = <NUM_LIT> ; <EOL> const sx = <NUM_LIT> ; <EOL> const sy = <NUM_LIT> ; <EOL> const sw = <NUM_LIT> ; <EOL> const sh = <NUM_LIT> ; <EOL> ctx . drawImage ( img , dx , dy ) ; <EOL> ctx . drawImage ( img , dx , dy , dw , dh ) ; <EOL> ctx . drawImage ( img , sx , sy , sw , sh , dx , dy , dw , dh ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const img = new Image ( ) ; <EOL> const pattern = ctx . createPattern ( img , '<STR_LIT>' ) as CanvasPattern ; <EOL> ctx . setFillStyle ( pattern ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( ctx2d . fillStyle ) . toStrictEqual ( pattern ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . setFont ( { <EOL> fontSize : <NUM_LIT> <EOL> } ) ; <EOL> const size = ctx . measureText ( '<STR_LIT>' ) ; <EOL> expect ( size . width ) . toStrictEqual ( <NUM_LIT> ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const textAlign = '<STR_LIT>' ; <EOL> ctx . setTextAlign ( textAlign ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , opts . contextWidth , opts . contextHeight ) ; <EOL> expect ( ctx2d . textAlign ) . toStrictEqual ( textAlign ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . fillText ( '<STR_LIT>' , <NUM_LIT> , <NUM_LIT> ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const fontSize = <NUM_LIT> ; <EOL> const fontFamily = '<STR_LIT>' ; <EOL> const fontWeight = '<STR_LIT>' ; <EOL> ctx . setFont ( { <EOL> fontSize , <EOL> fontFamily , <EOL> fontWeight <EOL> } ) ; <EOL> expect ( ctx2d . font ) . toStrictEqual ( [ fontWeight , ( fontSize * opts . devicePixelRatio ) + '<STR_LIT>' , fontFamily ] . join ( '<STR_LIT>' ) ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const textBaseline = '<STR_LIT>' ; <EOL> ctx . setTextBaseline ( textBaseline ) ; <EOL> expect ( ctx2d . textBaseline ) . toStrictEqual ( textBaseline ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const globalAlpha = <NUM_LIT> ; <EOL> ctx . setGlobalAlpha ( globalAlpha ) ; <EOL> expect ( ctx2d . globalAlpha ) . toStrictEqual ( globalAlpha ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . save ( ) ; <EOL> ctx . setFillStyle ( '<STR_LIT>' ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . restore ( ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> ctx . save ( ) ; <EOL> ctx . setFillStyle ( '<STR_LIT>' ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . restore ( ) ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> const opts = deepClone ( options ) ; <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = opts . contextWidth ; <EOL> canvas . height = opts . contextHeight ; <EOL> const ctx2d = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const ctx = new Context ( ctx2d , opts ) ; <EOL> const scaleX = <NUM_LIT> ; <EOL> const scaleY = <NUM_LIT> ; <EOL> ctx . scale ( scaleX , scaleY ) ; <EOL> ctx . rect ( <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ) ; <EOL> ctx . stroke ( ) ; <EOL> const calls = ctx2d . __getDrawCalls ( ) ; <EOL> expect ( calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import fetchPonyfill from "<STR_LIT>" ; <EOL> import { <EOL> VERSION <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> AlchemySendFunction <EOL> } from "<STR_LIT>" ; <EOL> const { <EOL> fetch , <EOL> Headers <EOL> } = fetchPonyfill ( ) ; <EOL> const ALCHEMY_HEADERS = new Headers ( { <EOL> Accept : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : VERSION , <EOL> } ) ; <EOL> const RATE_LIMIT_STATUS = <NUM_LIT> ; <EOL> export function makeHttpSender ( url ) { <EOL> return async ( request ) = > { <EOL> const response = await fetch ( url , { <EOL> method : "<STR_LIT>" , <EOL> headers : ALCHEMY_HEADERS , <EOL> body : JSON . stringify ( request ) , <EOL> } ) ; <EOL> const { <EOL> status <EOL> } = response ; <EOL> switch ( status ) { <EOL> case <NUM_LIT> : <EOL> return { <EOL> type : "<STR_LIT>" , response : await response . json ( ) <EOL> } ; <EOL> case RATE_LIMIT_STATUS : <EOL> return { <EOL> type : "<STR_LIT>" <EOL> } ; <EOL> case <NUM_LIT> : <EOL> return { <EOL> type : "<STR_LIT>" , status : <NUM_LIT> , message : "<STR_LIT>" , <EOL> } ; <EOL> default : <EOL> return { <EOL> status , type : "<STR_LIT>" , message : ( await response . json ( ) ) . message , <EOL> } ; <EOL> } <EOL> } ; <EOL> } </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> export const textEllipsis = ( ) = > [ <EOL> [ / ^ ( text - ) ? ellipsis ( - ( ? < value > [ <NUM_LIT> - <NUM_LIT> ] \ d * ) ) ? $ / , ( { <EOL> groups <EOL> } ) = > { <EOL> let { <EOL> value <EOL> } = groups as { <EOL> value   ? : string ; <EOL> } ; <EOL> if ( Number ( value ) == = <NUM_LIT> ) { <EOL> value = undefined ; <EOL> } <EOL> if ( value == = undefined ) { <EOL> return ConvertToCssObject ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , ] ) ; <EOL> } <EOL> return ConvertToCssObject ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ,   ` - webkit - line - clamp :   $ { value } ` , '<STR_LIT>' , ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> / ** <EOL> * Copyright ( c ) <NUM_LIT> , <NUM_LIT> Oracle and / or its affiliates . All rights reserved . <EOL> * This software is dual - licensed to you under the Universal Permissive License ( UPL ) <NUM_LIT> as shown at https : // oss . oracle . com / licenses / upl or Apache License <NUM_LIT> as shown at http : // www . apache . org / licenses / LICENSE - <NUM_LIT> . You may choose either license . <EOL> * Utility method to check if environment is node or browser <EOL> * / <EOL> import CircuitBreaker from "<STR_LIT>" ; <EOL> import { <EOL> ClientConfiguration <EOL> } from "<STR_LIT>" ; <EOL> export function isBrowser ( ) { <EOL> if ( typeof window == = "<STR_LIT>" ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> export function isEmpty ( obj ) { <EOL> return Object . keys ( obj ) . length == = <NUM_LIT> ; <EOL> } <EOL> export function checkNotNull ( value , msg ) { <EOL> if ( value ) { <EOL> return value ; <EOL> } <EOL> throw new Error ( msg ) ; <EOL> } <EOL> export function isCircuitBreakerSystemEnabled ( clientConfiguration ) { <EOL> const clientLevelCheck = clientConfiguration & & clientConfiguration . circuitBreaker & & clientConfiguration . circuitBreaker . noCircuit ; <EOL> if ( clientLevelCheck | |   ! CircuitBreaker . EnableGlobalCircuitBreaker | | CircuitBreaker . EnableDefaultCircuitBreaker == = "<STR_LIT>" ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } </s>
<s> import { <EOL> CustomIntegrationsPlugin <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> coreMock <EOL> } from '<STR_LIT>' ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> beforeEach ( ( ) = > { } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> let mockCoreSetup ; <EOL> let initContext ; <EOL> beforeEach ( ( ) = > { <EOL> mockCoreSetup = coreMock . createSetup ( ) ; <EOL> initContext = coreMock . createPluginInitializerContext ( ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , ( ) = > { <EOL> const setup = new CustomIntegrationsPlugin ( initContext ) . setup ( mockCoreSetup ) ; <EOL> expect ( setup ) . toHaveProperty ( '<STR_LIT>' ) ; <EOL> expect ( setup ) . toHaveProperty ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , ( ) = > { <EOL> const setup = new CustomIntegrationsPlugin ( initContext ) . setup ( mockCoreSetup ) ; <EOL> expect ( setup . getAppendCustomIntegrations ( ) ) . toEqual ( [ { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , { <EOL> id : '<STR_LIT>' , <EOL> title : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> shipper : '<STR_LIT>' , <EOL> uiInternalPath : '<STR_LIT>' , <EOL> isBeta : false , <EOL> icons : [ { <EOL> type : '<STR_LIT>' <EOL> } ] , <EOL> categories : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , ] ) ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import * as vscode from "<STR_LIT>" ; <EOL> import * as DocumentSymbolUtils from "<STR_LIT>" ; <EOL> import * as TestUtils from "<STR_LIT>" ; <EOL> suite ( "<STR_LIT>" , ( ) = > { <EOL> test ( "<STR_LIT>" , async ( ) = > { <EOL> const docUri = TestUtils . getDocUri ( "<STR_LIT>" ) ; <EOL> vscode . window . showInformationMessage ( ` Starting tests using based file :   $ { docUri } ` ) ; <EOL> DocumentSymbolUtils . testDocumentSymbols ( docUri , [ { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . Module <EOL> } , { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . Number <EOL> } , { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . String <EOL> } , { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . Function <EOL> } , { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . Variable , <EOL> children : [ { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . Number <EOL> } , { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . Number <EOL> } , { <EOL> name : "<STR_LIT>" , <EOL> kind : vscode . SymbolKind . Number <EOL> } , ] <EOL> } , ] ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> circle , <EOL> geoJSON , <EOL> icon , <EOL> latLng , <EOL> Layer , <EOL> marker , <EOL> polygon , <EOL> tileLayer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> LeafletLayersDemoModel <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' <EOL> } ) export class LeafletLayersDemoComponent { <EOL> LAYER_OCM = { <EOL> id : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> enabled : true , <EOL> layer : tileLayer ( '<STR_LIT>' , { <EOL> maxZoom : <NUM_LIT> , <EOL> attribution : '<STR_LIT>' <EOL> } ) <EOL> } ; <EOL> LAYER_OSM = { <EOL> id : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> enabled : false , <EOL> layer : tileLayer ( '<STR_LIT>' , { <EOL> maxZoom : <NUM_LIT> , <EOL> attribution : '<STR_LIT>' <EOL> } ) <EOL> } ; <EOL> circle = { <EOL> id : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> enabled : true , <EOL> layer : circle ( [ <NUM_LIT> , - <NUM_LIT> ] , { <EOL> radius : <NUM_LIT> <EOL> } ) <EOL> } ; <EOL> polygon = { <EOL> id : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> enabled : true , <EOL> layer : polygon ( [ <EOL> [ <NUM_LIT> , - <NUM_LIT> ] , <EOL> [ <NUM_LIT> , - <NUM_LIT> ] , <EOL> [ <NUM_LIT> , - <NUM_LIT> ] <EOL> ] ) <EOL> } ; <EOL> square = { <EOL> id : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> enabled : true , <EOL> layer : polygon ( [ <EOL> [ <NUM_LIT> , - <NUM_LIT> ] , <EOL> [ <NUM_LIT> , - <NUM_LIT> ] , <EOL> [ <NUM_LIT> , - <NUM_LIT> ] , <EOL> [ <NUM_LIT> , - <NUM_LIT> ] <EOL> ] ) <EOL> } ; <EOL> marker = { <EOL> id : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> enabled : true , <EOL> layer : marker ( [ <NUM_LIT> , - <NUM_LIT> ] , { <EOL> icon : icon ( { <EOL> iconSize : [ <NUM_LIT> , <NUM_LIT> ] , <EOL> iconAnchor : [ <NUM_LIT> , <NUM_LIT> ] , <EOL> iconUrl : '<STR_LIT>' , <EOL> iconRetinaUrl : '<STR_LIT>' , <EOL> shadowUrl : '<STR_LIT>' <EOL> } ) <EOL> } ) <EOL> } ; <EOL> geoJSON = { <EOL> id : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> enabled : true , <EOL> layer : geoJSON ( ( { <EOL> type : '<STR_LIT>' , <EOL> coordinates : [ <EOL> [ <EOL> [ - <NUM_LIT> , <NUM_LIT> ] , <EOL> [ - <NUM_LIT> , <NUM_LIT> ] , <EOL> [ - <NUM_LIT> , <NUM_LIT> ] , <EOL> [ - <NUM_LIT> , <NUM_LIT> ] <EOL> ] <EOL> ] <EOL> } ) as any , { <EOL> style : ( ) = > ( { <EOL> color : '<STR_LIT>' <EOL> } ) <EOL> } ) <EOL> } ; <EOL> model = new LeafletLayersDemoModel ( [ this . LAYER_OSM , this . LAYER_OCM ] , this . LAYER_OCM . id , [ this . circle , this . polygon , this . square , this . marker , this . geoJSON ] ) ; <EOL> layers : Layer [ ] ; <EOL> layersControl = { <EOL> baseLayers : { <EOL> '<STR_LIT>' : this . LAYER_OSM . layer , <EOL> '<STR_LIT>' : this . LAYER_OCM . layer <EOL> } , <EOL> overlays : { <EOL> Circle : this . circle . layer , <EOL> Square : this . square . layer , <EOL> Polygon : this . polygon . layer , <EOL> Marker : this . marker . layer , <EOL> GeoJSON : this . geoJSON . layer <EOL> } <EOL> } ; <EOL> options = { <EOL> zoom : <NUM_LIT> , <EOL> center : latLng ( <NUM_LIT> , - <NUM_LIT> ) <EOL> } ; <EOL> constructor ( ) { <EOL> this . apply ( ) ; <EOL> } <EOL> apply ( ) { <EOL> const baseLayer = this . model . baseLayers . find ( ( l ) = > ( l . id == = this . model . baseLayer ) ) ; <EOL> const newLayers = this . model . overlayLayers . filter ( ( l ) = > l . enabled ) . map ( ( l ) = > l . layer ) ; <EOL> newLayers . unshift ( baseLayer . layer ) ; <EOL> this . layers = newLayers ; <EOL> return false ; <EOL> } <EOL> } </s>
<s> import { <EOL> KvsStorage <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> kvsIndexedDB , <EOL> KvsIndexedDBOptions <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> KvsEnvStorageOptions , <EOL> KvsEnvStorageSchema <EOL> } from "<STR_LIT>" ; <EOL> export const kvsEnvStorage = async < Schema extends KvsEnvStorageSchema > ( options ) : Promise < KvsStorage < Schema > > = > { <EOL> return kvsIndexedDB ( options ) ; <EOL> } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import ReactDOM from '<STR_LIT>' ; <EOL> import { <EOL> Task <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> function App ( ) { <EOL> return < Task / > ; <EOL> } <EOL> ReactDOM . render ( < App / > , document . getElementById ( '<STR_LIT>' ) ) ; </s>
<s> import type { <EOL> ParsingExtension <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> named , <EOL> forKey , <EOL> validateOptions <EOL> } from '<STR_LIT>' ; <EOL> import isEqual from '<STR_LIT>' ; / ** Checks if two values are equal * / <EOL> export function eqDirective ( ) { <EOL> return named ( '<STR_LIT>' , forKey ( '<STR_LIT>' , validateOptions ( ( SchemaBuilder ) = > SchemaBuilder . arraySchema ( SchemaBuilder . fromJsonSchema ( { } ) ) , ( values ) = > async ( parse ) = > { <EOL> for ( const a of values ) { <EOL> for ( const b of values ) { <EOL> if ( a == = b ) continue ; <EOL> if ( isEqual ( a , b ) ) continue ; <EOL> return parse ( false , { <EOL> shouldFlatten : true <EOL> } ) ; <EOL> } <EOL> } <EOL> return parse ( true , { <EOL> shouldFlatten : true <EOL> } ) ; <EOL> } ) ) ) ; <EOL> } </s>
<s> import { <EOL> Component , <EOL> OnInit , <EOL> Input <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Validators , <EOL> FormGroup , <EOL> FormControl <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> matchPasswords <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> errorCodes <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> } ) export class PasswordInputComponent implements OnInit { <EOL> @ Input ( ) form : FormGroup ; <EOL> constructor ( ) { } <EOL> ngOnInit ( ) { <EOL> this . form . addControl ( '<STR_LIT>' , new FormControl ( '<STR_LIT>' , Validators . compose ( [ Validators . required , Validators . pattern ( errorCodes . password . regex . regex ) ] ) ) ) ; <EOL> this . form . addControl ( '<STR_LIT>' , new FormControl ( '<STR_LIT>' , Validators . required ) ) ; <EOL> this . form . setValidators ( matchPasswords ( '<STR_LIT>' , '<STR_LIT>' ) ) ; <EOL> } <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import type { <EOL> IndexPatternSelectProps <EOL> } from '<STR_LIT>' ; <EOL> const Fallback = ( ) = > < div / > ; <EOL> const LazyIndexPatternSelect = React . lazy ( ( ) = > import ( '<STR_LIT>' ) ) ; <EOL> export const IndexPatternSelect = ( props ) = > ( < React . Suspense fallback = { < Fallback / > } > < LazyIndexPatternSelect { ... props } / > < / React . Suspense > ) ; export * from '<STR_LIT>' ; export type { IndexPatternSelectProps } from '<STR_LIT>' ; </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormBuilder , <EOL> FormGroup , <EOL> ValidationErrors <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormData <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeUnit <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class TimeInputService { <EOL> constructor ( private fb ) { } <EOL> getFormConfiguration ( ) { <EOL> return this . fb . group ( { <EOL> time : null , <EOL> unit : Number ( TimeUnit . Hour ) <EOL> } ) ; <EOL> } <EOL> getUnits ( ) { <EOL> return Object . entries ( TimeUnit ) . map ( ( [ key , hours ] ) = > ( { <EOL> key , <EOL> value : Number ( hours ) <EOL> } ) ) ; <EOL> } <EOL> getOutputValue ( values ) { <EOL> return Number ( values . time ) * Number ( values . unit ) ; <EOL> } <EOL> externalValueUpdate ( formHandle , value ) { <EOL> if ( value ) { <EOL> const [ inp , unit ] = this . getWithTimeUnit ( value ) ; <EOL> const s = TimeUnit . Hour ; <EOL> formHandle . get ( '<STR_LIT>' ) . setValue ( inp ) ; <EOL> formHandle . get ( '<STR_LIT>' ) . setValue ( Number ( unit ) ) ; <EOL> } <EOL> } <EOL> getErrors ( value ) { <EOL> let errors = { } ; <EOL> const decimalPlaces = this . getDecimalPlacesNumber ( value ) ; <EOL> if ( decimalPlaces > <NUM_LIT> ) { <EOL> errors = { <EOL> ... errors , <EOL> toManyDecimalPlaces : { <EOL> valid : false <EOL> } <EOL> } ; <EOL> } <EOL> return errors ; <EOL> } <EOL> getWithTimeUnit ( input ) { <EOL> let resultTime = input ; <EOL> let resultUnit = TimeUnit . Hour ; <EOL> this . getUnits ( ) . sort ( ( a , b ) = > b . value - a . value ) . some ( entry = > { <EOL> if ( entry . value < input & & this . getDecimalPlacesNumber ( input / entry . value ) < <NUM_LIT> ) { <EOL> resultTime = input / entry . value ; <EOL> resultUnit = TimeUnit [ entry . key ] ; <EOL> return true ; <EOL> } <EOL> return false ; <EOL> } ) ; <EOL> return [ resultTime , resultUnit ] ; <EOL> } <EOL> getDecimalPlacesNumber ( num ) { <EOL> const div = String ( num ) . split ( '<STR_LIT>' ) ; <EOL> return div . length < <NUM_LIT>   ? <NUM_LIT> : div [ <NUM_LIT> ] . length ; <EOL> } <EOL> } </s>
<s> import type { <EOL> ICustomTimezone <EOL> } from '<STR_LIT>' ; <EOL> const allTimezones = { <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> GMT : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> } ; <EOL> export default allTimezones ; </s>
<s> import { <EOL> get , <EOL> noop , <EOL> find , <EOL> every <EOL> } from '<STR_LIT>' ; <EOL> import moment from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES , <EOL> TimeRange , <EOL> TimeRangeBounds , <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> intervalOptions , <EOL> autoInterval , <EOL> isAutoInterval <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createFilterDateHistogram <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BucketAggType , <EOL> IBucketAggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BUCKET_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExtendedBounds <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeBuckets <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> writeParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isMetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> dateHistogramInterval <EOL> } from '<STR_LIT>' ; <EOL> internal <EOL> export type CalculateBoundsFn = ( timeRange : TimeRange ) = > TimeRangeBounds ; <EOL> const updateTimeBuckets = ( agg , calculateBounds , customBuckets   ? ) = > { <EOL> const bounds = agg . params . timeRange & & ( agg . fieldIsTimeField ( ) | | isAutoInterval ( agg . params . interval ) )   ? calculateBounds ( agg . params . timeRange ) : undefined ; <EOL> const buckets = customBuckets | | agg . buckets ; <EOL> buckets . setBounds ( bounds ) ; <EOL> buckets . setInterval ( agg . params . interval ) ; <EOL> } ; <EOL> export interface DateHistogramBucketAggDependencies { <EOL> calculateBounds : CalculateBoundsFn ; isDefaultTimezone : ( ) = > boolean ; getConfig : < T = any > ( key : string ) = > T ; } export interface IBucketDateHistogramAggConfig extends IBucketAggConfig { buckets : TimeBuckets ; } export function isDateHistogramBucketAggConfig ( agg ) { return Boolean ( agg . buckets ) ; } export interface AggParamsDateHistogram extends BaseAggParams { field   ? : string ; timeRange   ? : TimeRange ; useNormalizedOpenSearchInterval   ? : boolean ; scaleMetricValues   ? : boolean ; interval   ? : string ; time_zone   ? : string ; drop_partials   ? : boolean ; format   ? : string ; min_doc_count   ? : number ; extended_bounds   ? : ExtendedBounds ; } export const getDateHistogramBucketAgg = ( { calculateBounds , isDefaultTimezone , getConfig , } ) = > new BucketAggType < IBucketDateHistogramAggConfig > ( { name : BUCKET_TYPES . DATE_HISTOGRAM , title : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , ordered : { date : true , } , makeLabel ( agg ) { let output = { } ; if ( this . params ) { output = writeParams ( this . params , agg ) ; } const field = agg . getFieldDisplayName ( ) ; return i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , values : { fieldName : field , intervalDescription : output . metricScaleText | | output . bucketInterval . description , } , } ) ; } , createFilter : createFilterDateHistogram , decorateAggConfig ( ) { let buckets ; return { buckets : { configurable : true , get ( ) { if ( buckets ) return buckets ; buckets = new TimeBuckets ( { '<STR_LIT>' : getConfig ( UI_SETTINGS . HISTOGRAM_MAX_BARS ) , '<STR_LIT>' : getConfig ( UI_SETTINGS . HISTOGRAM_BAR_TARGET ) , dateFormat : getConfig ( '<STR_LIT>' ) , '<STR_LIT>' : getConfig ( '<STR_LIT>' ) , } ) ; updateTimeBuckets ( this , calculateBounds , buckets ) ; return buckets ; } , } as any , } ; } , getSerializedFormat ( agg ) { return { id : '<STR_LIT>' , params : { pattern : agg . buckets . getScaledDateFormat ( ) , } , } ; } , params : [ { name : '<STR_LIT>' , type : '<STR_LIT>' , filterFieldTypes : OSD_FIELD_TYPES . DATE , default ( agg ) { return agg . getIndexPattern ( ) . timeFieldName ; } , onChange ( agg ) { if ( isAutoInterval ( get ( agg , '<STR_LIT>' ) ) & &   ! agg . fieldIsTimeField ( ) ) { delete agg . params . interval ; } } , } , { name : '<STR_LIT>' , default : null , write : noop , } , { name : '<STR_LIT>' , default : true , write : noop , } , { name : '<STR_LIT>' , default : false , write : noop , advanced : true , } , { name : '<STR_LIT>' , deserialize ( state , agg ) { if ( state == = '<STR_LIT>' ) { return get ( agg , '<STR_LIT>' ) ; } const interval = find ( intervalOptions , { val : state } ) ; if (   ! interval & & state == = '<STR_LIT>' ) { return '<STR_LIT>' ; } return state ; } , default : autoInterval , options : intervalOptions , write ( agg , output , aggs ) { updateTimeBuckets ( agg , calculateBounds ) ; const { useNormalizedOpenSearchInterval , scaleMetricValues } = agg . params ; const interval = agg . buckets . getInterval ( useNormalizedOpenSearchInterval ) ; output . bucketInterval = interval ; if ( interval . expression == = '<STR_LIT>' ) { return ; } output . params = { ... output . params , ... dateHistogramInterval ( interval . expression ) , } ; const scaleMetrics = scaleMetricValues & & interval . scaled & & interval . scale & & interval . scale < <NUM_LIT> ; if ( scaleMetrics & & aggs ) { const metrics = aggs . aggs . filter ( ( a ) = > isMetricAggType ( a . type ) ) ; const all = every ( metrics , ( a ) = > { const { type } = a ; if ( isMetricAggType ( type ) ) { return type . isScalable ( ) ; } } ) ; if ( all ) { output . metricScale = interval . scale ; output . metricScaleText = interval . preScaled   ? . description | | '<STR_LIT>' ; } } } , } , { name : '<STR_LIT>' , default : undefined , serialize : noop , write ( agg , output ) { let tz = agg . params . time_zone ; if (   ! tz & & agg . params . field ) { tz = get ( agg . getIndexPattern ( ) , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , agg . params . field . name , '<STR_LIT>' , ] ) ; } if (   ! tz ) { const detectedTimezone = moment . tz . guess ( ) ; const tzOffset = moment ( ) . format ( '<STR_LIT>' ) ; tz = isDefaultTimezone ( )   ? detectedTimezone | | tzOffset : getConfig ( '<STR_LIT>' ) ; } output . params . time_zone = tz ; } , } , { name : '<STR_LIT>' , default : false , write : noop , shouldShow : ( agg ) = > { const field = agg . params . field ; return field & & field . name & & field . name == = agg . getIndexPattern ( ) . timeFieldName ; } , } , { name : '<STR_LIT>' , } , { name : '<STR_LIT>' , default : <NUM_LIT> , } , { name : '<STR_LIT>' , default : { } , write ( agg , output ) { const val = agg . params . extended_bounds ; if ( val . min != null | | val . max != null ) { output . params . extended_bounds = { min : moment ( val . min ) . valueOf ( ) , max : moment ( val . max ) . valueOf ( ) , } ; return ; } } , } , ] , } ) ; </s>
<s> import { <EOL> CoreSetup , <EOL> CoreStart , <EOL> Plugin <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UrlGeneratorId , <EOL> UrlGeneratorsDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UrlGeneratorInternal <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UrlGeneratorContract <EOL> } from '<STR_LIT>' ; <EOL> export interface UrlGeneratorsStart { <EOL> getUrlGenerator : < T extends UrlGeneratorId > ( urlGeneratorId : T ) = > UrlGeneratorContract < T > ; } export interface UrlGeneratorsSetup { registerUrlGenerator : < Id extends UrlGeneratorId > ( generator : UrlGeneratorsDefinition < Id > ) = > UrlGeneratorContract < Id > ; } export class UrlGeneratorsService implements Plugin < UrlGeneratorsSetup , UrlGeneratorsStart > { private urlGenerators : Map < string , UrlGeneratorInternal < any > > = new Map ( ) ; constructor ( ) { } public setup ( core ) { const setup = { registerUrlGenerator : < Id extends UrlGeneratorId > ( generatorOptions ) = > { const generator = new UrlGeneratorInternal < Id > ( generatorOptions , this . getUrlGenerator ) ; this . urlGenerators . set ( generatorOptions . id , generator ) ; return generator . getPublicContract ( ) ; } , } ; return setup ; } public start ( core ) { const start = { getUrlGenerator : this . getUrlGenerator , } ; return start ; } public stop ( ) { } private readonly getUrlGenerator = ( id ) = > { const generator = this . urlGenerators . get ( id ) ; if (   ! generator ) { throw new Error ( i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , values : { id } , } ) ) ; } return generator . getPublicContract ( ) ; } ; } </s>
<s> import ResultPoint from '<STR_LIT>' ; <EOL> author Sean Owen <EOL> export default class AlignmentPattern extends ResultPoint { <EOL> public constructor ( posX , posY , private estimatedModuleSize ) { <EOL> super ( posX , posY ) ; <EOL> } <EOL> / ** <EOL> * < p > Determines if this alignment pattern "<STR_LIT>" an alignment pattern at the stated <EOL> * position and size - - meaning , it is at nearly the same center with nearly the same size . < / p > <EOL> * / <EOL> public aboutEquals ( moduleSize , i , j ) { <EOL> if ( Math . abs ( i - this . getY ( ) ) <= moduleSize & & Math . abs ( j - this . getX ( ) ) <= moduleSize ) { <EOL> const moduleSizeDiff = Math . abs ( moduleSize - this . estimatedModuleSize ) ; <EOL> return moduleSizeDiff <= <NUM_LIT> | | moduleSizeDiff <= this . estimatedModuleSize ; <EOL> } <EOL> return false ; <EOL> } <EOL> / ** <EOL> * Combines this object ' s current estimate of a finder pattern position and module size <EOL> * with a new estimate . It returns a new { @ code FinderPattern } containing an average of the two . <EOL> * / <EOL> public combineEstimate ( i , j , newModuleSize ) { <EOL> const combinedX = ( this . getX ( ) + j ) / <NUM_LIT> ; <EOL> const combinedY = ( this . getY ( ) + i ) / <NUM_LIT> ; <EOL> const combinedModuleSize = ( this . estimatedModuleSize + newModuleSize ) / <NUM_LIT> ; <EOL> return new AlignmentPattern ( combinedX , combinedY , combinedModuleSize ) ; <EOL> } <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import Dialog , { <EOL> DialogTitle , <EOL> DialogContent , <EOL> DialogFooter , <EOL> DialogButton , <EOL> } from '<STR_LIT>' ; <EOL> import Button from '<STR_LIT>' ; <EOL> import List , { <EOL> ListItem , <EOL> ListItemText <EOL> } from '<STR_LIT>' ; <EOL> import Radio , { <EOL> NativeRadioControl <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> const choices = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> class Confirmation extends React . Component < { } , { <EOL> isOpen : boolean ; action : string ; selectedIndex : number ; <EOL> } > { <EOL> state = { <EOL> isOpen : false , <EOL> action : '<STR_LIT>' , <EOL> selectedIndex : - <NUM_LIT> <EOL> } ; isChecked = ( i ) = > i == = this . state . selectedIndex ; render ( ) { <EOL> return ( < main className = '<STR_LIT>' > < aside > < Button raised onClick = { ( ) = > this . setState ( { isOpen :   ! this . state . isOpen } ) } > { this . state . isOpen   ? '<STR_LIT>' : '<STR_LIT>' } < / Button > < p className = '<STR_LIT>' > Dialog Action : < samp > & emsp ; { this . state . action } & bull ; Selected Index : { '<STR_LIT>' } { this . state . selectedIndex } < / samp > < / p > < / aside > < Dialog escapeKeyAction = { '<STR_LIT>' } scrimClickAction = { '<STR_LIT>' } onClose = { ( action ) = > this . setState ( { isOpen : false , action } ) } open = { this . state . isOpen } > < DialogTitle > Phone Ringtone < / DialogTitle > < DialogContent > < List singleSelection handleSelect = { ( selectedIndex ) = > this . setState ( { selectedIndex } ) } > { choices . map ( ( choice , i ) = > { const c = choice . replace ( / \ s / g , '<STR_LIT>' ) ; return ( < ListItem key = { i } > < span className = '<STR_LIT>' > < Radio key = { c } > < NativeRadioControl name = '<STR_LIT>' value = { choice } id = { c } checked = { this . isChecked ( i ) } onChange = { ( ) = > { } } / > < / Radio > < / span > < label htmlFor = { c } > < ListItemText primaryText = { choice } / > < / label > < / ListItem > ) ; } ) } < / List > < / DialogContent > < DialogFooter > < DialogButton action = '<STR_LIT>' > Cancel < / DialogButton > < DialogButton action = '<STR_LIT>' isDefault > Ok < / DialogButton > < / DialogFooter > < / Dialog > < / main > ) ; } } export default Confirmation ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent , <EOL> ReactNode <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css <EOL> } from "<STR_LIT>" ; <EOL> interface Props { <EOL> children : ReactNode ; <EOL> } <EOL> const Layout = ( { <EOL> children <EOL> } ) = > ( < div css = { wrapperStyle } > { children } < / div > ) ; export default Layout ; const wrapperStyle = css ( { height : "<STR_LIT>" , position : "<STR_LIT>" , } ) ; </s>
<s> </s>
<s> const DEBUG = false ; <EOL> export function log ( ... messages ) { <EOL> if ( DEBUG ) { <EOL> console . log ( ... messages ) ; <EOL> } <EOL> } </s>
<s> import dateMath from '<STR_LIT>' ; <EOL> import { <EOL> TimeRange <EOL> } from '<STR_LIT>' ; <EOL> export function validateTimeRange ( time   ? ) { <EOL> if ( ! time ) return false ; <EOL> const momentDateFrom = dateMath . parse ( time . from ) ; <EOL> const momentDateTo = dateMath . parse ( time . to ) ; <EOL> return   ! ! ( momentDateFrom & & momentDateFrom . isValid ( ) & & momentDateTo & & momentDateTo . isValid ( ) ) ; <EOL> } </s>
<s> const NUM_BYTES = <NUM_LIT> ; <EOL> const BYTE_SIZE = <NUM_LIT> ; <EOL> function throwError ( ipAddress ) { <EOL> throw Error ( '<STR_LIT>' + ipAddress ) ; <EOL> } <EOL> function isIntegerInRange ( integer , min , max ) { <EOL> return ( ! isNaN ( integer as number ) & & integer >= min & & integer < max & & ( integer as number ) % <NUM_LIT> == = <NUM_LIT> ) ; <EOL> } <EOL> export class Ipv4Address { <EOL> private value : number ; <EOL> constructor ( ipAddress ) { <EOL> if ( typeof ipAddress == = '<STR_LIT>' ) { <EOL> this . value = <NUM_LIT> ; <EOL> const bytes = ipAddress . split ( '<STR_LIT>' ) ; <EOL> if ( bytes . length != = NUM_BYTES ) { <EOL> throwError ( ipAddress ) ; <EOL> } <EOL> for ( let i = <NUM_LIT> ; i < bytes . length ; i + + ) { <EOL> const byte = Number ( bytes [ i ] ) ; <EOL> if ( ! isIntegerInRange ( byte , <NUM_LIT> , BYTE_SIZE ) ) { <EOL> throwError ( ipAddress ) ; <EOL> } <EOL> this . value += Math . pow ( BYTE_SIZE , NUM_BYTES - <NUM_LIT> - i ) * byte ; <EOL> } <EOL> } else { <EOL> this . value = ipAddress ; <EOL> } <EOL> if ( ! isIntegerInRange ( this . value , <NUM_LIT> , Math . pow ( BYTE_SIZE , NUM_BYTES ) ) ) { <EOL> throwError ( ipAddress ) ; <EOL> } <EOL> } <EOL> public toString ( ) { <EOL> let value = this . value ; <EOL> const bytes = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < NUM_BYTES ; i + + ) { <EOL> bytes . unshift ( value % <NUM_LIT> ) ; <EOL> value = Math . floor ( value / <NUM_LIT> ) ; <EOL> } <EOL> return bytes . join ( '<STR_LIT>' ) ; <EOL> } <EOL> public valueOf ( ) { <EOL> return this . value ; <EOL> } <EOL> } </s>
<s> import _ from '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> import { <EOL> SavedObjectsClientContract <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternSelect , <EOL> IndexPatternSelectProps <EOL> } from '<STR_LIT>' ; <EOL> export function createIndexPatternSelect ( savedObjectsClient ) { <EOL> return ( props ) = > ( < IndexPatternSelect { ... props } savedObjectsClient = { savedObjectsClient } / > ) ; <EOL> } </s>
<s> import { <EOL> mapValues , <EOL> isString <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldMappingSpec , <EOL> MappingObject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OPENSEARCH_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> private type ShorthandFieldMapObject = FieldMappingSpec | OPENSEARCH_FIELD_TYPES | '<STR_LIT>' ; <EOL> public <EOL> export const expandShorthand = ( sh ) : MappingObject = > { <EOL> return mapValues ( sh , ( val ) = > { <EOL> const fieldMap = isString ( val )   ? { <EOL> type : val <EOL> } : val ; <EOL> const json = { <EOL> type : OPENSEARCH_FIELD_TYPES . TEXT , <EOL> _serialize ( v ) { <EOL> if ( v ) return JSON . stringify ( v ) ; <EOL> } , <EOL> _deserialize ( v ) { <EOL> if ( v ) return JSON . parse ( v ) ; <EOL> } , <EOL> } ; <EOL> return fieldMap . type == = '<STR_LIT>'   ? json : fieldMap ; <EOL> } ) as MappingObject ; <EOL> } ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> render <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Global <EOL> } from "<STR_LIT>" ; <EOL> import debug from "<STR_LIT>" ; <EOL> import { <EOL> name , <EOL> version <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> globalStyle <EOL> } from "<STR_LIT>" ; <EOL> import App from "<STR_LIT>" ; <EOL> const log = debug ( "<STR_LIT>" ) ; <EOL> ( async ( ) = > { <EOL> log ( ` $ { name } v $ { version } ` ) ; <EOL> document . title +=   ` v $ { version } ` ; <EOL> render ( < React . StrictMode > < Global styles = { globalStyle } / > < App / > < / React . StrictMode > , document . getElementById ( "<STR_LIT>" ) ) ; } ) ( ) . catch ( ( err ) = > console . error ( err ) ) ; </s>
<s> import React , { <EOL> ReactElement <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiHeaderLinks <EOL> } from '<STR_LIT>' ; <EOL> import classNames from '<STR_LIT>' ; <EOL> import { <EOL> MountPoint <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MountPointPortal <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> StatefulSearchBarProps , <EOL> DataPublicPluginStart , <EOL> SearchBarProps , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TopNavMenuData <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TopNavMenuItem <EOL> } from '<STR_LIT>' ; <EOL> export type TopNavMenuProps = StatefulSearchBarProps & Omit < SearchBarProps , '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' > & { <EOL> config   ? : TopNavMenuData [ ] ; showSearchBar   ? : boolean ; showQueryBar   ? : boolean ; showQueryInput   ? : boolean ; showDatePicker   ? : boolean ; showFilterBar   ? : boolean ; data   ? : DataPublicPluginStart ; className   ? : string ; example setMenuMountPoint   ? : ( menuMount : MountPoint | undefined ) = > void ; <EOL> } ; <EOL> export function TopNavMenu ( props ) { <EOL> const { <EOL> config , <EOL> showSearchBar , <EOL> ... searchBarProps <EOL> } = props ; <EOL> if ( ( ! config | | config . length == = <NUM_LIT> ) & & ( ! showSearchBar | |   ! props . data ) ) { <EOL> return null ; <EOL> } <EOL> function renderItems ( ) { <EOL> if ( ! config | | config . length == = <NUM_LIT> ) return null ; <EOL> return config . map ( ( menuItem , i ) = > { <EOL> return < TopNavMenuItem key = {   ` nav - menu - $ { i } ` } { ... menuItem } / > ; <EOL> } ) ; <EOL> } <EOL> function renderMenu ( className ) { <EOL> if ( ! config | | config . length == = <NUM_LIT> ) return null ; <EOL> return ( < EuiHeaderLinks data - test - subj = "<STR_LIT>" gutterSize = "<STR_LIT>" className = { className } > { renderItems ( ) } < / EuiHeaderLinks > ) ; } function renderSearchBar ( ) { if (   ! showSearchBar | |   ! props . data ) return null ; const { SearchBar } = props . data . ui ; return < SearchBar { ... searchBarProps } / > ; } function renderLayout ( ) { const { setMenuMountPoint } = props ; const menuClassName = classNames ( '<STR_LIT>' , props . className ) ; const wrapperClassName = '<STR_LIT>' ; if ( setMenuMountPoint ) { return ( < > < MountPointPortal setMountPoint = { setMenuMountPoint } > < span className = { wrapperClassName } > { renderMenu ( menuClassName ) } < / span > < / MountPointPortal > < span className = { wrapperClassName } > { renderSearchBar ( ) } < / span > < / > ) ; } else { return ( < span className = { wrapperClassName } > { renderMenu ( menuClassName ) } { renderSearchBar ( ) } < / span > ) ; } } return renderLayout ( ) ; } TopNavMenu . defaultProps = { showSearchBar : false , showQueryBar : true , showQueryInput : true , showDatePicker : true , showFilterBar : true , screenTitle : '<STR_LIT>' , } ; </s>
<s> import type { <EOL> ParsingExtension <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AppConfigError <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> named , <EOL> forKey , <EOL> composeExtensions <EOL> } from '<STR_LIT>' ; / ** Provides string parsing * / <EOL> export function parseDirective ( ) { <EOL> return named ( '<STR_LIT>' , composeExtensions ( [ forKey ( '<STR_LIT>' , ( value ) = > async ( parse ) = > { <EOL> const parsed = await parse ( value ) ; <EOL> const primitive = parsed . asPrimitive ( ) ; <EOL> if ( typeof primitive == = '<STR_LIT>' ) { <EOL> return parse ( primitive . toLowerCase ( ) == = '<STR_LIT>' | | primitive . toLowerCase ( ) == = '<STR_LIT>' , { <EOL> shouldFlatten : true , <EOL> } ) ; <EOL> } <EOL> return parse ( ! ! parsed . toJSON ( ) , { <EOL> shouldFlatten : true <EOL> } ) ; <EOL> } ) , forKey ( '<STR_LIT>' , ( value ) = > async ( parse ) = > { <EOL> const parsed = await parse ( value ) ; <EOL> const primitive = parsed . asPrimitive ( ) ; <EOL> if ( typeof primitive == = '<STR_LIT>' ) { <EOL> return parse ( primitive , { <EOL> shouldFlatten : true <EOL> } ) ; <EOL> } <EOL> if ( typeof primitive == = '<STR_LIT>' ) { <EOL> const floatValue = Number . parseFloat ( primitive ) ; <EOL> if ( Number . isNaN ( floatValue ) ) { <EOL> throw new AppConfigError ( ` Failed to   $ parseFloat ( $ { primitive } ) ` ) ; <EOL> } <EOL> return parse ( floatValue , { <EOL> shouldFlatten : true <EOL> } ) ; <EOL> } <EOL> throw new AppConfigError ( ` Failed to   $ parseFloat ( $ { parsed . toJSON ( ) as string } ) - invalid input type ` ) ; <EOL> } ) , forKey ( '<STR_LIT>' , ( value ) = > async ( parse ) = > { <EOL> const parsed = await parse ( value ) ; <EOL> const primitive = parsed . asPrimitive ( ) ; <EOL> if ( typeof primitive == = '<STR_LIT>' ) { <EOL> return parse ( primitive | <NUM_LIT> , { <EOL> shouldFlatten : true <EOL> } ) ; <EOL> } <EOL> if ( typeof primitive == = '<STR_LIT>' ) { <EOL> const intValue = Number . parseInt ( primitive , <NUM_LIT> ) ; <EOL> if ( Number . isNaN ( intValue ) ) { <EOL> throw new AppConfigError ( ` Failed to   $ parseInt ( $ { primitive } ) ` ) ; <EOL> } <EOL> return parse ( intValue , { <EOL> shouldFlatten : true <EOL> } ) ; <EOL> } <EOL> throw new AppConfigError ( ` Failed to   $ parseInt ( $ { parsed . toJSON ( ) as string } ) - invalid input type ` ) ; <EOL> } ) , ] ) ) ; <EOL> } </s>
<s> import { <EOL> SearchResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Search <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IOpenSearchDashboardsSearchRequest , <EOL> IOpenSearchDashboardsSearchResponse <EOL> } from '<STR_LIT>' ; <EOL> export const OPENSEARCH_SEARCH_STRATEGY = '<STR_LIT>' ; <EOL> export interface ISearchOptions { <EOL> / ** <EOL> * An   ` AbortSignal ` that allows the caller of   ` search ` to abort a search request . <EOL> * / <EOL> abortSignal   ? : AbortSignal ; <EOL> / ** <EOL> * Use this option to force using a specific server side search strategy . Leave empty to use the default strategy . <EOL> * / <EOL> strategy   ? : string ; <EOL> } <EOL> export type ISearchRequestParams < T = Record < string , any > > = { <EOL> trackTotalHits   ? : boolean ; <EOL> } & Search < T > ; <EOL> export interface IOpenSearchSearchRequest extends IOpenSearchDashboardsSearchRequest < ISearchRequestParams > { <EOL> indexType   ? : string ; <EOL> } <EOL> export type IOpenSearchSearchResponse < Source = any > = IOpenSearchDashboardsSearchResponse < SearchResponse < Source > > ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FILTERS <EOL> } from '<STR_LIT>' ; <EOL> export interface Operator { <EOL> message : string ; type : FILTERS ; negate : boolean ; fieldTypes   ? : string [ ] ; <EOL> } <EOL> export const isOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . PHRASE , <EOL> negate : false , <EOL> } ; <EOL> export const isNotOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . PHRASE , <EOL> negate : true , <EOL> } ; <EOL> export const isOneOfOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . PHRASES , <EOL> negate : false , <EOL> fieldTypes : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } ; <EOL> export const isNotOneOfOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . PHRASES , <EOL> negate : true , <EOL> fieldTypes : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } ; <EOL> export const isBetweenOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . RANGE , <EOL> negate : false , <EOL> fieldTypes : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } ; <EOL> export const isNotBetweenOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . RANGE , <EOL> negate : true , <EOL> fieldTypes : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } ; <EOL> export const existsOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . EXISTS , <EOL> negate : false , <EOL> } ; <EOL> export const doesNotExistOperator = { <EOL> message : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : FILTERS . EXISTS , <EOL> negate : true , <EOL> } ; <EOL> export const FILTER_OPERATORS = [ isOperator , isNotOperator , isOneOfOperator , isNotOneOfOperator , isBetweenOperator , isNotBetweenOperator , existsOperator , doesNotExistOperator , ] ; </s>
<s> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UpdateDef <EOL> } from '<STR_LIT>' ; <EOL> export class UpdateManager extends Store < UpdateDef [ ] > { <EOL> constructor ( defs   ? ) { <EOL> super ( ) ; <EOL> if ( defs ) { <EOL> this . add ( defs ) ; <EOL> } <EOL> } <EOL> add ( defs ) { <EOL> if ( ! Array . isArray ( defs ) ) { <EOL> defs = [ defs ] ; <EOL> } <EOL> defs . forEach ( def = > { <EOL> const all = this . get ( def . mutation ) | | [ ] ; <EOL> all . push ( def ) ; <EOL> super . set ( def . mutation , all ) ; <EOL> } ) ; <EOL> } <EOL> set ( ) { <EOL> console . error ( '<STR_LIT>' ) ; <EOL> } <EOL> } </s>
<s> import React , { <EOL> Children , <EOL> ReactNode , <EOL> useRef , <EOL> useState , <EOL> useCallback , <EOL> useEffect <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> keys <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PanelContextProvider <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Resizer , <EOL> ResizerMouseEvent , <EOL> ResizerKeyDownEvent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PanelRegistry <EOL> } from '<STR_LIT>' ; <EOL> export interface Props { <EOL> children : ReactNode ; className   ? : string ; resizerClassName   ? : string ; onPanelWidthChange   ? : ( arrayOfPanelWidths : number [ ] ) = > any ; <EOL> } <EOL> interface State { <EOL> isDragging : boolean ; currentResizerPos : number ; <EOL> } <EOL> const initialState = { <EOL> isDragging : false , <EOL> currentResizerPos : - <NUM_LIT> <EOL> } ; <EOL> const pxToPercent = ( proportion , whole ) = > ( proportion / whole ) * <NUM_LIT> ; <EOL> export function PanelsContainer ( { <EOL> children , <EOL> className , <EOL> onPanelWidthChange , <EOL> resizerClassName , <EOL> } ) { <EOL> const childrenArray = Children . toArray ( children ) ; <EOL> const [ firstChild , secondChild ] = childrenArray ; <EOL> const registryRef = useRef ( new PanelRegistry ( ) ) ; <EOL> const containerRef = useRef < HTMLDivElement > ( null ) ; <EOL> const [ state , setState ] = useState < State > ( initialState ) ; <EOL> const getContainerWidth = ( ) = > { <EOL> return containerRef . current ! . getBoundingClientRect ( ) . width ; <EOL> } ; <EOL> const handleMouseDown = useCallback ( ( event ) = > { <EOL> setState ( { <EOL> ... state , <EOL> isDragging : true , <EOL> currentResizerPos : event . clientX , <EOL> } ) ; <EOL> } , [ state ] ) ; <EOL> const handleKeyDown = useCallback ( ( ev ) = > { <EOL> const { <EOL> key <EOL> } = ev ; <EOL> if ( key == = keys . ARROW_LEFT | | key == = keys . ARROW_RIGHT ) { <EOL> ev . preventDefault ( ) ; <EOL> const { <EOL> current : registry <EOL> } = registryRef ; <EOL> const [ left , right ] = registry . getPanels ( ) ; <EOL> const leftPercent = left . width - ( key == = keys . ARROW_LEFT   ? <NUM_LIT> : - <NUM_LIT> ) ; <EOL> const rightPercent = right . width - ( key == = keys . ARROW_RIGHT   ? <NUM_LIT> : - <NUM_LIT> ) ; <EOL> left . setWidth ( leftPercent ) ; <EOL> right . setWidth ( rightPercent ) ; <EOL> if ( onPanelWidthChange ) { <EOL> onPanelWidthChange ( [ leftPercent , rightPercent ] ) ; <EOL> } <EOL> } <EOL> } , [ onPanelWidthChange ] ) ; <EOL> useEffect ( ( ) = > { <EOL> if ( process . env . NODE_ENV != = '<STR_LIT>' ) { <EOL> if ( childrenArray . length > <NUM_LIT> ) { <EOL> console . warn ( '<STR_LIT>' ) ; <EOL> } <EOL> } <EOL> } , [ childrenArray . length ] ) ; <EOL> const childrenWithResizer = [ firstChild , < Resizer key = { '<STR_LIT>' } className = { resizerClassName } onKeyDown = { handleKeyDown } onMouseDown = { handleMouseDown } / > , secondChild , ] ; <EOL> return ( < PanelContextProvider registry = { registryRef . current } > < div className = { className } ref = { containerRef } style = { { display : '<STR_LIT>' , height : '<STR_LIT>' , width : '<STR_LIT>' } } onMouseMove = { ( event ) = > { if ( state . isDragging ) { const { clientX : x } = event ; const { current : registry } = registryRef ; const [ left , right ] = registry . getPanels ( ) ; const delta = x - state . currentResizerPos ; const containerWidth = getContainerWidth ( ) ; const leftPercent = pxToPercent ( left . getWidth ( ) + delta , containerWidth ) ; const rightPercent = pxToPercent ( right . getWidth ( ) - delta , containerWidth ) ; left . setWidth ( leftPercent ) ; right . setWidth ( rightPercent ) ; if ( onPanelWidthChange ) { onPanelWidthChange ( [ leftPercent , rightPercent ] ) ; } setState ( { ... state , currentResizerPos : x } ) ; } } } onMouseUp = { ( ) = > { setState ( initialState ) ; } } > { childrenWithResizer } < / div > < / PanelContextProvider > ) ; } </s>
<s> / ** <EOL> Flatten the type output to improve type hints shown in editors . <EOL> Borrowed from type - fest <EOL> * / <EOL> type Simplify < T > = { <EOL> [ KeyType in keyof T ] : T [ KeyType ] ; <EOL> } ; <EOL> / ** <EOL> Create a type that makes the given keys required . The remaining keys are kept as is . <EOL> Borrowed from type - fest <EOL> * / <EOL> type SetRequired < BaseType , Keys extends keyof BaseType > = Simplify < Omit < BaseType , Keys > & Required < Pick < BaseType , Keys > > > ; <EOL> / ** <EOL> * Parameter types for plugins <EOL> * / <EOL> export enum ParameterType { <EOL> BOOL , <EOL> STRING , <EOL> INT , <EOL> FLOAT , <EOL> FUNCTION , <EOL> KEY , <EOL> KEYS , <EOL> SELECT , <EOL> HTML_STRING , <EOL> IMAGE , <EOL> AUDIO , <EOL> VIDEO , <EOL> OBJECT , <EOL> COMPLEX , <EOL> TIMELINE <EOL> } <EOL> type ParameterTypeMap = { <EOL> [ ParameterType . BOOL ] : boolean ; <EOL> [ ParameterType . STRING ] : string ; <EOL> [ ParameterType . INT ] : number ; <EOL> [ ParameterType . FLOAT ] : number ; <EOL> [ ParameterType . FUNCTION ] : ( ... args : any [ ] ) = > any ; <EOL> [ ParameterType . KEY ] : string ; <EOL> [ ParameterType . KEYS ] : string [ ] | "<STR_LIT>" | "<STR_LIT>" ; <EOL> [ ParameterType . SELECT ] : any ; <EOL> [ ParameterType . HTML_STRING ] : string ; <EOL> [ ParameterType . IMAGE ] : string ; <EOL> [ ParameterType . AUDIO ] : string ; <EOL> [ ParameterType . VIDEO ] : string ; <EOL> [ ParameterType . OBJECT ] : object ; <EOL> [ ParameterType . COMPLEX ] : any ; <EOL> [ ParameterType . TIMELINE ] : any ; <EOL> } ; <EOL> export interface ParameterInfo { <EOL> type : ParameterType ; array   ? : boolean ; pretty_name   ? : string ; <EOL> default   ? : any ; preload   ? : boolean ; <EOL> } <EOL> export interface ParameterInfos { <EOL> [ key ] : ParameterInfo ; <EOL> } <EOL> type InferredParameter < I extends ParameterInfo > = I [ "<STR_LIT>" ] extends true   ? Array < ParameterTypeMap [ I [ "<STR_LIT>" ] ] > : ParameterTypeMap [ I [ "<STR_LIT>" ] ] ; <EOL> type RequiredParameterNames < I extends ParameterInfos > = { <EOL> [ K in keyof I ] : I [ K ] [ "<STR_LIT>" ] extends undefined   ? K : never ; <EOL> } [ keyof I ] ; <EOL> type InferredParameters < I extends ParameterInfos > = SetRequired < { <EOL> [ Property in keyof I ]   ? : InferredParameter < I [ Property ] > ; <EOL> } , RequiredParameterNames < I > > ; <EOL> export const universalPluginParameters = < const > { / ** <EOL> * Data to add to this trial ( key - value pairs ) <EOL> * / data : { type : ParameterType . OBJECT , pretty_name : "<STR_LIT>" , default : { } , } , / ** <EOL> * Function to execute when trial begins <EOL> * / on_start : { type : ParameterType . FUNCTION , pretty_name : "<STR_LIT>" , default : function ( ) { return ; } , } , / ** <EOL> * Function to execute when trial is finished <EOL> * / on_finish : { type : ParameterType . FUNCTION , pretty_name : "<STR_LIT>" , default : function ( ) { return ; } , } , / ** <EOL> * Function to execute after the trial has loaded <EOL> * / on_load : { type : ParameterType . FUNCTION , pretty_name : "<STR_LIT>" , default : function ( ) { return ; } , } , / ** <EOL> * Length of gap between the end of this trial and the start of the next trial <EOL> * / post_trial_gap : { type : ParameterType . INT , pretty_name : "<STR_LIT>" , default : null , } , / ** <EOL> * A list of CSS classes to add to the jsPsych display element for the duration of this trial <EOL> * / css_classes : { type : ParameterType . STRING , pretty_name : "<STR_LIT>" , default : null , } , / ** <EOL> * Options to control simulation mode for the trial . <EOL> * / simulation_options : { type : ParameterType . COMPLEX , default : null , } , } ; export type UniversalPluginParameters = InferredParameters < typeof universalPluginParameters > ; export interface PluginInfo { name : string ; parameters : { [ key ] : ParameterInfo ; } ; } export interface JsPsychPlugin < I extends PluginInfo > { trial ( display_element , trial , on_load   ? ) : void | Promise < any > ; } export type TrialType < I extends PluginInfo > = InferredParameters < I [ "<STR_LIT>" ] > & UniversalPluginParameters ; export type PluginParameters < I extends PluginInfo > = InferredParameters < I [ "<STR_LIT>" ] > ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent , <EOL> ReactNode <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css <EOL> } from "<STR_LIT>" ; <EOL> interface Props { <EOL> children : ReactNode ; <EOL> } <EOL> const Main = ( { <EOL> children <EOL> } ) = > ( < div css = { wrapperStyle } > { children } < / div > ) ; export default Main ; const wrapperStyle = css ( { position : "<STR_LIT>" , width : "<STR_LIT>" , height : "<STR_LIT>" , backgroundImage : "<STR_LIT>" , backgroundRepeat : "<STR_LIT>" , backgroundPosition : "<STR_LIT>" , } ) ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import styled from "<STR_LIT>" ; <EOL> import { <EOL> colors <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ShareIcon <EOL> } from "<STR_LIT>" ; <EOL> export interface ShareBtnStyleProps { <EOL> textBottom   ? : boolean ; <EOL> } <EOL> export const ShareBtnStyled = styled . button   ` <EOL> align - items : center ; <EOL> background - color :   $ { colors . basic . WHITE } ; <EOL> border : none ; <EOL> color :   $ { colors . accent . CIVIL_GRAY_2 } ; <EOL> cursor : pointer ; <EOL> display : flex ; <EOL> flex - direction :   $ { ( props ) = > ( props . textBottom   ? "<STR_LIT>" : "<STR_LIT>" ) } ; <EOL> font - size : <NUM_LIT> px ; <EOL> justify - content : center ; <EOL> line - height : <NUM_LIT> ; <EOL> outline : none ; <EOL> padding : <NUM_LIT> ; <EOL> transition : color <NUM_LIT> s ease ; <EOL> svg { <EOL> margin :   $ { ( props ) = > ( props . textBottom   ? "<STR_LIT>" : "<STR_LIT>" ) } ; <EOL> path { <EOL> fill :   $ { colors . accent . CIVIL_GRAY_0 } ; <EOL> transition : fill <NUM_LIT> s ease ; <EOL> } <EOL> } <EOL> & : hover { <EOL> color :   $ { colors . accent . CIVIL_BLUE } ; <EOL> svg path { <EOL> fill :   $ { colors . accent . CIVIL_BLUE } ; <EOL> } <EOL> } <EOL> ` ; <EOL> export interface ShareButtonProps { <EOL> textBottom   ? : boolean ; <EOL> onClick ( ev ) : void ; <EOL> } <EOL> export const ShareButton = props = > { <EOL> return ( < ShareBtnStyled onClick = { props . onClick } textBottom = { props . textBottom } > < ShareIcon / > Share < / ShareBtnStyled > ) ; } ; </s>
<s> import { <EOL> CoreSetup , <EOL> CoreStart , <EOL> Plugin <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomIntegrationsSetup , <EOL> CustomIntegrationsStart , <EOL> CustomIntegrationsStartDependencies , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomIntegration , <EOL> ROUTES_APPEND_CUSTOM_INTEGRATIONS , <EOL> ROUTES_REPLACEMENT_CUSTOM_INTEGRATIONS , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> pluginServices <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> pluginServiceRegistry <EOL> } from '<STR_LIT>' ; <EOL> export class CustomIntegrationsPlugin implements Plugin < CustomIntegrationsSetup , CustomIntegrationsStart > { <EOL> public setup ( core ) { <EOL> return { <EOL> async getReplacementCustomIntegrations ( ) { <EOL> return core . http . get ( ROUTES_REPLACEMENT_CUSTOM_INTEGRATIONS ) ; <EOL> } , <EOL> async getAppendCustomIntegrations ( ) { <EOL> return core . http . get ( ROUTES_APPEND_CUSTOM_INTEGRATIONS ) ; <EOL> } , <EOL> } ; <EOL> } <EOL> public start ( coreStart , startPlugins ) { <EOL> pluginServices . setRegistry ( pluginServiceRegistry . start ( { <EOL> coreStart , <EOL> startPlugins <EOL> } ) ) ; <EOL> return { <EOL> ContextProvider : pluginServices . getContextProvider ( ) , <EOL> } ; <EOL> } <EOL> public stop ( ) { } <EOL> } </s>
<s> import { <EOL> EuiButton , <EOL> EuiButtonEmpty , <EOL> EuiCodeEditor , <EOL> EuiFieldText , <EOL> EuiFlexGroup , <EOL> EuiFlexItem , <EOL> EuiForm , <EOL> EuiFormRow , <EOL> EuiPopoverTitle , <EOL> EuiSpacer , <EOL> EuiSwitch , <EOL> EuiSwitchEvent , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage , <EOL> InjectedIntl , <EOL> injectI18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import React , { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GenericComboBox , <EOL> GenericComboBoxProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getFieldFromFilter , <EOL> getFilterableFields , <EOL> getOperatorFromFilter , <EOL> getOperatorOptions , <EOL> isFilterValid , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Operator <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PhraseValueInput <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PhrasesValuesInput <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RangeValueInput <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> IFieldType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter , <EOL> getIndexPatternFromFilter , <EOL> FieldFilter , <EOL> buildFilter , <EOL> buildCustomFilter , <EOL> cleanFilter , <EOL> getFilterParams , <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> filter : Filter ; indexPatterns : IIndexPattern [ ] ; onSubmit : ( filter : Filter ) = > void ; onCancel : ( ) = > void ; intl : InjectedIntl ; <EOL> } <EOL> interface State { <EOL> selectedIndexPattern   ? : IIndexPattern ; <EOL> selectedField   ? : IFieldType ; <EOL> selectedOperator   ? : Operator ; <EOL> params : any ; <EOL> useCustomLabel : boolean ; <EOL> customLabel : string | null ; <EOL> queryDsl : string ; <EOL> isCustomEditorOpen : boolean ; <EOL> } <EOL> class FilterEditorUI extends Component < Props , State > { <EOL> constructor ( props ) { <EOL> super ( props ) ; <EOL> this . state = { <EOL> selectedIndexPattern : this . getIndexPatternFromFilter ( ) , <EOL> selectedField : this . getFieldFromFilter ( ) , <EOL> selectedOperator : this . getSelectedOperator ( ) , <EOL> params : getFilterParams ( props . filter ) , <EOL> useCustomLabel : props . filter . meta . alias != = null , <EOL> customLabel : props . filter . meta . alias , <EOL> queryDsl : JSON . stringify ( cleanFilter ( props . filter ) , null , <NUM_LIT> ) , <EOL> isCustomEditorOpen : this . isUnknownFilterType ( ) , <EOL> } ; <EOL> } <EOL> public render ( ) { <EOL> return ( < div > < EuiPopoverTitle > < EuiFlexGroup alignItems = "<STR_LIT>" responsive = { false } > < EuiFlexItem > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiFlexItem > < EuiFlexItem grow = { false } className = "<STR_LIT>" / > < EuiFlexItem grow = { false } > < EuiButtonEmpty size = "<STR_LIT>" data - test - subj = "<STR_LIT>" onClick = { this . toggleCustomEditor } > { this . state . isCustomEditorOpen   ? ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) : ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) } < / EuiButtonEmpty > < / EuiFlexItem > < / EuiFlexGroup > < / EuiPopoverTitle > < div className = "<STR_LIT>" > < EuiForm > { this . renderIndexPatternInput ( ) } { this . state . isCustomEditorOpen   ? this . renderCustomEditor ( ) : this . renderRegularEditor ( ) } < EuiSpacer size = "<STR_LIT>" / > < EuiSwitch id = "<STR_LIT>" data - test - subj = "<STR_LIT>" label = { this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } checked = { this . state . useCustomLabel } onChange = { this . onCustomLabelSwitchChange } / > { this . state . useCustomLabel & & ( < div > < EuiSpacer size = "<STR_LIT>" / > < EuiFormRow fullWidth = { true } label = { this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } > < EuiFieldText fullWidth = { true } value = {   ` $ { this . state . customLabel } ` } onChange = { this . onCustomLabelChange } / > < / EuiFormRow > < / div > ) } < EuiSpacer size = "<STR_LIT>" / > < EuiFlexGroup direction = "<STR_LIT>" alignItems = "<STR_LIT>" responsive = { false } > < EuiFlexItem grow = { false } > < EuiButton fill onClick = { this . onSubmit } isDisabled = {   ! this . isFilterValid ( ) } data - test - subj = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiButton > < / EuiFlexItem > < EuiFlexItem grow = { false } > < EuiButtonEmpty flush = "<STR_LIT>" onClick = { this . props . onCancel } data - test - subj = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiButtonEmpty > < / EuiFlexItem > < EuiFlexItem / > < / EuiFlexGroup > < / EuiForm > < / div > < / div > ) ; } private renderIndexPatternInput ( ) { if ( this . props . indexPatterns . length <= <NUM_LIT> & & this . props . indexPatterns . find ( ( indexPattern ) = > indexPattern == = this . getIndexPatternFromFilter ( ) ) ) { / ** <EOL> * Don '<STR_LIT>' s just one   \ zero index patterns <EOL> * and if the index pattern the filter was LOADED with is in the indexPatterns list . <EOL> ** / return '<STR_LIT>' ; } const { selectedIndexPattern } = this . state ; return ( < EuiFlexGroup > < EuiFlexItem > < EuiFormRow label = { this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } > < IndexPatternComboBox placeholder = { this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } options = { this . props . indexPatterns } selectedOptions = { selectedIndexPattern   ? [ selectedIndexPattern ] : [ ] } getLabel = { ( indexPattern ) = > indexPattern . title } onChange = { this . onIndexPatternChange } singleSelection = { { asPlainText : true } } isClearable = { false } data - test - subj = "<STR_LIT>" / > < / EuiFormRow > < / EuiFlexItem > < / EuiFlexGroup > ) ; } private renderRegularEditor ( ) { return ( < div > < EuiFlexGroup responsive = { false } gutterSize = "<STR_LIT>" > < EuiFlexItem grow = { <NUM_LIT> } > { this . renderFieldInput ( ) } < / EuiFlexItem > < EuiFlexItem grow = { false } style = { { flexBasis : <NUM_LIT> } } > { this . renderOperatorInput ( ) } < / EuiFlexItem > < / EuiFlexGroup > < EuiSpacer size = "<STR_LIT>" / > < div data - test - subj = "<STR_LIT>" > { this . renderParamsEditor ( ) } < / div > < / div > ) ; } private renderFieldInput ( ) { const { selectedIndexPattern , selectedField } = this . state ; const fields = selectedIndexPattern   ? getFilterableFields ( selectedIndexPattern ) : [ ] ; return ( < EuiFormRow label = { this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } > < FieldComboBox id = "<STR_LIT>" fullWidth = { true } isDisabled = {   ! selectedIndexPattern } placeholder = { this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } options = { fields } selectedOptions = { selectedField   ? [ selectedField ] : [ ] } getLabel = { ( field ) = > field . name } onChange = { this . onFieldChange } singleSelection = { { asPlainText : true } } isClearable = { false } className = "<STR_LIT>" data - test - subj = "<STR_LIT>" / > < / EuiFormRow > ) ; } private renderOperatorInput ( ) { const { selectedField , selectedOperator } = this . state ; const operators = selectedField   ? getOperatorOptions ( selectedField ) : [ ] ; return ( < EuiFormRow label = { this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } > < OperatorComboBox isDisabled = {   ! selectedField } placeholder = { selectedField   ? this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) : this . props . intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } options = { operators } selectedOptions = { selectedOperator   ? [ selectedOperator ] : [ ] } getLabel = { ( { message } ) = > message } onChange = { this . onOperatorChange } singleSelection = { { asPlainText : true } } isClearable = { false } data - test - subj = "<STR_LIT>" / > < / EuiFormRow > ) ; } private renderCustomEditor ( ) { return ( < EuiFormRow label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } fullWidth = { true } > < EuiCodeEditor value = { this . state . queryDsl } onChange = { this . onQueryDslChange } mode = "<STR_LIT>" width = "<STR_LIT>" height = "<STR_LIT>" / > < / EuiFormRow > ) ; } private renderParamsEditor ( ) { const indexPattern = this . state . selectedIndexPattern ; if (   ! indexPattern | |   ! this . state . selectedOperator ) { return '<STR_LIT>' ; } switch ( this . state . selectedOperator . type ) { case '<STR_LIT>' : return '<STR_LIT>' ; case '<STR_LIT>' : return ( < PhraseValueInput indexPattern = { indexPattern } field = { this . state . selectedField } value = { this . state . params } onChange = { this . onParamsChange } data - test - subj = "<STR_LIT>" / > ) ; case '<STR_LIT>' : return ( < PhrasesValuesInput indexPattern = { indexPattern } field = { this . state . selectedField } values = { this . state . params } onChange = { this . onParamsChange } / > ) ; case '<STR_LIT>' : return ( < RangeValueInput field = { this . state . selectedField } value = { this . state . params } onChange = { this . onParamsChange } / > ) ; } } private toggleCustomEditor = ( ) = > { const isCustomEditorOpen =   ! this . state . isCustomEditorOpen ; this . setState ( { isCustomEditorOpen } ) ; } ; private isUnknownFilterType ( ) { const { type } = this . props . filter . meta ; return   !   ! type & &   ! [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( type ) ; } private getIndexPatternFromFilter ( ) { return getIndexPatternFromFilter ( this . props . filter , this . props . indexPatterns ) ; } private getFieldFromFilter ( ) { const indexPattern = this . getIndexPatternFromFilter ( ) ; return indexPattern & & getFieldFromFilter ( this . props . filter as FieldFilter , indexPattern ) ; } private getSelectedOperator ( ) { return getOperatorFromFilter ( this . props . filter ) ; } private isFilterValid ( ) { const { isCustomEditorOpen , queryDsl , selectedIndexPattern : indexPattern , selectedField : field , selectedOperator : operator , params , } = this . state ; if ( isCustomEditorOpen ) { try { return Boolean ( JSON . parse ( queryDsl ) ) ; } catch ( e ) { return false ; } } return isFilterValid ( indexPattern , field , operator , params ) ; } private onIndexPatternChange = ( [ selectedIndexPattern ] ) = > { const selectedField = undefined ; const selectedOperator = undefined ; const params = undefined ; this . setState ( { selectedIndexPattern , selectedField , selectedOperator , params } ) ; } ; private onFieldChange = ( [ selectedField ] ) = > { const selectedOperator = undefined ; const params = undefined ; this . setState ( { selectedField , selectedOperator , params } ) ; } ; private onOperatorChange = ( [ selectedOperator ] ) = > { const params = get ( this . state . selectedOperator , '<STR_LIT>' ) == = get ( selectedOperator , '<STR_LIT>' )   ? this . state . params : undefined ; this . setState ( { selectedOperator , params } ) ; } ; private onCustomLabelSwitchChange = ( event ) = > { const useCustomLabel = event . target . checked ; const customLabel = event . target . checked   ? '<STR_LIT>' : null ; this . setState ( { useCustomLabel , customLabel } ) ; } ; private onCustomLabelChange = ( event ) = > { const customLabel = event . target . value ; this . setState ( { customLabel } ) ; } ; private onParamsChange = ( params ) = > { this . setState ( { params } ) ; } ; private onQueryDslChange = ( queryDsl ) = > { this . setState ( { queryDsl } ) ; } ; private onSubmit = ( ) = > { const { selectedIndexPattern : indexPattern , selectedField : field , selectedOperator : operator , params , useCustomLabel , customLabel , isCustomEditorOpen , queryDsl , } = this . state ; const {   $ state } = this . props . filter ; if (   !   $ state | |   !   $ state . store ) { return ; } const alias = useCustomLabel   ? customLabel : null ; if ( isCustomEditorOpen ) { const { index , disabled , negate } = this . props . filter . meta ; const newIndex = index | | this . props . indexPatterns [ <NUM_LIT> ] . id   ! ; const body = JSON . parse ( queryDsl ) ; const filter = buildCustomFilter ( newIndex , body , disabled , negate , alias ,   $ state . store ) ; this . props . onSubmit ( filter ) ; } else if ( indexPattern & & field & & operator ) { const filter = buildFilter ( indexPattern , field , operator . type , operator . negate , this . props . filter . meta . disabled , params   ? ? '<STR_LIT>' , alias ,   $ state . store ) ; this . props . onSubmit ( filter ) ; } } ; } function IndexPatternComboBox ( props ) { return GenericComboBox ( props ) ; } function FieldComboBox ( props ) { return GenericComboBox ( props ) ; } function OperatorComboBox ( props ) { return GenericComboBox ( props ) ; } export const FilterEditor = injectI18n ( FilterEditorUI ) ; </s>
<s> import moment from '<STR_LIT>' ; <EOL> import { <EOL> keys <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimefilterContract <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RangeFilter , <EOL> TimeRange <EOL> } from '<STR_LIT>' ; <EOL> export function convertRangeFilterToTimeRange ( filter ) { <EOL> const key = keys ( filter . range ) [ <NUM_LIT> ] ; <EOL> const values = filter . range [ key ] ; <EOL> return { <EOL> from : moment ( values . gt | | values . gte ) , <EOL> to : moment ( values . lt | | values . lte ) , <EOL> } ; <EOL> } <EOL> export function convertRangeFilterToTimeRangeString ( filter ) { <EOL> const { <EOL> from , <EOL> to <EOL> } = convertRangeFilterToTimeRange ( filter ) ; <EOL> return { <EOL> from : from ? . toISOString ( ) , <EOL> to : to ? . toISOString ( ) , <EOL> } ; <EOL> } <EOL> export function changeTimeFilter ( timeFilter , filter ) { <EOL> timeFilter . setTime ( convertRangeFilterToTimeRange ( filter ) ) ; <EOL> } </s>
<s> import React , { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import PropTypes from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiTab , <EOL> EuiTabs <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RequestDetailsRequest , <EOL> RequestDetailsResponse , <EOL> RequestDetailsStats <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RequestDetailsProps <EOL> } from '<STR_LIT>' ; <EOL> interface RequestDetailsState { <EOL> availableDetails : DetailViewData [ ] ; selectedDetail : DetailViewData | null ; <EOL> } <EOL> export interface DetailViewData { <EOL> name : string ; label : string ; component : any ; <EOL> } <EOL> const DETAILS = [ { <EOL> name : '<STR_LIT>' , <EOL> label : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> component : RequestDetailsStats , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> label : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> component : RequestDetailsRequest , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> label : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> component : RequestDetailsResponse , <EOL> } , ] ; <EOL> export class RequestDetails extends Component < RequestDetailsProps , RequestDetailsState > { <EOL> static propTypes = { <EOL> request : PropTypes . object . isRequired , <EOL> } ; state = { <EOL> availableDetails : [ ] , <EOL> selectedDetail : null , <EOL> } ; static getDerivedStateFromProps ( nextProps , prevState ) { <EOL> const selectedDetail = prevState & & prevState . selectedDetail ; <EOL> const availableDetails = DETAILS . filter ( ( detail ) = >   ! detail . component . shouldShow | | detail . component . shouldShow ( nextProps . request ) ) ; <EOL> if ( selectedDetail & & availableDetails . includes ( selectedDetail ) ) { <EOL> return { <EOL> availableDetails <EOL> } ; <EOL> } <EOL> return { <EOL> availableDetails , <EOL> selectedDetail : availableDetails [ <NUM_LIT> ] , <EOL> } ; <EOL> } <EOL> selectDetailsTab = ( detail ) = > { <EOL> if ( detail != = this . state . selectedDetail ) { <EOL> this . setState ( { <EOL> selectedDetail : detail , <EOL> } ) ; <EOL> } <EOL> } ; static getSelectedDetailComponent ( detail ) { <EOL> return detail   ? detail . component : null ; <EOL> } <EOL> renderDetailTab = ( detail ) = > { <EOL> return ( < EuiTab key = { detail . name } isSelected = { detail == = this . state . selectedDetail } onClick = { ( ) = > this . selectDetailsTab ( detail ) } data - test - subj = {   ` inspectorRequestDetail $ { detail . name } ` } > { detail . label } < / EuiTab > ) ; } ; render ( ) { const { selectedDetail , availableDetails } = this . state ; const DetailComponent = RequestDetails . getSelectedDetailComponent ( selectedDetail ) ; if (   ! availableDetails . length | |   ! DetailComponent ) { return null ; } return ( < > < EuiTabs size = "<STR_LIT>" > { this . state . availableDetails . map ( this . renderDetailTab ) } < / EuiTabs > < DetailComponent request = { this . props . request } / > < / > ) ; } } </s>
<s> / ** <EOL> * Copyright ( c ) <NUM_LIT> , <NUM_LIT> Oracle and / or its affiliates . All rights reserved . <EOL> * This software is dual - licensed to you under the Universal Permissive License ( UPL ) <NUM_LIT> as shown at https : // oss . oracle . com / licenses / upl or Apache License <NUM_LIT> as shown at http : // www . apache . org / licenses / LICENSE - <NUM_LIT> . You may choose either license . <EOL> * / <EOL> import { <EOL> Readable <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ExponentialBackoffDelayStrategy , <EOL> MaxAttemptsTerminationStrategy , <EOL> WaiterConfigurationDetails , <EOL> delay , <EOL> WaitContextImpl , <EOL> ExponentialBackoffDelayStrategyWithJitter <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> HttpClient <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> HttpRequest <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> isReadableStream <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> handleErrorBody , <EOL> handleErrorResponse <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> OciError <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Logger <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> BooleanString <EOL> } from "<STR_LIT>" ; <EOL> / ** <EOL> * This class implements the retrier <EOL> * NOTE : Retries are not supported for requests that have binary or stream bodies <EOL> * this also affects UploadManager operations <EOL> * For all requests with binary / stream bodies , retry attempts will be made if RetryConfigurationDetails . backupBinaryBody <EOL> * is set to true , or if the original stream body is able to be retried <EOL> * <EOL> * / <EOL> export type RetryConfiguration = Partial < RetryConfigurationDetails > ; <EOL> export interface RetryConfigurationDetails extends WaiterConfigurationDetails { <EOL> retryCondition : ( response : OciError ) = > boolean ; backupBinaryBody : boolean ; <EOL> } <EOL> export class DefaultRetryCondition { <EOL> / ** <EOL> * Default retry condition for Retry mechanism <EOL> * NOTE : Retries are not supported for requests that have binary or stream bodies <EOL> * / <EOL> private static RETRYABLE_SERVICE_ERRORS : Map < number , string > = new Map ( [ <EOL> [ <NUM_LIT> , "<STR_LIT>" ] , <EOL> [ <NUM_LIT> , "<STR_LIT>" ] <EOL> ] ) ; <EOL> static shouldBeRetried ( error ) { <EOL> return ( error . statusCode == = <NUM_LIT> | | error . statusCode == = <NUM_LIT> | | error . statusCode == = <NUM_LIT> | | error . statusCode == = <NUM_LIT> | | error . statusCode == - <NUM_LIT> | | isNaN ( error . statusCode ) | | ( DefaultRetryCondition . RETRYABLE_SERVICE_ERRORS . has ( error . statusCode ) & & DefaultRetryCondition . RETRYABLE_SERVICE_ERRORS . get ( error . statusCode ) == = error . serviceCode ) ) ; <EOL> } <EOL> } <EOL> const NO_RETRY_MAXIMUM_NUMBER_OF_ATTEMPTS = <NUM_LIT> ; <EOL> const NO_RETRY_MAXIMUM_DELAY_IN_SECONDS = <NUM_LIT> ; <EOL> const OCI_SDK_DEFAULT_RETRY_MAXIMUM_NUMBER_OF_ATTEMPTS = <NUM_LIT> ; <EOL> const OCI_SDK_DEFAULT_RETRY_MAXIMUM_DELAY_IN_SECONDS = <NUM_LIT> ; <EOL> export const NoRetryConfigurationDetails = { <EOL> terminationStrategy : new MaxAttemptsTerminationStrategy ( NO_RETRY_MAXIMUM_NUMBER_OF_ATTEMPTS ) , <EOL> delayStrategy : new ExponentialBackoffDelayStrategyWithJitter ( NO_RETRY_MAXIMUM_DELAY_IN_SECONDS ) , <EOL> retryCondition : DefaultRetryCondition . shouldBeRetried , <EOL> backupBinaryBody : false <EOL> } ; <EOL> export const OciSdkDefaultRetryConfiguration = { <EOL> terminationStrategy : new MaxAttemptsTerminationStrategy ( OCI_SDK_DEFAULT_RETRY_MAXIMUM_NUMBER_OF_ATTEMPTS ) , <EOL> delayStrategy : new ExponentialBackoffDelayStrategyWithJitter ( OCI_SDK_DEFAULT_RETRY_MAXIMUM_DELAY_IN_SECONDS ) , <EOL> retryCondition : DefaultRetryCondition . shouldBeRetried , <EOL> backupBinaryBody : false <EOL> } ; <EOL> export class GenericRetrier { <EOL> private _retryConfiguration : RetryConfigurationDetails ; <EOL> private _logger : Logger = ( undefined as unknown ) as Logger ; <EOL> private static OPC_CLIENT_RETRIES_HEADER = "<STR_LIT>" ; <EOL> private static OCI_SDK_DEFAULT_RETRY_ENABLED = "<STR_LIT>" ; <EOL> constructor ( retryConfiguration ) { <EOL> const preferredRetryConfig = { <EOL> ... NoRetryConfigurationDetails , <EOL> ... retryConfiguration <EOL> } ; <EOL> this . _retryConfiguration = preferredRetryConfig ; <EOL> } <EOL> static get envVariableCheckForDefaultRetry ( ) : RetryConfiguration | null { <EOL> if ( process . env [ GenericRetrier . OCI_SDK_DEFAULT_RETRY_ENABLED ] == = BooleanString . FALSE ) { <EOL> return NoRetryConfigurationDetails ; <EOL> } else if ( process . env [ GenericRetrier . OCI_SDK_DEFAULT_RETRY_ENABLED ] == = BooleanString . TRUE ) { <EOL> return OciSdkDefaultRetryConfiguration ; <EOL> } else return null ; <EOL> } <EOL> private static DefaultRetryConfiguration : RetryConfiguration | null = GenericRetrier . envVariableCheckForDefaultRetry ; <EOL> static get defaultRetryConfiguration ( ) : RetryConfiguration | null { <EOL> return GenericRetrier . DefaultRetryConfiguration ; <EOL> } <EOL> static set defaultRetryConfiguration ( retryConfig ) { <EOL> GenericRetrier . DefaultRetryConfiguration = { <EOL> ... GenericRetrier . DefaultRetryConfiguration , <EOL> ... retryConfig <EOL> } ; <EOL> } <EOL> public set logger ( logger ) { <EOL> this . _logger = logger ; <EOL> } <EOL> public get backUpBinaryBody ( ) : boolean { <EOL> return this . retryConfiguration . backupBinaryBody ; <EOL> } <EOL> public get retryConfiguration ( ) : RetryConfigurationDetails { <EOL> return this . _retryConfiguration ; <EOL> } <EOL> public static createPreferredRetrier ( clientRetryConfiguration   ? , requestRetryConfiguration   ? , specRetryConfiguration   ? ) { <EOL> let retryConfigToUse = [ requestRetryConfiguration , clientRetryConfiguration , GenericRetrier . defaultRetryConfiguration ] . filter ( configuration = > configuration != = null & & configuration != = undefined ) [ <NUM_LIT> ] ; <EOL> retryConfigToUse = { <EOL> ... specRetryConfiguration , <EOL> ... retryConfigToUse <EOL> } ; <EOL> return new GenericRetrier ( retryConfigToUse ) ; <EOL> } <EOL> public async makeServiceCall ( httpClient , request , excludeBody   ? ) { <EOL> const waitContext = new WaitContextImpl ( ) ; <EOL> let lastKnownError ! ; <EOL> let shouldBeRetried = true ; <EOL> while ( true ) { <EOL> try { <EOL> this . addOpcClientRetryHeader ( request ) ; <EOL> const response = await httpClient . send ( request , excludeBody ) ; <EOL> if ( response . status & & response . status >= <NUM_LIT> & & response . status <= <NUM_LIT> ) { <EOL> return response ; <EOL> } else if ( ( response as any ) . code == = "<STR_LIT>" ) { <EOL> const circuitBreakerError = response ; <EOL> const errorObject = new OciError ( circuitBreakerError . code , "<STR_LIT>" , circuitBreakerError . message , "<STR_LIT>" ) ; <EOL> shouldBeRetried = this . retryConfiguration . retryCondition ( errorObject ) ; <EOL> lastKnownError = errorObject ; <EOL> } else { <EOL> const errBody = await handleErrorBody ( response ) ; <EOL> const errorObject = handleErrorResponse ( response , errBody ) ; <EOL> shouldBeRetried = this . retryConfiguration . retryCondition ( errorObject ) ; <EOL> lastKnownError = errorObject ; <EOL> } <EOL> } catch ( err ) { <EOL> lastKnownError = new OciError ( err . code , "<STR_LIT>" , err . message , "<STR_LIT>" ) ; <EOL> shouldBeRetried = true ; <EOL> } <EOL> if ( ! shouldBeRetried | |   ! GenericRetrier . isRequestRetryable ( request ) ) { <EOL> console . warn ( ` Request cannot be retried . Not Retrying . Exception occurred :   $ { lastKnownError } ` ) ; <EOL> throw lastKnownError ; <EOL> } else if ( this . retryConfiguration . terminationStrategy . shouldTerminate ( waitContext ) ) { <EOL> console . warn ( ` All retry attempts have exhausted . Total Attempts :   $ { waitContext . attemptCount + <NUM_LIT> } . Last exception occurred :   $ { lastKnownError } ` ) ; <EOL> throw lastKnownError ; <EOL> } <EOL> const delayTime = this . retryConfiguration . delayStrategy . delay ( waitContext ) ; <EOL> waitContext . attemptCount + + ; <EOL> console . warn ( ` Request failed with Exception :   $ { lastKnownError } \ nRetrying request -> Total Attempts :   $ { waitContext . attemptCount } , Retrying after   $ { delayTime } seconds ... ` ) ; <EOL> await delay ( delayTime ) ; <EOL> GenericRetrier . refreshRequest ( request ) ; <EOL> } <EOL> } <EOL> private static refreshRequest ( request ) { <EOL> request . headers . set ( "<STR_LIT>" , new Date ( ) . toUTCString ( ) ) ; <EOL> } <EOL> private addOpcClientRetryHeader ( request ) { <EOL> const terminationStrategy = this . retryConfiguration . terminationStrategy ; <EOL> const opcClientRetryHeader = request . headers . get ( GenericRetrier . OPC_CLIENT_RETRIES_HEADER ) ; <EOL> if ( terminationStrategy instanceof MaxAttemptsTerminationStrategy & & terminationStrategy . maxAttempts > <NUM_LIT> & & ( opcClientRetryHeader == = undefined | | opcClientRetryHeader == = null ) ) { <EOL> request . headers . set ( GenericRetrier . OPC_CLIENT_RETRIES_HEADER , "<STR_LIT>" ) ; <EOL> } <EOL> } <EOL> private static isRequestRetryable ( request ) { <EOL> if ( ! request . body ) return true ; <EOL> else if ( request . body ) { <EOL> return this . isRetryableStream ( request . body ) ; <EOL> } <EOL> } <EOL> private static isRetryableStream ( obj ) { <EOL> if ( obj instanceof Uint8Array | | obj instanceof Buffer | | typeof obj == = "<STR_LIT>" ) { <EOL> return true ; <EOL> } <EOL> return false ; <EOL> } <EOL> } </s>
<s> import { <EOL> isValidOpenSearchInterval <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> leastCommonInterval <EOL> } from '<STR_LIT>' ; <EOL> function parseWithBase ( value , baseInterval ) { <EOL> try { <EOL> const interval = leastCommonInterval ( baseInterval , value ) ; <EOL> return interval == = value . replace ( / \ s / g , '<STR_LIT>' ) ; <EOL> } catch ( e ) { <EOL> return false ; <EOL> } <EOL> } <EOL> export function isValidInterval ( value , baseInterval   ? ) { <EOL> if ( baseInterval ) { <EOL> return parseWithBase ( value , baseInterval ) ; <EOL> } else { <EOL> return isValidOpenSearchInterval ( value ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SavedObjectsClientCommon <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createIndexPatternCache <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPattern <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createEnsureDefaultIndexPattern , <EOL> EnsureDefaultIndexPattern , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OnNotification , <EOL> OnError , <EOL> OnUnsupportedTimePattern , <EOL> UiSettingsCommon , <EOL> IIndexPatternsApiClient , <EOL> GetFieldsOptions , <EOL> IndexPatternSpec , <EOL> IndexPatternAttributes , <EOL> FieldSpec , <EOL> FieldFormatMap , <EOL> IndexPatternFieldMap , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldFormatsStartCommon <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UI_SETTINGS , <EOL> SavedObject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SavedObjectNotFound <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternMissingIndices <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> findByTitle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DuplicateIndexPatternError <EOL> } from '<STR_LIT>' ; <EOL> const indexPatternCache = createIndexPatternCache ( ) ; <EOL> const MAX_ATTEMPTS_TO_RESOLVE_CONFLICTS = <NUM_LIT> ; <EOL> const savedObjectType = '<STR_LIT>' ; <EOL> export interface IndexPatternSavedObjectAttrs { <EOL> title : string ; <EOL> } <EOL> interface IndexPatternsServiceDeps { <EOL> uiSettings : UiSettingsCommon ; savedObjectsClient : SavedObjectsClientCommon ; apiClient : IIndexPatternsApiClient ; fieldFormats : FieldFormatsStartCommon ; onNotification : OnNotification ; onError : OnError ; onRedirectNoIndexPattern   ? : ( ) = > void ; onUnsupportedTimePattern : OnUnsupportedTimePattern ; <EOL> } <EOL> export class IndexPatternsService { <EOL> private config : UiSettingsCommon ; <EOL> private savedObjectsClient : SavedObjectsClientCommon ; <EOL> private savedObjectsCache   ? : Array < SavedObject < IndexPatternSavedObjectAttrs > > | null ; <EOL> private apiClient : IIndexPatternsApiClient ; <EOL> private fieldFormats : FieldFormatsStartCommon ; <EOL> private onNotification : OnNotification ; <EOL> private onError : OnError ; <EOL> private onUnsupportedTimePattern : OnUnsupportedTimePattern ; <EOL> ensureDefaultIndexPattern : EnsureDefaultIndexPattern ; <EOL> constructor ( { <EOL> uiSettings , <EOL> savedObjectsClient , <EOL> apiClient , <EOL> fieldFormats , <EOL> onNotification , <EOL> onError , <EOL> onUnsupportedTimePattern , <EOL> onRedirectNoIndexPattern = ( ) = > { } , <EOL> } ) { <EOL> this . apiClient = apiClient ; <EOL> this . config = uiSettings ; <EOL> this . savedObjectsClient = savedObjectsClient ; <EOL> this . fieldFormats = fieldFormats ; <EOL> this . onNotification = onNotification ; <EOL> this . onError = onError ; <EOL> this . onUnsupportedTimePattern = onUnsupportedTimePattern ; <EOL> this . ensureDefaultIndexPattern = createEnsureDefaultIndexPattern ( uiSettings , onRedirectNoIndexPattern ) ; <EOL> } <EOL> / ** <EOL> * Refresh cache of index pattern ids and titles <EOL> * / <EOL> private async refreshSavedObjectsCache ( ) { <EOL> this . savedObjectsCache = await this . savedObjectsClient . find < IndexPatternSavedObjectAttrs > ( { <EOL> type : '<STR_LIT>' , <EOL> fields : [ '<STR_LIT>' ] , <EOL> perPage : <NUM_LIT> , <EOL> } ) ; <EOL> } <EOL> param refresh getIds = async ( refresh = false ) = > { <EOL> if ( ! this . savedObjectsCache | | refresh ) { <EOL> await this . refreshSavedObjectsCache ( ) ; <EOL> } <EOL> if ( ! this . savedObjectsCache ) { <EOL> return [ ] ; <EOL> } <EOL> return this . savedObjectsCache . map ( ( obj ) = > obj ? . id ) ; <EOL> } ; <EOL> param refresh getTitles = async ( refresh = false ) : Promise < string [ ] > = > { <EOL> if ( ! this . savedObjectsCache | | refresh ) { <EOL> await this . refreshSavedObjectsCache ( ) ; <EOL> } <EOL> if ( ! this . savedObjectsCache ) { <EOL> return [ ] ; <EOL> } <EOL> return this . savedObjectsCache . map ( ( obj ) = > obj ? . attributes ? . title ) ; <EOL> } ; <EOL> param refresh getIdsWithTitle = async ( refresh = false ) : Promise < Array < { <EOL> id : string ; title : string ; <EOL> } > > = > { <EOL> if ( ! this . savedObjectsCache | | refresh ) { <EOL> await this . refreshSavedObjectsCache ( ) ; <EOL> } <EOL> if ( ! this . savedObjectsCache ) { <EOL> return [ ] ; <EOL> } <EOL> return this . savedObjectsCache . map ( ( obj ) = > ( { <EOL> id : obj ? . id , <EOL> title : obj ? . attributes ? . title , <EOL> } ) ) ; <EOL> } ; <EOL> param id clearCache = ( id   ? ) = > { <EOL> this . savedObjectsCache = null ; <EOL> if ( id ) { <EOL> indexPatternCache . clear ( id ) ; <EOL> } else { <EOL> indexPatternCache . clearAll ( ) ; <EOL> } <EOL> } ; <EOL> getCache = async ( ) = > { <EOL> if ( ! this . savedObjectsCache ) { <EOL> await this . refreshSavedObjectsCache ( ) ; <EOL> } <EOL> return this . savedObjectsCache ; <EOL> } ; <EOL> / ** <EOL> * Get default index pattern <EOL> * / <EOL> getDefault = async ( ) = > { <EOL> const defaultIndexPatternId = await this . config . get ( '<STR_LIT>' ) ; <EOL> if ( defaultIndexPatternId ) { <EOL> return await this . get ( defaultIndexPatternId ) ; <EOL> } <EOL> return null ; <EOL> } ; <EOL> param id param force setDefault = async ( id , force = false ) = > { <EOL> if ( force | |   ! this . config . get ( '<STR_LIT>' ) ) { <EOL> await this . config . set ( '<STR_LIT>' , id ) ; <EOL> } <EOL> } ; <EOL> private isFieldRefreshRequired ( specs   ? ) { <EOL> if ( ! specs ) { <EOL> return true ; <EOL> } <EOL> return Object . values ( specs ) . every ( ( spec ) = > { <EOL> const hasFieldCaps = '<STR_LIT>' in spec & & '<STR_LIT>' in spec ; <EOL> const hasDocValuesFlag = '<STR_LIT>' in spec ; <EOL> return   ! hasFieldCaps | |   ! hasDocValuesFlag ; <EOL> } ) ; <EOL> } <EOL> param options getFieldsForWildcard = async ( options = { } ) = > { <EOL> const metaFields = await this . config . get ( UI_SETTINGS . META_FIELDS ) ; <EOL> return this . apiClient . getFieldsForWildcard ( { <EOL> pattern : options . pattern , <EOL> metaFields , <EOL> type : options . type , <EOL> params : options . params | | { } , <EOL> } ) ; <EOL> } ; <EOL> param options getFieldsForIndexPattern = async ( indexPattern , options = { } ) = > this . getFieldsForWildcard ( { <EOL> pattern : indexPattern . title as string , <EOL> ... options , <EOL> type : indexPattern . type , <EOL> params : indexPattern . typeMeta & & indexPattern . typeMeta . params , <EOL> } ) ; <EOL> param indexPattern refreshFields = async ( indexPattern ) = > { <EOL> try { <EOL> const fields = await this . getFieldsForIndexPattern ( indexPattern ) ; <EOL> const scripted = indexPattern . getScriptedFields ( ) . map ( ( field ) = > field . spec ) ; <EOL> indexPattern . fields . replaceAll ( [ ... fields , ... scripted ] ) ; <EOL> } catch ( err ) { <EOL> if ( err instanceof IndexPatternMissingIndices ) { <EOL> this . onNotification ( { <EOL> title : ( err as any ) . message , <EOL> color : '<STR_LIT>' , <EOL> iconType : '<STR_LIT>' <EOL> } ) ; <EOL> } <EOL> this . onError ( err , { <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> id : indexPattern . id , <EOL> title : indexPattern . title <EOL> } , <EOL> } ) , <EOL> } ) ; <EOL> } <EOL> } ; <EOL> param fields param id param title param options private refreshFieldSpecMap = async ( fields , id , title , options ) = > { <EOL> const scriptdFields = Object . values ( fields ) . filter ( ( field ) = > field . scripted ) ; <EOL> try { <EOL> const newFields = await this . getFieldsForWildcard ( options ) ; <EOL> return this . fieldArrayToMap ( [ ... newFields , ... scriptdFields ] ) ; <EOL> } catch ( err ) { <EOL> if ( err instanceof IndexPatternMissingIndices ) { <EOL> this . onNotification ( { <EOL> title : ( err as any ) . message , <EOL> color : '<STR_LIT>' , <EOL> iconType : '<STR_LIT>' <EOL> } ) ; <EOL> return { } ; <EOL> } <EOL> this . onError ( err , { <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> id , <EOL> title <EOL> } , <EOL> } ) , <EOL> } ) ; <EOL> } <EOL> return fields ; <EOL> } ; <EOL> param fieldSpecs param fieldFormatMap private addFormatsToFields = ( fieldSpecs , fieldFormatMap ) = > { <EOL> Object . entries ( fieldFormatMap ) . forEach ( ( [ fieldName , value ] ) = > { <EOL> const field = fieldSpecs . find ( ( fld ) = > fld . name == = fieldName ) ; <EOL> if ( field ) { <EOL> field . format = value ; <EOL> } <EOL> } ) ; <EOL> } ; <EOL> param fields fieldArrayToMap = ( fields ) = > fields . reduce < IndexPatternFieldMap > ( ( collector , field ) = > { <EOL> collector [ field . name ] = field ; <EOL> return collector ; <EOL> } , { } ) ; <EOL> param savedObject savedObjectToSpec = ( savedObject ) : IndexPatternSpec = > { <EOL> const { <EOL> id , <EOL> version , <EOL> attributes : { <EOL> title , <EOL> timeFieldName , <EOL> intervalName , <EOL> fields , <EOL> sourceFilters , <EOL> fieldFormatMap , <EOL> typeMeta , <EOL> type , <EOL> } , <EOL> } = savedObject ; <EOL> const parsedSourceFilters = sourceFilters   ? JSON . parse ( sourceFilters ) : undefined ; <EOL> const parsedTypeMeta = typeMeta   ? JSON . parse ( typeMeta ) : undefined ; <EOL> const parsedFieldFormatMap = fieldFormatMap   ? JSON . parse ( fieldFormatMap ) : { } ; <EOL> const parsedFields = fields   ? JSON . parse ( fields ) : [ ] ; <EOL> this . addFormatsToFields ( parsedFields , parsedFieldFormatMap ) ; <EOL> return { <EOL> id , <EOL> version , <EOL> title , <EOL> intervalName , <EOL> timeFieldName , <EOL> sourceFilters : parsedSourceFilters , <EOL> fields : this . fieldArrayToMap ( parsedFields ) , <EOL> typeMeta : parsedTypeMeta , <EOL> type , <EOL> } ; <EOL> } ; <EOL> param id get = async ( id ) : Promise < IndexPattern > = > { <EOL> const cache = indexPatternCache . get ( id ) ; <EOL> if ( cache ) { <EOL> return cache ; <EOL> } <EOL> const savedObject = await this . savedObjectsClient . get < IndexPatternAttributes > ( savedObjectType , id ) ; <EOL> if ( ! savedObject . version ) { <EOL> throw new SavedObjectNotFound ( savedObjectType , id , '<STR_LIT>' ) ; <EOL> } <EOL> const spec = this . savedObjectToSpec ( savedObject ) ; <EOL> const { <EOL> title , <EOL> type , <EOL> typeMeta <EOL> } = spec ; <EOL> const parsedFieldFormats = savedObject . attributes . fieldFormatMap   ? JSON . parse ( savedObject . attributes . fieldFormatMap ) : { } ; <EOL> const isFieldRefreshRequired = this . isFieldRefreshRequired ( spec . fields ) ; <EOL> let isSaveRequired = isFieldRefreshRequired ; <EOL> try { <EOL> spec . fields = isFieldRefreshRequired   ? await this . refreshFieldSpecMap ( spec . fields | | { } , id , spec . title as string , { <EOL> pattern : title , <EOL> metaFields : await this . config . get ( UI_SETTINGS . META_FIELDS ) , <EOL> type , <EOL> params : typeMeta & & typeMeta . params , <EOL> } ) : spec . fields ; <EOL> } catch ( err ) { <EOL> isSaveRequired = false ; <EOL> if ( err instanceof IndexPatternMissingIndices ) { <EOL> this . onNotification ( { <EOL> title : ( err as any ) . message , <EOL> color : '<STR_LIT>' , <EOL> iconType : '<STR_LIT>' , <EOL> } ) ; <EOL> } else { <EOL> this . onError ( err , { <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> id , <EOL> title <EOL> } , <EOL> } ) , <EOL> } ) ; <EOL> } <EOL> } <EOL> Object . entries ( parsedFieldFormats ) . forEach ( ( [ fieldName , value ] ) = > { <EOL> const field = spec . fields ? . [ fieldName ] ; <EOL> if ( field ) { <EOL> field . format = value ; <EOL> } <EOL> } ) ; <EOL> const indexPattern = await this . create ( spec , true ) ; <EOL> indexPatternCache . set ( id , indexPattern ) ; <EOL> if ( isSaveRequired ) { <EOL> try { <EOL> this . updateSavedObject ( indexPattern ) ; <EOL> } catch ( err ) { <EOL> this . onError ( err , { <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> id : indexPattern . id , <EOL> title : indexPattern . title , <EOL> } , <EOL> } ) , <EOL> } ) ; <EOL> } <EOL> } <EOL> if ( indexPattern . isUnsupportedTimePattern ( ) ) { <EOL> this . onUnsupportedTimePattern ( { <EOL> id : indexPattern . id as string , <EOL> title : indexPattern . title , <EOL> index : indexPattern . getIndex ( ) , <EOL> } ) ; <EOL> } <EOL> indexPattern . resetOriginalSavedObjectBody ( ) ; <EOL> return indexPattern ; <EOL> } ; <EOL> migrate ( indexPattern , newTitle ) { <EOL> return this . savedObjectsClient . update < IndexPatternAttributes > ( savedObjectType , indexPattern . id ! , { <EOL> title : newTitle , <EOL> intervalName : null , <EOL> } , { <EOL> version : indexPattern . version , <EOL> } ) . then ( ( { <EOL> attributes : { <EOL> title , <EOL> intervalName <EOL> } <EOL> } ) = > { <EOL> indexPattern . title = title ; <EOL> indexPattern . intervalName = intervalName ; <EOL> } ) . then ( ( ) = > this ) ; <EOL> } <EOL> param spec param skipFetchFields async create ( spec , skipFetchFields = false ) { <EOL> const shortDotsEnable = await this . config . get ( UI_SETTINGS . SHORT_DOTS_ENABLE ) ; <EOL> const metaFields = await this . config . get ( UI_SETTINGS . META_FIELDS ) ; <EOL> const indexPattern = new IndexPattern ( { <EOL> spec , <EOL> savedObjectsClient : this . savedObjectsClient , <EOL> fieldFormats : this . fieldFormats , <EOL> shortDotsEnable , <EOL> metaFields , <EOL> } ) ; <EOL> if ( ! skipFetchFields ) { <EOL> await this . refreshFields ( indexPattern ) ; <EOL> } <EOL> return indexPattern ; <EOL> } <EOL> find = async ( search , size = <NUM_LIT> ) : Promise < IndexPattern [ ] > = > { <EOL> const savedObjects = await this . savedObjectsClient . find < IndexPatternSavedObjectAttrs > ( { <EOL> type : '<STR_LIT>' , <EOL> fields : [ '<STR_LIT>' ] , <EOL> search , <EOL> searchFields : [ '<STR_LIT>' ] , <EOL> perPage : size , <EOL> } ) ; <EOL> const getIndexPatternPromises = savedObjects . map ( async ( savedObject ) = > { <EOL> return await this . get ( savedObject . id ) ; <EOL> } ) ; <EOL> return await Promise . all ( getIndexPatternPromises ) ; <EOL> } ; <EOL> param spec param override param skipFetchFields async createAndSave ( spec , override = false , skipFetchFields = false ) { <EOL> const indexPattern = await this . create ( spec , skipFetchFields ) ; <EOL> await this . createSavedObject ( indexPattern , override ) ; <EOL> await this . setDefault ( indexPattern . id as string ) ; <EOL> return indexPattern ; <EOL> } <EOL> param indexPattern param override async createSavedObject ( indexPattern , override = false ) { <EOL> const dupe = await findByTitle ( this . savedObjectsClient , indexPattern . title ) ; <EOL> if ( dupe ) { <EOL> if ( override ) { <EOL> await this . delete ( dupe . id ) ; <EOL> } else { <EOL> throw new DuplicateIndexPatternError ( ` Duplicate index pattern :   $ { indexPattern . title } ` ) ; <EOL> } <EOL> } <EOL> const body = indexPattern . getAsSavedObjectBody ( ) ; <EOL> const response = await this . savedObjectsClient . create ( savedObjectType , body , { <EOL> id : indexPattern . id , <EOL> } ) ; <EOL> indexPattern . id = response . id ; <EOL> indexPatternCache . set ( indexPattern . id , indexPattern ) ; <EOL> return indexPattern ; <EOL> } <EOL> param indexPattern param saveAttempts async updateSavedObject ( indexPattern , saveAttempts = <NUM_LIT> , ignoreErrors = false ) { <EOL> if ( ! indexPattern . id ) return ; <EOL> const body = indexPattern . getAsSavedObjectBody ( ) ; <EOL> const originalBody = indexPattern . getOriginalSavedObjectBody ( ) ; <EOL> const originalChangedKeys = [ ] ; <EOL> Object . entries ( body ) . forEach ( ( [ key , value ] ) = > { <EOL> if ( value != = ( originalBody as any ) [ key ] ) { <EOL> originalChangedKeys . push ( key ) ; <EOL> } <EOL> } ) ; <EOL> return this . savedObjectsClient . update ( savedObjectType , indexPattern . id , body , { <EOL> version : indexPattern . version <EOL> } ) . then ( ( resp ) = > { <EOL> indexPattern . id = resp . id ; <EOL> indexPattern . version = resp . version ; <EOL> } ) . catch ( async ( err ) = > { <EOL> if ( err ? . res ? . status == = <NUM_LIT> & & saveAttempts + + < MAX_ATTEMPTS_TO_RESOLVE_CONFLICTS ) { const samePattern = await this . get ( indexPattern . id as string ) ; const updatedBody = samePattern . getAsSavedObjectBody ( ) ; const serverChangedKeys = [ ] ; Object . entries ( updatedBody ) . forEach ( ( [ key , value ] ) = > { if ( value != = ( body as any ) [ key ] & & value != = ( originalBody as any ) [ key ] ) { serverChangedKeys . push ( key ) ; } } ) ; let unresolvedCollision = false ; for ( const originalKey of originalChangedKeys ) { for ( const serverKey of serverChangedKeys ) { if ( originalKey == = serverKey ) { unresolvedCollision = true ; break ; } } } if ( unresolvedCollision ) { if ( ignoreErrors ) { return ; } const title = i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) ; this . onNotification ( { title , color : '<STR_LIT>' } ) ; throw err ; } serverChangedKeys . forEach ( ( key ) = > { ( indexPattern as any ) [ key ] = ( samePattern as any ) [ key ] ; } ) ; indexPattern . version = samePattern . version ; indexPatternCache . clear ( indexPattern . id   ! ) ; return this . updateSavedObject ( indexPattern , saveAttempts , ignoreErrors ) ; } throw err ; } ) ; } param indexPatternId async delete ( indexPatternId ) { indexPatternCache . clear ( indexPatternId ) ; return this . savedObjectsClient . delete ( '<STR_LIT>' , indexPatternId ) ; } } export type IndexPatternsContract = PublicMethodsOf < IndexPatternsService > ; </s>
<s> const verbosityLevels = { <EOL> debug : <NUM_LIT> , <EOL> info : <NUM_LIT> , <EOL> log : <NUM_LIT> , <EOL> warn : <NUM_LIT> , <EOL> error : <NUM_LIT> , <EOL> } ; <EOL> const logLevel = verbosityLevels . log ; <EOL> const printWithVerbosity = ( verbosity , ... values ) = > { <EOL> if ( logLevel <= verbosity & & process . env . NODE_ENV == = "<STR_LIT>" ) { <EOL> console . log ( ... values ) ; <EOL> } <EOL> } ; <EOL> const createPrinter = ( verbosity ) = > ( ... values ) = > printWithVerbosity ( verbosity , ... values ) ; <EOL> export default { <EOL> debug : createPrinter ( verbosityLevels . debug ) , <EOL> info : createPrinter ( verbosityLevels . info ) , <EOL> log : createPrinter ( verbosityLevels . log ) , <EOL> warn : createPrinter ( verbosityLevels . warn ) , <EOL> error : createPrinter ( verbosityLevels . error ) , <EOL> } ; </s>
<s> import React from "<STR_LIT>" ; <EOL> import { <EOL> StyledShortcutWrapper , <EOL> StyledShortcutName , <EOL> StyledShortcutKey , <EOL> } from "<STR_LIT>" ; <EOL> type Props = { <EOL> id : string ; name : string ; shortcutKey : string ; <EOL> } ; <EOL> const Shortcut = ( { <EOL> id , <EOL> name , <EOL> shortcutKey <EOL> } ) = > { <EOL> return ( < StyledShortcutWrapper > < StyledShortcutName htmlFor = { id } > { name } < / StyledShortcutName > < StyledShortcutKey type = "<STR_LIT>" value = { shortcutKey } id = { id } disabled / > < / StyledShortcutWrapper > ) ; } ; export default React . memo ( Shortcut ) ; </s>
<s> import { <EOL> downloadImageFromCanvas <EOL> } from '<STR_LIT>' ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> const ctx = canvas . getContext ( '<STR_LIT>' ) as CanvasRenderingContext2D ; <EOL> const opts = { <EOL> width : <NUM_LIT> , <EOL> height : <NUM_LIT> , <EOL> } ; <EOL> ctx . clearRect ( <NUM_LIT> , <NUM_LIT> , opts . width , opts . height ) ; <EOL> ctx . fillStyle = '<STR_LIT>' ; <EOL> ctx . fillRect ( <NUM_LIT> , <NUM_LIT> , opts . width / <NUM_LIT> , opts . height / <NUM_LIT> ) ; <EOL> test ( '<STR_LIT>' , async ( ) = > { <EOL> downloadImageFromCanvas ( canvas , { <EOL> filename : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> } ) ; <EOL> expect ( canvas ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> EuiLoadingContent , <EOL> EuiDelayRender <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> MarkdownSimpleProps <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> MarkdownProps <EOL> } from '<STR_LIT>' ; <EOL> const Fallback = ( ) = > ( < EuiDelayRender > < EuiLoadingContent lines = { <NUM_LIT> } / > < / EuiDelayRender > ) ; const LazyMarkdownSimple = React . lazy ( ( ) = > import ( '<STR_LIT>' ) ) ; export const MarkdownSimple = ( props ) = > ( < React . Suspense fallback = { < Fallback / > } > < LazyMarkdownSimple { ... props } / > < / React . Suspense > ) ; const LazyMarkdown = React . lazy ( ( ) = > import ( '<STR_LIT>' ) ) ; export const Markdown = ( props ) = > ( < React . Suspense fallback = { < Fallback / > } > < LazyMarkdown { ... props } / > < / React . Suspense > ) ; </s>
<s> import { <EOL> limitNum , <EOL> limitAngle <EOL> } from '<STR_LIT>' ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> test ( '<STR_LIT>' , ( ) = > { <EOL> const num1 = limitNum ( <NUM_LIT> / <NUM_LIT> ) ; <EOL> expect ( num1 ) . toStrictEqual ( <NUM_LIT> ) ; <EOL> const num2 = limitNum ( <NUM_LIT> / <NUM_LIT> ) ; <EOL> expect ( num2 ) . toStrictEqual ( <NUM_LIT> ) ; <EOL> const num3 = limitNum ( <NUM_LIT> * <NUM_LIT> ) ; <EOL> expect ( num3 ) . toStrictEqual ( <NUM_LIT> ) ; <EOL> } ) ; <EOL> test ( '<STR_LIT>' , ( ) = > { <EOL> const num1 = limitAngle ( <NUM_LIT> ) ; <EOL> expect ( num1 ) . toStrictEqual ( <NUM_LIT> ) ; <EOL> const num2 = limitAngle ( - <NUM_LIT> ) ; <EOL> expect ( num2 ) . toStrictEqual ( - <NUM_LIT> ) ; <EOL> const num3 = limitAngle ( - <NUM_LIT> ) ; <EOL> expect ( num3 ) . toStrictEqual ( - <NUM_LIT> ) ; <EOL> const num4 = limitAngle ( <NUM_LIT> ) ; <EOL> expect ( num4 ) . toStrictEqual ( <NUM_LIT> ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> </s>
<s> import IB , { <EOL> EventName , <EOL> Stock <EOL> } from '<STR_LIT>' ; <EOL> import isEmpty from '<STR_LIT>' ; <EOL> import findIndex from '<STR_LIT>' ; <EOL> import compact from '<STR_LIT>' ; <EOL> import { <EOL> CreateSale , <EOL> OrderWithContract , <EOL> OrderStatus , <EOL> OrderStatusType , <EOL> OrderStock , <EOL> GetOrderType , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> publishDataToTopic , <EOL> IbkrEvents , <EOL> IBKREVENTS <EOL> } from '<STR_LIT>' ; <EOL> import IBKRConnection from '<STR_LIT>' ; <EOL> import { <EOL> log , <EOL> verbose <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createSymbolAndTickerId <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> handleEventfulError <EOL> } from '<STR_LIT>' ; <EOL> const ibkrEvents = IbkrEvents . Instance ; <EOL> interface SymbolTickerOrder { <EOL> id : string ; tickerId : number ; orderPermId   ? : number ; symbol : string ; stockOrderRequest : OrderStock ; orderStatus   ? : OrderStatusType ; <EOL> } <EOL> export class Orders { <EOL> ib : IB = null ; tickerId = <NUM_LIT> ; processing = false ; <EOL> / ** <EOL> * Orders to be taken from nextValidId <EOL> * These are always deleted after order is submitted to IB <EOL> * / <EOL> stockOrders : OrderStock [ ] = [ ] ; timeoutRetries : { <EOL> [ x ] : NodeJS . Timeout [ ] ; <EOL> } = { } ; unique tickersAndOrders : SymbolTickerOrder [ ] = [ ] ; <EOL> / ** <EOL> * Redundant orderIdNext recorded <EOL> * / <EOL> orderIdNext : number = null ; public openedOrders : OrderWithContract [ ] = [ ] ; public receivedOrders = false ; private static _instance : Orders ; public static get Instance ( ) : Orders { <EOL> return this . _instance | | ( this . _instance = new this ( ) ) ; <EOL> } <EOL> private constructor ( ) { <EOL> const self = this ; <EOL> ibkrEvents . on ( IBKREVENTS . CONNECTED , async ( ) = > { <EOL> self . init ( ) ; <EOL> } ) ; <EOL> ibkrEvents . emit ( IBKREVENTS . PING ) ; <EOL> } <EOL> / ** <EOL> * init <EOL> * / <EOL> public init = async ( ) : Promise < void > = > { <EOL> const self = this ; <EOL> if ( ! self . ib ) { <EOL> const ib = IBKRConnection . Instance . getIBKR ( ) ; <EOL> self . ib = ib ; <EOL> ib . on ( EventName . openOrderEnd , ( ) = > { <EOL> publishDataToTopic ( { <EOL> topic : IBKREVENTS . OPEN_ORDERS , <EOL> data : self . openedOrders , <EOL> } ) ; <EOL> } ) ; <EOL> ib . on ( EventName . orderStatus , ( id , status , filled , remaining , avgFillPrice , permId , parentId , lastFillPrice , clientId , whyHeld ) = > { <EOL> const currentOrder = self . openedOrders . find ( ( oo ) = > oo . orderId == = id ) ; <EOL> const orderStatus = { <EOL> status : status as any , <EOL> filled , <EOL> remaining , <EOL> avgFillPrice , <EOL> permId , <EOL> parentId , <EOL> lastFillPrice , <EOL> clientId , <EOL> whyHeld : whyHeld as any , <EOL> } ; <EOL> publishDataToTopic ( { <EOL> topic : IBKREVENTS . ORDER_STATUS , <EOL> data : { <EOL> order : currentOrder , <EOL> orderStatus , <EOL> } , <EOL> } ) ; <EOL> verbose ( ` Orders > orderStatus   $ { currentOrder & & currentOrder . symbol } ` , JSON . stringify ( { <EOL> id , <EOL> status , <EOL> filled , <EOL> remaining , <EOL> symbol : currentOrder & & currentOrder . symbol , <EOL> } ) ) ; <EOL> } ) ; <EOL> ib . on ( EventName . openOrder , ( orderId , contract , order , orderState ) = > { <EOL> self . receivedOrders = true ; <EOL> const openedOrders = self . openedOrders ; <EOL> const currentOrderindex = findIndex ( openedOrders , { <EOL> orderId <EOL> } ) ; <EOL> openedOrders [ currentOrderindex ] = { <EOL> orderId , <EOL> orderState , <EOL> ... order , <EOL> ... contract , <EOL> } ; <EOL> self . openedOrders = compact ( openedOrders ) ; <EOL> if ( orderState . status == = '<STR_LIT>' ) { <EOL> log ( ` Filled - - - - -> DELETE FROM OPEN ORDERS - - - - - - -> symbol = $ { contract & & contract . symbol } ` ) ; <EOL> self . openedOrders = compact ( ( self . openedOrders | | [ ] ) . filter ( ( i ) = > i . orderId != = orderId ) ) ; <EOL> } <EOL> if ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( orderState . status ) ) { <EOL> log ( ` $ { orderState . status } - - - - -> DELETE FROM OPEN ORDERS - - - - - - ->   $ { contract & & contract . symbol } ` ) ; <EOL> self . openedOrders = compact ( ( self . openedOrders | | [ ] ) . filter ( ( i ) = > i . orderId != = orderId ) ) ; <EOL> } <EOL> const openOrdersArr = self . openedOrders ; <EOL> log ( ` OPEN ORDERS   $ { openOrdersArr & & openOrdersArr . length } ` ) ; <EOL> const allTickerOrder = self . tickersAndOrders ; <EOL> const thisOrderTicker = allTickerOrder . find ( ( tickerOrder ) = > tickerOrder . tickerId == = orderId ) ; <EOL> if ( ! isEmpty ( thisOrderTicker ) ) { <EOL> let updatedSymbolTicker = null ; <EOL> self . tickersAndOrders = self . tickersAndOrders . map ( ( i ) = > { <EOL> if ( i . tickerId == = orderId ) { <EOL> const updatedSymbolTickerX = { <EOL> ... i , <EOL> orderPermId : order . permId , <EOL> symbol : thisOrderTicker . symbol , <EOL> orderStatus : orderState . status as any , <EOL> } ; <EOL> updatedSymbolTicker = updatedSymbolTickerX ; <EOL> return updatedSymbolTickerX ; <EOL> } <EOL> return i ; <EOL> } ) ; <EOL> if ( orderState . status == = '<STR_LIT>' ) { <EOL> if ( ! isEmpty ( updatedSymbolTicker . stockOrderRequest ) ) { <EOL> const { <EOL> stockOrderRequest <EOL> } = updatedSymbolTicker ; <EOL> const { <EOL> exitTrade , <EOL> exitParams , <EOL> symbol , <EOL> capital <EOL> } = stockOrderRequest ; <EOL> const dataSaleSymbolOrder = { <EOL> ... order , <EOL> ... contract , <EOL> orderState , <EOL> orderId , <EOL> } ; <EOL> if ( exitTrade ) { <EOL> const { <EOL> exitPrice , <EOL> exitTime , <EOL> entryTime , <EOL> entryPrice <EOL> } = exitParams ; <EOL> const newSale = { <EOL> capital , <EOL> exitPrice , <EOL> exitTime , <EOL> entryTime , <EOL> entryPrice , <EOL> symbol , <EOL> profit : entryPrice - exitPrice , <EOL> } ; <EOL> log ( ` AccountOrderStock . openOrder ` ,   ` FILLED , TO CREATE SALE ->   $ { contract . symbol }   $ { order . action }   $ { order . totalQuantity }     $ { orderState . status } ` ) ; <EOL> return publishDataToTopic ( { <EOL> topic : IBKREVENTS . ORDER_FILLED , <EOL> data : { <EOL> sale : newSale , <EOL> order : dataSaleSymbolOrder <EOL> } , <EOL> } ) ; <EOL> } <EOL> log ( ` AccountOrderStock . openOrder ` ,   ` FILLED , but no sale created ->   $ { contract . symbol }   $ { order . action }   $ { order . totalQuantity }     $ { orderState . status } ` ) ; <EOL> publishDataToTopic ( { <EOL> topic : IBKREVENTS . ORDER_FILLED , <EOL> data : { <EOL> sale : null , <EOL> order : dataSaleSymbolOrder <EOL> } , <EOL> } ) ; <EOL> } <EOL> } <EOL> } <EOL> } ) ; <EOL> ibkrEvents . on ( IBKREVENTS . PLACE_ORDER , async ( { <EOL> stockOrder <EOL> } ) = > { <EOL> await self . placeOrder ( stockOrder ) ; <EOL> } ) ; <EOL> } <EOL> } ; public getOpenOrders = async ( ) : Promise < OrderWithContract [ ] > = > { <EOL> const self = this ; <EOL> const openedOrders = [ ] ; <EOL> return new Promise ( ( resolve ) = > { <EOL> let done = false ; <EOL> const handleOpenOrders = ( ordersData ) = > { <EOL> if ( ! done ) { <EOL> self . ib . off ( EventName . openOrder , handleOpenOrders ) ; <EOL> self . ib . off ( EventName . openOrderEnd , openOrderEnd ) ; <EOL> done = true ; <EOL> self . openedOrders = ordersData ; <EOL> return resolve ( ordersData ) ; <EOL> } <EOL> } ; <EOL> const openOrderEnd = ( ) = > { <EOL> handleOpenOrders ( openedOrders ) ; <EOL> } ; <EOL> self . ib . once ( EventName . openOrderEnd , openOrderEnd ) ; <EOL> self . ib . on ( EventName . openOrder , function ( orderId , contract , order , orderState ) { <EOL> if ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( orderState . status ) ) { <EOL> openedOrders . push ( { <EOL> orderId , <EOL> orderState , <EOL> ... order , <EOL> ... contract , <EOL> } ) ; <EOL> } <EOL> } ) ; <EOL> self . ib . reqAllOpenOrders ( ) ; <EOL> return ; <EOL> } ) ; <EOL> } ; public isActive = ( ) : boolean = > { <EOL> return this . receivedOrders ; <EOL> } ; stockOrder options when public placeOrder = async ( stockOrder , options   ? ) : Promise < any > = > { <EOL> const self = this ; <EOL> const ib = self . ib ; <EOL> const { <EOL> symbol <EOL> } = stockOrder ; <EOL> const shouldBeUniqueOrder = ( options & & options . unique ) | | false ; <EOL> const success = ( ) : boolean = > { <EOL> ib . off ( EventName . nextValidId , handleOrderIdNext ) ; <EOL> self . processing = false ; <EOL> return true ; <EOL> } ; <EOL> const erroredOut = ( error   ? ) : boolean = > { <EOL> ib . off ( EventName . nextValidId , handleOrderIdNext ) ; <EOL> self . processing = false ; <EOL> return false ; <EOL> } ; <EOL> const checkPending = ( ) : boolean = > { <EOL> const orderSize = stockOrder . size ; <EOL> const orderIsPending = ( ) = > { <EOL> log ( '<STR_LIT>' ,   ` ** ** ** ** ** ** ** ** ** ** ** * Order is already being processed for   $ { stockOrder . action } symbol = $ { symbol }   ` ) ; <EOL> return erroredOut ( ) ; <EOL> } ; <EOL> if ( Number . isNaN ( orderSize ) ) { <EOL> log ( '<STR_LIT>' ,   ` ** ** ** ** ** ** ** ** ** ** ** * orderSize is NaN size = $ { orderSize } action = $ { stockOrder . action } symbol = $ { symbol } ` ) ; <EOL> return erroredOut ( ) ; <EOL> } <EOL> / ** <EOL> * Check existing orders from tickersAndOrders <EOL> * / <EOL> const currentOpenOrders = self . tickersAndOrders ; <EOL> const currentOpenOrdersSymbolId = currentOpenOrders . filter ( ( cos ) = > cos . symbol == = symbol ) ; <EOL> verbose ( '<STR_LIT>' , JSON . stringify ( currentOpenOrdersSymbolId . map ( ( o ) = > o . symbol ) ) ) ; <EOL> if ( ! isEmpty ( currentOpenOrdersSymbolId ) ) { <EOL> const existingOrdersStatuses = currentOpenOrdersSymbolId . map ( ( i ) = > i . orderStatus ) ; <EOL> const allOrdersThatArePending = existingOrdersStatuses . filter ( ( status ) = > [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( status ) ) ; <EOL> if ( shouldBeUniqueOrder ) { <EOL> if ( ! isEmpty ( allOrdersThatArePending ) ) { <EOL> return orderIsPending ( ) ; <EOL> } <EOL> } <EOL> } <EOL> / ** <EOL> * Check existing opened placed orders <EOL> * / <EOL> const checkExistingOrders = self . openedOrders ; <EOL> log ( '<STR_LIT>' ,   ` Existing orders in queue ->   $ { ( checkExistingOrders | | [ ] ) . map ( ( i ) = > i . symbol ) } ` ) ; <EOL> if ( ! isEmpty ( checkExistingOrders ) ) { <EOL> const findMatchingAction = checkExistingOrders . filter ( ( exi ) = > exi . action == = stockOrder . action & & exi . symbol == = stockOrder . symbol ) ; <EOL> if ( ! isEmpty ( findMatchingAction ) ) { <EOL> if ( shouldBeUniqueOrder ) { <EOL> log ( '<STR_LIT>' ,   ` Order already exist for   $ { stockOrder . action } ,   $ { findMatchingAction [ <NUM_LIT> ] . symbol } -> @ $ { stockOrder . parameters [ <NUM_LIT> ] } ` ) ; <EOL> return erroredOut ( ) ; <EOL> } <EOL> } <EOL> } <EOL> return true ; <EOL> } ; <EOL> const handleOrderIdNext = ( orderIdNext ) = > { <EOL> const tickerToUse = + + orderIdNext ; <EOL> const currentOrders = self . stockOrders ; <EOL> if ( isEmpty ( currentOrders ) ) { <EOL> log ( '<STR_LIT>' ,   ` Stock Orders are empty ` ) ; <EOL> return erroredOut ( ) ; <EOL> } <EOL> const stockOrder = self . stockOrders . shift ( ) ; <EOL> if ( isEmpty ( stockOrder ) ) { <EOL> log ( '<STR_LIT>' ,   ` First Stock Orders Item is empty ` ) ; <EOL> return erroredOut ( ) ; <EOL> } <EOL> const { <EOL> symbol , <EOL> size <EOL> } = stockOrder ; <EOL> const StockOrderType = GetOrderType ( stockOrder . type ) ; <EOL> const orderCommand = StockOrderType ; <EOL> const args = stockOrder . parameters ; <EOL> if ( isEmpty ( args ) ) { <EOL> log ( '<STR_LIT>' ,   ` Arguments cannot be null ` ) ; <EOL> return erroredOut ( ) ; <EOL> } <EOL> const tickerIdWithSymbol = createSymbolAndTickerId ( symbol , tickerToUse ) ; <EOL> const oldTickerSymbol = self . tickersAndOrders . find ( ( t ) = > t . id == = tickerIdWithSymbol ) ; <EOL> if ( oldTickerSymbol ) { <EOL> log ( '<STR_LIT>' ,   ` Order already exists ` ) ; <EOL> return erroredOut ( ) ; <EOL> } <EOL> const tickerNOrder = { <EOL> id : tickerIdWithSymbol , <EOL> tickerId : tickerToUse , <EOL> symbol , <EOL> orderStatus : '<STR_LIT>' , <EOL> stockOrderRequest : stockOrder , <EOL> } ; <EOL> ib . placeOrder ( tickerToUse , new Stock ( stockOrder . symbol ) , new orderCommand ( stockOrder . action , ... args ) ) ; <EOL> self . tickersAndOrders . push ( tickerNOrder ) ; <EOL> self . tickerId = tickerToUse ; <EOL> ib . reqAllOpenOrders ( ) ; <EOL> log ( '<STR_LIT>' ,   ` Placing order for ... tickerToUse = $ { tickerToUse } orderIdNext = $ { orderIdNext } tickerId = $ { self . tickerId } symbol = $ { symbol } size = $ { size } ` ) ; <EOL> return success ( ) ; <EOL> } ; <EOL> function placingOrderNow ( ) { <EOL> if ( isEmpty ( stockOrder . symbol ) ) { <EOL> erroredOut ( new Error ( '<STR_LIT>' ) ) ; <EOL> return ; <EOL> } <EOL> self . stockOrders . push ( stockOrder ) ; <EOL> self . ib . reqIds ( + + self . orderIdNext ) ; <EOL> verbose ( '<STR_LIT>' ,   ` Order > placeOrder -> tickerId = $ { self . tickerId } symbol = $ { stockOrder . symbol } ` ) ; <EOL> } <EOL> async function run ( ) { <EOL> const canProceed = await checkPending ( ) ; <EOL> if ( canProceed == = true ) { <EOL> if ( self . processing ) { <EOL> return log ( ` Broker is already processing an order for   $ { self . tickerId } ` , symbol ) ; <EOL> } <EOL> self . processing = true ; <EOL> ib . on ( EventName . nextValidId , handleOrderIdNext ) ; <EOL> return placingOrderNow ( ) ; <EOL> } <EOL> } <EOL> return run ( ) ; <EOL> } ; param orderId cancelOrder = async ( orderId ) : Promise < boolean > = > { <EOL> const self = this ; <EOL> const ib = self . ib ; <EOL> return new Promise ( ( res ) = > { <EOL> const handleResults = ( r ) = > { <EOL> if ( r ) { <EOL> self . openedOrders = compact ( ( self . openedOrders | | [ ] ) . filter ( ( i ) = > i . orderId != = orderId ) ) ; <EOL> } <EOL> res ( r ) ; <EOL> handleError ( ) ; <EOL> } ; <EOL> const handleError = handleEventfulError ( undefined , [ ` OrderId   $ { orderId } that needs to be cancelled is not found ` ] , ( ) = > handleResults ( false ) ) ; <EOL> ib . cancelOrder ( orderId ) ; <EOL> setTimeout ( ( ) = > handleResults ( true ) , <NUM_LIT> ) ; <EOL> } ) ; <EOL> } ; <EOL> } <EOL> export default Orders ; </s>
<s> import { <EOL> DomainEvents <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> prisma <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> User <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UserEmail <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UserMap <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IUserRepo <EOL> } from '<STR_LIT>' ; <EOL> export class PrismaUserRepo implements IUserRepo { <EOL> async findByEmail ( email ) { <EOL> const rawUser = await prisma . user . findOne ( { <EOL> where : { <EOL> email : email instanceof UserEmail   ? email . value : email , <EOL> } , <EOL> } ) ; <EOL> if ( ! rawUser ) { <EOL> return null ; <EOL> } <EOL> return UserMap . toDomain ( rawUser ) ; <EOL> } <EOL> async findById ( id ) { <EOL> const rawUser = await prisma . user . findOne ( { <EOL> where : { <EOL> id <EOL> } , <EOL> } ) ; <EOL> if ( ! rawUser ) { <EOL> return null ; <EOL> } <EOL> return UserMap . toDomain ( rawUser ) ; <EOL> } <EOL> async save ( user ) { <EOL> const data = await UserMap . toPersistence ( user ) ; <EOL> await prisma . user . upsert ( { <EOL> where : { <EOL> email : user . email . value <EOL> } , <EOL> update : data , <EOL> create : data , <EOL> } ) ; <EOL> DomainEvents . dispatchEventsForAggregate ( user . id ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggType , <EOL> AggTypeConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggParamType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldTypes <EOL> } from '<STR_LIT>' ; <EOL> export interface IMetricAggConfig extends AggConfig { <EOL> type : InstanceType < typeof MetricAggType > ; <EOL> } <EOL> export interface MetricAggParam < TMetricAggConfig extends AggConfig > extends AggParamType < TMetricAggConfig > { <EOL> filterFieldTypes   ? : FieldTypes ; onlyAggregatable   ? : boolean ; <EOL> } <EOL> const metricType = '<STR_LIT>' ; <EOL> interface MetricAggTypeConfig < TMetricAggConfig extends AggConfig > extends AggTypeConfig < TMetricAggConfig , MetricAggParam < TMetricAggConfig > > { <EOL> isScalable   ? : ( ) = > boolean ; subtype   ? : string ; <EOL> } <EOL> export type IMetricAggType = MetricAggType ; <EOL> export class MetricAggType < TMetricAggConfig extends AggConfig = IMetricAggConfig > extends AggType < TMetricAggConfig , MetricAggParam < TMetricAggConfig > > { <EOL> subtype : string ; isScalable : ( ) = > boolean ; type = metricType ; getKey = ( ) = > { } ; constructor ( config ) { <EOL> super ( config ) ; <EOL> this . getValue = config . getValue | | ( ( agg , bucket ) = > { <EOL> const isSettableToZero = [ METRIC_TYPES . CARDINALITY , METRIC_TYPES . SUM ] . includes ( agg . type . name as METRIC_TYPES ) ; <EOL> if ( ! bucket [ agg . id ] & & isSettableToZero ) return <NUM_LIT> ; <EOL> return bucket [ agg . id ] & & bucket [ agg . id ] . value ; <EOL> } ) ; <EOL> this . subtype = config . subtype | | i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> this . isScalable = config . isScalable | | ( ( ) = > false ) ; <EOL> } <EOL> } <EOL> export function isMetricAggType ( aggConfig ) { <EOL> return aggConfig & & aggConfig . type == = metricType ; <EOL> } </s>
<s> import * as parsingLib from "<STR_LIT>" ; <EOL> import { <EOL> Program <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Range <EOL> } from "<STR_LIT>" ; <EOL> export type Parser = ( source : string , options   ? : ParserOptions , cache   ? : ParseCache , module   ? : boolean ) = > Program ; <EOL> interface ParseErrorDetail { <EOL> message : string ; lineNumber : number ; description : string ; index : number ; column : number ; <EOL> } <EOL> export class ParseError extends Error { <EOL> constructor ( public error ) { <EOL> super ( error . message ) ; <EOL> } <EOL> } <EOL> type ParserOptions = { <EOL> range   ? : boolean ; comment   ? : boolean ; attachComment   ? : boolean ; loc   ? : boolean ; <EOL> } ; <EOL> function parseWithLib ( source , options = { } , module = false ) { <EOL> try { <EOL> const { <EOL> parse , <EOL> parseModule <EOL> } = parsingLib ; <EOL> return ( module   ? parseModule : parse ) ( source , { <EOL> range : true , <EOL> ranges : true , <EOL> comment : true , <EOL> next : true , <EOL> attachComment : true , <EOL> loc : true , <EOL> ... options <EOL> } ) ; <EOL> } catch ( e ) { <EOL> throw new ParseError ( e ) ; <EOL> } <EOL> } <EOL> export const parse = ( source , options = { } , cache   ? , module = false ) = > { <EOL> let ast ; <EOL> if ( cache ) { <EOL> if ( ( ast = cache . get ( source ) ) ) { <EOL> return ast ; <EOL> } else { <EOL> return cache . set ( source , parseWithLib ( source , options , module ) as Program ) ; <EOL> } <EOL> } else { <EOL> return parseWithLib ( source , options , module ) ; <EOL> } <EOL> } ; <EOL> export let defaultSource = ( source ) = > ( range ) = > source . substring ( range [ <NUM_LIT> ] , range [ <NUM_LIT> ] ) ; <EOL> export type ParseCache = ReturnType < typeof createCache > ; <EOL> export function createCache ( ) { <EOL> const cache = { } ; <EOL> return { <EOL> get ( source ) { <EOL> return cache [ source ] ; <EOL> } , <EOL> set ( source , value ) { <EOL> return ( cache [ source ] = value ) ; <EOL> } <EOL> } ; <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> EuiIcon <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> export type ResizerMouseEvent = React . MouseEvent < HTMLButtonElement , MouseEvent > ; <EOL> export type ResizerKeyDownEvent = React . KeyboardEvent < HTMLButtonElement > ; <EOL> export interface Props { <EOL> onKeyDown : ( eve : ResizerKeyDownEvent ) = > void ; onMouseDown : ( eve : ResizerMouseEvent ) = > void ; className   ? : string ; <EOL> } <EOL> export function Resizer ( props ) { <EOL> return ( < button { ... props } data - test - subj = "<STR_LIT>" aria - label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } > < EuiIcon type = "<STR_LIT>" / > < / button > ) ; } </s>
<s> import { <EOL> AggregateRoot <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ProductWasAddedEvent <EOL> } from '<STR_LIT>' ; <EOL> export class ProductAggregate extends AggregateRoot { <EOL> constructor ( private readonly sku ) { <EOL> super ( ) ; <EOL> } <EOL> public registerProduct ( sku , name , price , currency ) { <EOL> this . apply ( new ProductWasAddedEvent ( sku , name , price , currency ) ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> ArgumentType <EOL> } from '<STR_LIT>' ; <EOL> export class ExpressionFunctionParameter { <EOL> name : string ; required : boolean ; help : string ; types : string [ ] ; default : any ; aliases : string [ ] ; multi : boolean ; resolve : boolean ; options : any [ ] ; constructor ( name , arg ) { <EOL> const { <EOL> required , <EOL> help , <EOL> types , <EOL> aliases , <EOL> multi , <EOL> resolve , <EOL> options <EOL> } = arg ; <EOL> if ( name == = '<STR_LIT>' ) { <EOL> throw Error ( '<STR_LIT>' ) ; <EOL> } <EOL> this . name = name ; <EOL> this . required =   ! ! required ; <EOL> this . help = help | | '<STR_LIT>' ; <EOL> this . types = types | | [ ] ; <EOL> this . default = arg . default ; <EOL> this . aliases = aliases | | [ ] ; <EOL> this . multi =   ! ! multi ; <EOL> this . resolve = resolve == null   ? true : resolve ; <EOL> this . options = options | | [ ] ; <EOL> } <EOL> accepts ( type ) { <EOL> if ( ! this . types . length ) return true ; <EOL> return this . types . indexOf ( type ) > - <NUM_LIT> ; <EOL> } <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> Switch , <EOL> Route , <EOL> Redirect <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> LoginForm <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SignupForm <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import { <EOL> useAuth <EOL> } from '<STR_LIT>' ; <EOL> export const UnauthenticatedLayout = ( ) = > { <EOL> const { <EOL> login <EOL> } = useAuth ( ) ; <EOL> return ( < div className = "<STR_LIT>" > < div > < Switch > < Route path = "<STR_LIT>" > < LoginForm onAuthenticated = { login } / > < / Route > < Route path = "<STR_LIT>" > < SignupForm onAuthenticated = { login } / > < / Route > < Redirect to = "<STR_LIT>" / > < / Switch > < / div > < / div > ) ; } ; </s>
<s> import { <EOL> PagePlugin <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> GraphQLSchemaPlugin <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> loadDynamicPage <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> DynamicPage <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> interpolateValue <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> IndexPageDataPlugin <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> SearchPublishedPagesPlugin <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ContextPlugin <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> PbContext <EOL> } from "<STR_LIT>" ; <EOL> export default ( ) = > [ new ContextPlugin < PbContext > ( async ( context ) = > { <EOL> / ** <EOL> * Store "<STR_LIT>" flag into DB if page URL is a pattern <EOL> * / <EOL> context . pageBuilder . onBeforePageUpdate . subscribe ( async ( params ) = > { <EOL> const { <EOL> page <EOL> } = params ; <EOL> if ( page . path & & page . path . includes ( "<STR_LIT>" ) ) { <EOL> ( page as any ) . dynamic = true ; <EOL> } <EOL> } ) ; <EOL> } ) , new PagePlugin < DynamicPage > ( { <EOL> async notFound ( { <EOL> args , <EOL> context <EOL> } ) { <EOL> return await loadDynamicPage ( args , context ) ; <EOL> } <EOL> } ) , new IndexPageDataPlugin < DynamicPage > ( ( { <EOL> page , <EOL> data <EOL> } ) = > { <EOL> data . dynamic = page . dynamic ; <EOL> } ) , new SearchPublishedPagesPlugin ( { <EOL> modifyQuery ( { <EOL> query , <EOL> args <EOL> } ) { <EOL> const { <EOL> where <EOL> } = args ; <EOL> if ( where & & where . dynamic ) { <EOL> query . filter . push ( { <EOL> term : { <EOL> dynamic : where . dynamic <EOL> } <EOL> } ) ; <EOL> } <EOL> } <EOL> } ) , new GraphQLSchemaPlugin ( { <EOL> typeDefs :   ` <EOL> extend type PbPage { <EOL> dynamic : Boolean <EOL> } <EOL> extend type PbPageListItem { <EOL> dynamic : Boolean <EOL> } <EOL>                 ` , <EOL> resolvers : { <EOL> PbPage : { <EOL> title ( page ) { <EOL> if ( page . dynamic & & page . title . includes ( "<STR_LIT>" ) & & Array . isArray ( page . dataSources ) ) { <EOL> const [ ds ] = page . title . substring ( <NUM_LIT> , page . title . length - <NUM_LIT> ) . split ( "<STR_LIT>" ) ; <EOL> const dataSource = page . dataSources . find ( d = > d . id == = ds ) ; <EOL> if ( dataSource ) { <EOL> return interpolateValue ( page . title , dataSource . data ) ; <EOL> } <EOL> } <EOL> return page . title ; <EOL> } <EOL> } <EOL> } <EOL> } ) ] ; </s>
<s> import { <EOL> createUseStyles <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IconProps , <EOL> IconSize <EOL> } from '<STR_LIT>' ; <EOL> const useStyles = createUseStyles ( { <EOL> icon : ( { <EOL> iconSize <EOL> } ) = > ( { <EOL> backgroundColor : '<STR_LIT>' , <EOL> color : '<STR_LIT>' , <EOL> display : '<STR_LIT>' , <EOL> fill : '<STR_LIT>' , <EOL> height : iconSize , <EOL> verticalAlign : '<STR_LIT>' , <EOL> width : iconSize , <EOL> '<STR_LIT>' : { <EOL> fill : '<STR_LIT>' , <EOL> height : '<STR_LIT>' , <EOL> width : '<STR_LIT>' , <EOL> '<STR_LIT>' : { <EOL> all : '<STR_LIT>' <EOL> } <EOL> } <EOL> } ) <EOL> } ) ; <EOL> export const Icon = ( props ) : JSX . Element = > { <EOL> const { <EOL> className = '<STR_LIT>' , name = '<STR_LIT>' , size : propSize = '<STR_LIT>' <EOL> } = props ; <EOL> const size = propSize . toLowerCase ( ) . trim ( ) as IconSize ; <EOL> let iconSize ; <EOL> switch ( size ) { <EOL> case '<STR_LIT>' : <EOL> iconSize = <NUM_LIT> ; <EOL> break ; <EOL> case '<STR_LIT>' : <EOL> iconSize = <NUM_LIT> ; <EOL> break ; <EOL> case '<STR_LIT>' : <EOL> iconSize = <NUM_LIT> ; <EOL> break ; <EOL> case '<STR_LIT>' : <EOL> iconSize = <NUM_LIT> ; <EOL> break ; <EOL> default : <EOL> iconSize = <NUM_LIT> ; <EOL> break ; <EOL> } <EOL> const classes = useStyles ( { <EOL> iconSize <EOL> } ) ; <EOL> const styleClasses = [ name , classes . icon , className ] ; <EOL> const useTag =   ` < use xlink : href = "<STR_LIT>" / > ` ; <EOL> return < svg className = { styleClasses . join ( '<STR_LIT>' ) } dangerouslySetInnerHTML = { { __html : useTag } } / > ; <EOL> } ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent , <EOL> ReactNode <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> globalColors <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ClientBrowser <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> BrowserIcon <EOL> } from "<STR_LIT>" ; <EOL> interface Props { <EOL> displayName : string ; browser : ClientBrowser ; controllers : ReactNode ; <EOL> } <EOL> const StreamController = ( { <EOL> displayName , <EOL> browser , <EOL> controllers , <EOL> } ) = > ( < div css = { wrapperStyle } > < div css = { rowStyle } > < BrowserIcon { ... browser } / > & nbsp ; { displayName } < / div > < div css = { rowStyle } > { controllers } < / div > < / div > ) ; export default StreamController ; const wrapperStyle = css ( { display : "<STR_LIT>" , gridTemplateColumns : "<STR_LIT>" , padding : <NUM_LIT> , color : globalColors . white , backgroundColor : "<STR_LIT>" , fontSize : "<STR_LIT>" , } ) ; const rowStyle = css ( { display : "<STR_LIT>" , alignItems : "<STR_LIT>" , } ) ; </s>
<s> import { <EOL> EuiBadge , <EOL> useInnerText <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import React , { <EOL> FC <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FilterLabel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter , <EOL> isFilterPinned <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> FilterLabelStatus <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> filter : Filter ; valueLabel : string ; filterLabelStatus : FilterLabelStatus ; errorMessage   ? : string ; <EOL> [ propName ] : any ; <EOL> } <EOL> export const FilterView = ( { <EOL> filter , <EOL> iconOnClick , <EOL> onClick , <EOL> valueLabel , <EOL> errorMessage , <EOL> filterLabelStatus , <EOL> ... rest <EOL> } ) = > { <EOL> const [ ref , innerText ] = useInnerText ( ) ; <EOL> let title = errorMessage | | i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> innerText <EOL> } , <EOL> } ) ; <EOL> if ( isFilterPinned ( filter ) ) { <EOL> title =   ` $ { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) }   $ { title } ` ; <EOL> } <EOL> if ( filter . meta . disabled ) { <EOL> title =   ` $ { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) }   $ { title } ` ; <EOL> } <EOL> return ( < EuiBadge title = { title } color = "<STR_LIT>" iconType = "<STR_LIT>" iconSide = "<STR_LIT>" closeButtonProps = { { tabIndex : - <NUM_LIT> , } } iconOnClick = { iconOnClick } iconOnClickAriaLabel = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } onClick = { onClick } onClickAriaLabel = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } { ... rest } > < span ref = { ref } > < FilterLabel filter = { filter } valueLabel = { valueLabel } filterLabelStatus = { filterLabelStatus } / > < / span > < / EuiBadge > ) ; } ; </s>
<s> import * as assert from "<STR_LIT>" ; <EOL> import * as vscode from "<STR_LIT>" ; <EOL> import * as TestUtils from "<STR_LIT>" ; <EOL> import { <EOL> Commands <EOL> } from "<STR_LIT>" ; <EOL> export enum VertificationType { <EOL> Exact , <EOL> Ordered , <EOL> Contains <EOL> } <EOL> export async function testCompletion ( docUri , position , expectedCompletionList , vertification ) { <EOL> const actualCompletionList = await testCompletionBase ( docUri , position ) ; <EOL> if ( actualCompletionList == = undefined ) { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> if ( vertification == = VertificationType . Exact ) { <EOL> assert . equal ( actualCompletionList . items . length , expectedCompletionList . items . length , "<STR_LIT>" ) ; <EOL> } else { <EOL> assert ( actualCompletionList . items . length >= expectedCompletionList . items . length ,   ` received fewer items ( $ { actualCompletionList . items . length } ) than expected ( $ { expectedCompletionList . items . length } ) ` ) ; <EOL> } <EOL> if ( vertification == = VertificationType . Exact | | vertification == = VertificationType . Ordered ) { <EOL> expectedCompletionList . items . forEach ( ( expectedItem , index ) = > { <EOL> const actualItem = actualCompletionList . items . at ( index ) ; <EOL> assert . equal ( actualItem ? . label , expectedItem . label ) ; <EOL> assert . equal ( actualItem ? . kind , expectedItem . kind ) ; <EOL> } ) ; <EOL> } else { <EOL> expectedCompletionList . items . forEach ( ( expectedItem ) = > { <EOL> const filteredItems = actualCompletionList . items . filter ( ( item ) = > item . label == = expectedItem . label ) ; <EOL> assert . equal ( filteredItems . length , <NUM_LIT> ,   ` expected to find one item with label '<STR_LIT>' ` ) ; <EOL> assert . equal ( filteredItems [ <NUM_LIT> ] . kind , expectedItem . kind ,   ` item kind mismatch . ` ) ; <EOL> } ) ; <EOL> } <EOL> } <EOL> async function testCompletionBase ( docUri , position ) { <EOL> await TestUtils . activate ( docUri ) ; <EOL> return vscode . commands . executeCommand ( Commands . CompletionItems , docUri , position ) ; <EOL> } </s>
<s> import { <EOL> ChangeDetectionStrategy , <EOL> Component , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AbstractControl , <EOL> FormBuilder , <EOL> FormGroup , <EOL> Validators <EOL> } from '<STR_LIT>' ; <EOL> import * as moment from '<STR_LIT>' ; <EOL> import { <EOL> Observable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> filter , <EOL> tap <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldComponent , <EOL> FormFieldOption <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getDays , <EOL> getDaysByMonthAndYear , <EOL> getMonthChoices , <EOL> getYears <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class FieldDateComponent extends FieldComponent implements OnInit { <EOL> / ** <EOL> * DateData control <EOL> * / <EOL> dateForm ! : FormGroup ; <EOL> / ** <EOL> * Days for select <EOL> * / <EOL> days : number [ ] = getDays ( ) ; <EOL> / ** <EOL> * Months for select <EOL> * / <EOL> months : FormFieldOption [ ] = getMonthChoices ( ) ; <EOL> / ** <EOL> * Years for select <EOL> * / <EOL> years : number [ ] = getYears ( ) ; <EOL> / ** <EOL> * Watching for change control <EOL> * / <EOL> valueChanges $ ! : Observable < string > ; <EOL> constructor ( protected formBuilder ) { <EOL> super ( ) ; <EOL> this . dateForm = this . formBuilder . group ( { <EOL> day : [ null , [ Validators . required ] ] , <EOL> month : [ null , [ Validators . required ] ] , <EOL> year : [ null , [ Validators . required ] ] <EOL> } ) ; <EOL> } <EOL> ngOnInit ( ) { <EOL> const years = this . field . attrs & & this . field . attrs . years ; <EOL> if ( years ) { <EOL> this . years = getYears ( null , years . start , years . end ) ; <EOL> } <EOL> if ( this . formControl . value ) { <EOL> this . patchDate ( ) ; <EOL> } <EOL> this . valueChanges $ = this . formControl . valueChanges . pipe ( filter ( data = >   ! ! data ) , tap ( ( ) = > { <EOL> if ( this . dateForm . invalid ) { <EOL> this . patchDate ( ) ; <EOL> } <EOL> } ) ) ; <EOL> } <EOL> / ** <EOL> * Set auto value for empty select <EOL> * / <EOL> onControlBlur ( control , value ) { <EOL> if ( ! control . value ) { <EOL> control . setValue ( value ) ; <EOL> this . onChanged ( ) ; <EOL> } <EOL> } <EOL> / ** <EOL> * Update control <EOL> * / <EOL> onChanged ( ) { <EOL> const selectedDay = this . dateForm . get ( '<STR_LIT>' ) . value ; <EOL> const month = this . dateForm . get ( '<STR_LIT>' ) . value ; <EOL> const year = this . dateForm . get ( '<STR_LIT>' ) . value ; <EOL> if ( month & & year ) { <EOL> const newDays = getDaysByMonthAndYear ( + month , + year ) ; <EOL> if ( newDays . length != = this . days . length ) { <EOL> this . days = newDays ; <EOL> } <EOL> if ( month & & year & & selectedDay & & + selectedDay > this . days . length ) { <EOL> this . dateForm . get ( '<STR_LIT>' ) . patchValue ( <NUM_LIT> ) ; <EOL> } <EOL> } <EOL> if ( this . dateForm . valid ) { <EOL> this . formControl . patchValue ( this . getDateData ( ) ) ; <EOL> } <EOL> } <EOL> protected patchDate ( ) { <EOL> const date = moment ( this . formControl . value , '<STR_LIT>' ) ; <EOL> this . dateForm . patchValue ( { <EOL> day : date . date ( ) , <EOL> month : date . month ( ) + <NUM_LIT> , <EOL> year : date . year ( ) <EOL> } ) ; <EOL> } <EOL> / ** <EOL> * Return birthday in format YYYY - M - D <EOL> * / <EOL> protected getDateData ( ) { <EOL> const data = this . dateForm . value ; <EOL> return moment ( ` $ { data . year } - $ { data . month } - $ { data . day } ` , '<STR_LIT>' ) . format ( '<STR_LIT>' ) ; <EOL> } <EOL> } </s>
<s> export function toHex ( n ) { <EOL> return   ` <NUM_LIT> x $ { n . toString ( <NUM_LIT> ) } ` ; <EOL> } <EOL> export function fromHex ( hexString ) { <EOL> return Number . parseInt ( hexString , <NUM_LIT> ) ; <EOL> } <EOL> export function formatBlock ( block ) { <EOL> if ( typeof block == = "<STR_LIT>" ) { <EOL> return block ; <EOL> } else if ( typeof block == = "<STR_LIT>" & & Number . isInteger ( block ) ) { <EOL> return toHex ( block ) ; <EOL> } <EOL> return block . toString ( ) ; <EOL> } </s>
<s> export interface IRegistry < T > { <EOL> get ( id ) : T | null ; toJS ( ) : Record < string , <EOL> T > ; toArray ( ) : T [ ] ; <EOL> } </s>
<s> import * as Papa from '<STR_LIT>' ; <EOL> import * as React from '<STR_LIT>' ; <EOL> import * as CSSModules from '<STR_LIT>' ; <EOL> import * as fileDownload from '<STR_LIT>' ; <EOL> import { <EOL> constructLogString <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> actionLogs <EOL> } from '<STR_LIT>' ; <EOL> import * as styles from '<STR_LIT>' ; <EOL> export class FooterBase extends React . PureComponent < { } , { } > { <EOL> public render ( ) { <EOL> return ( < div styleName = '<STR_LIT>' > < a onClick = { this . exportLogs } > Download logs < / a > < / div > ) ; } private exportLogs ( ) { const logs = constructLogString ( actionLogs . getLog ( ) . actions ) ; const csv = Papa . unparse ( logs ) ; const fileName =   ` Logs_voyager_ $ { new Date ( ) } . csv ` ; fileDownload ( csv , fileName ) ; } } export const Footer = CSSModules ( FooterBase , styles ) ; </s>
<s> import type { <EOL> IScalpelOptions <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> VariantFunction <EOL> } from '<STR_LIT>' ; <EOL> export function getVariantMediaQuery ( config ) { <EOL> return ( matcher ) = > { <EOL> / ** <EOL> *   ! not use regexp star limit ^ to match <EOL> * because in attributify value is not start with media query <EOL> * just replace media query to empty string <EOL> * / <EOL> const [ , mediaQuery = '<STR_LIT>' ] = matcher . match ( new RegExp ( ` ( $ { Object . keys ( config . mediaQueries ) . join ( '<STR_LIT>' ) } ) @ ` ) )   ? ? [ ] ; <EOL> if ( ! mediaQuery ) { <EOL> return { <EOL> matcher <EOL> } ; <EOL> } <EOL> return { <EOL> matcher : matcher . replace ( new RegExp ( ` $ { mediaQuery } @ ` ) , '<STR_LIT>' ) , <EOL> parent : [ ` @ $ { config . mediaQueries [ mediaQuery ] } ` , <NUM_LIT> ] , <EOL> } ; <EOL> } ; <EOL> } </s>
<s> import { <EOL> parse , <EOL> stringify <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> History , <EOL> Location <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> url <EOL> } from '<STR_LIT>' ; <EOL> export function removeQueryParam ( history , param , replace = true ) { <EOL> const oldLocation = history . location ; <EOL> const search = ( oldLocation . search | | '<STR_LIT>' ) . replace ( / ^ \ ? / , '<STR_LIT>' ) ; <EOL> const query = parse ( search , { <EOL> sort : false <EOL> } ) ; <EOL> delete query [ param ] ; <EOL> const newSearch = stringify ( url . encodeQuery ( query ) , { <EOL> sort : false , <EOL> encode : false <EOL> } ) ; <EOL> const newLocation = { <EOL> ... oldLocation , <EOL> search : newSearch , <EOL> } ; <EOL> if ( replace ) { <EOL> history . replace ( newLocation ) ; <EOL> } else { <EOL> history . push ( newLocation ) ; <EOL> } <EOL> } </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import styled from "<STR_LIT>" ; <EOL> import { <EOL> colors <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> CloseXIcon <EOL> } from "<STR_LIT>" ; <EOL> export const CloseXBtnStyled = styled . button   ` <EOL> background - color :   $ { colors . basic . WHITE } ; <EOL> border : <NUM_LIT> px solid   $ { colors . accent . CIVIL_GRAY_4 } ; <EOL> border - radius : <NUM_LIT> % ; <EOL> cursor : pointer ; <EOL> padding : <NUM_LIT> ; <EOL> height : <NUM_LIT> px ; <EOL> width : <NUM_LIT> px ; <EOL> svg path { <EOL> transition : fill <NUM_LIT> s ease ; <EOL> } <EOL> & : hover { <EOL> svg path { <EOL> fill :   $ { colors . accent . CIVIL_BLUE } ; <EOL> } <EOL> } <EOL> ` ; <EOL> export interface CloseXButtonProps { <EOL> onClick ( ev ) : void ; <EOL> } <EOL> export const CloseXButton = props = > { <EOL> return ( < CloseXBtnStyled onClick = { props . onClick } > < CloseXIcon color = { colors . accent . CIVIL_GRAY_2 } width = { <NUM_LIT> } height = { <NUM_LIT> } / > < / CloseXBtnStyled > ) ; } ; </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> vislibColorMaps , <EOL> RawColorSchema <EOL> } from '<STR_LIT>' ; <EOL> function enforceBounds ( x ) { <EOL> if ( x < <NUM_LIT> ) { <EOL> return <NUM_LIT> ; <EOL> } else if ( x > <NUM_LIT> ) { <EOL> return <NUM_LIT> ; <EOL> } else { <EOL> return x ; <EOL> } <EOL> } <EOL> function interpolateLinearly ( x , values ) { <EOL> const xValues = [ ] ; <EOL> const rValues = [ ] ; <EOL> const gValues = [ ] ; <EOL> const bValues = [ ] ; <EOL> values . forEach ( ( value ) = > { <EOL> xValues . push ( value [ <NUM_LIT> ] ) ; <EOL> rValues . push ( value [ <NUM_LIT> ] [ <NUM_LIT> ] ) ; <EOL> gValues . push ( value [ <NUM_LIT> ] [ <NUM_LIT> ] ) ; <EOL> bValues . push ( value [ <NUM_LIT> ] [ <NUM_LIT> ] ) ; <EOL> } ) ; <EOL> let i = <NUM_LIT> ; <EOL> while ( xValues [ i ] < x ) i + + ; <EOL> const width = Math . abs ( xValues [ i - <NUM_LIT> ] - xValues [ i ] ) ; <EOL> const scalingFactor = ( x - xValues [ i - <NUM_LIT> ] ) / width ; <EOL> const r = rValues [ i - <NUM_LIT> ] + scalingFactor * ( rValues [ i ] - rValues [ i - <NUM_LIT> ] ) ; <EOL> const g = gValues [ i - <NUM_LIT> ] + scalingFactor * ( gValues [ i ] - gValues [ i - <NUM_LIT> ] ) ; <EOL> const b = bValues [ i - <NUM_LIT> ] + scalingFactor * ( bValues [ i ] - bValues [ i - <NUM_LIT> ] ) ; <EOL> return [ enforceBounds ( r ) , enforceBounds ( g ) , enforceBounds ( b ) ] ; <EOL> } <EOL> export function getHeatmapColors ( value , colorSchemaName ) { <EOL> if ( ! _ . isNumber ( value ) | | value < <NUM_LIT> | | value > <NUM_LIT> ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> const colorSchema = vislibColorMaps [ colorSchemaName ] . value ; <EOL> if ( ! colorSchema ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> const color = interpolateLinearly ( value , colorSchema ) ; <EOL> const r = Math . round ( <NUM_LIT> * color [ <NUM_LIT> ] ) ; <EOL> const g = Math . round ( <NUM_LIT> * color [ <NUM_LIT> ] ) ; <EOL> const b = Math . round ( <NUM_LIT> * color [ <NUM_LIT> ] ) ; <EOL> return   ` rgb ( $ { r } , $ { g } , $ { b } ) ` ; <EOL> } <EOL> function drawColormap ( colorSchema , width = <NUM_LIT> , height = <NUM_LIT> ) { <EOL> const canvas = document . createElement ( '<STR_LIT>' ) ; <EOL> canvas . width = width ; <EOL> canvas . height = height ; <EOL> const ctx = canvas . getContext ( '<STR_LIT>' ) ; <EOL> if ( ctx == = null ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> for ( let i = <NUM_LIT> ; i <= width ; i + + ) { <EOL> ctx . fillStyle = getHeatmapColors ( i / width , colorSchema ) ; <EOL> ctx . fillRect ( i , <NUM_LIT> , <NUM_LIT> , height ) ; <EOL> } <EOL> return canvas ; <EOL> } <EOL> getHeatmapColors . prototype . drawColormap = drawColormap ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> useState <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> RoomStream <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> globalColors <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> RoomStat <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> rightMenuWidth <EOL> } from "<STR_LIT>" ; <EOL> import Video from "<STR_LIT>" ; <EOL> import StreamController from "<STR_LIT>" ; <EOL> import { <EOL> Icon , <EOL> IconButton <EOL> } from "<STR_LIT>" ; <EOL> import StreamInfo from "<STR_LIT>" ; <EOL> import VADetector from "<STR_LIT>" ; <EOL> interface Props { <EOL> stream : RoomStream ; stat : RoomStat | null ; isPinned : boolean ; onClickSetPinned : ( ) = > void ; <EOL> } <EOL> const RemoteStreamLayout = ( { <EOL> stream , <EOL> stat , <EOL> isPinned , <EOL> onClickSetPinned , <EOL> } ) = > { <EOL> const isVideoDisabled = stat & & stat . isVideoDisabled   ? true : false ; <EOL> const [ isInfoShown , setInfoShown ] = useState ( false ) ; <EOL> return ( < > < div css = { videoStyle } > < Video stream = { stream } / > < div css = { actionStyle } > {   ! isVideoDisabled   ? ( < IconButton name = { isPinned   ? "<STR_LIT>" : "<STR_LIT>" } showEdge = { true } title = "<STR_LIT>" onClick = { onClickSetPinned } / > ) : null } < IconButton name = "<STR_LIT>" showEdge = { true } title = "<STR_LIT>" onClick = { ( ) = > setInfoShown (   ! isInfoShown ) } / > < / div > { isInfoShown & & stat != = null   ? ( < div css = { infoStyle } > < StreamInfo stream = { stream } browser = { stat . browser } / > < / div > ) : null } < div css = { controllerStyle } > { stat != = null   ? ( < > < VADetector stream = { stream } / > < StreamController displayName = { stat . displayName } browser = { stat . browser } controllers = { < > { stat . isVideoDisabled   ? null : ( < Icon name = { stat . isVideoMuted   ? "<STR_LIT>" : "<STR_LIT>" } / > ) } < Icon name = { stat . isAudioMuted   ? "<STR_LIT>" : "<STR_LIT>" } / > < / > } / > < / > ) : null } < / div > < / div > < / > ) ; } ; export default RemoteStreamLayout ; const videoStyle = css ( { position : "<STR_LIT>" , height : ( rightMenuWidth / <NUM_LIT> ) * <NUM_LIT> , backgroundColor : globalColors . black , } ) ; const infoStyle = css ( { position : "<STR_LIT>" , left : <NUM_LIT> , right : <NUM_LIT> , top : <NUM_LIT> , bottom : <NUM_LIT> , zIndex : <NUM_LIT> , } ) ; const controllerStyle = css ( { position : "<STR_LIT>" , left : <NUM_LIT> , right : <NUM_LIT> , bottom : <NUM_LIT> , zIndex : <NUM_LIT> , } ) ; const actionStyle = css ( { position : "<STR_LIT>" , top : <NUM_LIT> , right : <NUM_LIT> , zIndex : <NUM_LIT> , display : "<STR_LIT>" , alignItems : "<STR_LIT>" , color : globalColors . white , } ) ; </s>
<s> / ** Net interface supports http transport * / <EOL> export interface Net { <EOL> / ** base URL * / <EOL> readonly baseURL : string ; <EOL> param method param path param params returns http ( method , path , params   ? ) : Promise < any > ; <EOL> param path openWebSocketReader ( path ) : Net . WebSocketReader ; <EOL> } <EOL> export namespace Net { <EOL> / ** http request params * / <EOL> export interface Params { <EOL> query   ? : Record < string , string > ; <EOL> body   ? : any ; <EOL> headers   ? : Record < string , string > ; <EOL> validateResponseHeader   ? : ( headers : Record < string , string > ) = > void ; <EOL> } / ** websocket reader * / <EOL> export interface WebSocketReader { <EOL> / ** read data * / <EOL> read ( ) : Promise < any > ; <EOL> close ( ) : void ; <EOL> } <EOL> } / ** Wallet interface manages private keys * / <EOL> export interface Wallet { <EOL> / ** list all keys * / <EOL> readonly list : Wallet . Key [ ] ; <EOL> } <EOL> export namespace Wallet { <EOL> / ** describes an operational key * / <EOL> export interface Key { <EOL> / ** address derived from key * / <EOL> address : string ; param msgHash returns sign ( msgHash ) : Promise < Buffer > ; <EOL> } <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> NavLink <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Menu , <EOL> MenuList , <EOL> MenuButton , <EOL> MenuItem <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> api <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Avatar <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Logo <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> useAuth <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> export const PrimaryHeader = ( ) = > { <EOL> const { <EOL> user , <EOL> dispatch <EOL> } = useAuth ( ) ; <EOL> function handleLogout ( ) { <EOL> dispatch ( { <EOL> type : '<STR_LIT>' <EOL> } ) ; <EOL> api . auth . logout ( ) ; <EOL> } <EOL> return ( < header className = "<STR_LIT>" > < div className = "<STR_LIT>" > < div > < Logo / > < / div > < div > < nav className = "<STR_LIT>" > < NavLink to = "<STR_LIT>" exact className = "<STR_LIT>" > Dashboard < / NavLink > < NavLink to = "<STR_LIT>" className = "<STR_LIT>" > Boards < / NavLink > < Menu > < MenuButton className = "<STR_LIT>" > < Avatar src = { user   ? . avatarUrl   ! } size = { <NUM_LIT> } / > < / MenuButton > < MenuList className = "<STR_LIT>" > < MenuItem onSelect = { handleLogout } > Logout < / MenuItem > < / MenuList > < / Menu > < / nav > < / div > < / div > < / header > ) ; } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import classnames from '<STR_LIT>' ; <EOL> import { <EOL> withRipple , <EOL> InjectedProps , <EOL> RippledComponentProps , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MDCIconButtonToggleAdapter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MDCIconButtonToggleFoundation <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MDCIconButtonToggleEventDetail <EOL> } from '<STR_LIT>' ; <EOL> import IconToggle from '<STR_LIT>' ; <EOL> const ARIA_PRESSED = '<STR_LIT>' ; <EOL> interface ElementAttributes { <EOL> [ ARIA_PRESSED ]   ? : boolean | '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' ; <EOL> } <EOL> type IconButtonTypes = HTMLButtonElement | HTMLAnchorElement ; <EOL> export interface IconButtonBaseProps extends ElementAttributes { <EOL> handleChange   ? : ( evt : MDCIconButtonToggleEventDetail ) = > void ; <EOL> isLink   ? : boolean ; <EOL> } <EOL> interface IconButtonBaseState extends ElementAttributes { <EOL> classList : Set < string > ; <EOL> } <EOL> export interface IconButtonProps < T extends IconButtonTypes > extends InjectedProps < T > , IconButtonBaseProps , React . HTMLProps < T > { } <EOL> class IconButtonBase < T extends IconButtonTypes > extends React . Component < IconButtonProps < T > , IconButtonBaseState > { <EOL> foundation ! : MDCIconButtonToggleFoundation ; constructor ( props ) { <EOL> super ( props ) ; <EOL> this . state = { <EOL> classList : new Set ( ) , <EOL> [ ARIA_PRESSED ] : props [ ARIA_PRESSED ] , <EOL> } ; <EOL> } <EOL> static defaultProps = { <EOL> className : '<STR_LIT>' , <EOL> handleChange : ( ) = > { } , <EOL> initRipple : ( ) = > { } , <EOL> isLink : false , <EOL> onClick : ( ) = > { } , <EOL> unbounded : true , <EOL> } ; componentDidMount ( ) { <EOL> this . foundation = new MDCIconButtonToggleFoundation ( this . adapter ) ; <EOL> this . foundation . init ( ) ; <EOL> } <EOL> get classes ( ) { <EOL> const { <EOL> classList <EOL> } = this . state ; <EOL> const { <EOL> className <EOL> } = this . props ; <EOL> return classnames ( '<STR_LIT>' , Array . from ( classList ) , className ) ; <EOL> } <EOL> get adapter ( ) : MDCIconButtonToggleAdapter { <EOL> return { <EOL> addClass : ( className ) = > this . setState ( { <EOL> classList : this . state . classList . add ( className ) <EOL> } ) , <EOL> removeClass : ( className ) = > { <EOL> const { <EOL> classList <EOL> } = this . state ; <EOL> classList . delete ( className ) ; <EOL> this . setState ( { <EOL> classList <EOL> } ) ; <EOL> } , <EOL> hasClass : ( className ) = > this . classes . split ( '<STR_LIT>' ) . includes ( className ) , <EOL> setAttr : this . updateState , <EOL> notifyChange : this . props . handleChange ! , <EOL> } ; <EOL> } <EOL> updateState = ( key , value ) = > { <EOL> this . setState ( ( prevState ) = > ( { <EOL> ... prevState , <EOL> [ key ] : value , <EOL> } ) ) ; <EOL> } ; handleClick_ = ( e ) = > { <EOL> this . props . onClick ! ( e ) ; <EOL> this . foundation . handleClick ( ) ; <EOL> } ; render ( ) { <EOL> const { <EOL> children , <EOL> initRipple , <EOL> isLink , <EOL> className , <EOL> handleChange , <EOL> onClick , <EOL> unbounded , <EOL> [ ARIA_PRESSED ] : ariaPressed , <EOL> ... otherProps <EOL> } = this . props ; <EOL> const props = { <EOL> className : this . classes , <EOL> ref : initRipple , <EOL> [ ARIA_PRESSED ] : this . state [ ARIA_PRESSED ] , <EOL> onClick : this . handleClick_ , <EOL> ... otherProps , <EOL> } ; <EOL> if ( isLink ) { <EOL> return ( < a { ... ( props as IconButtonProps < HTMLAnchorElement > ) } > { children } < / a > ) ; } return ( < button { ... ( props as IconButtonProps < HTMLButtonElement > ) } > { children } < / button > ) ; } } const IconButton = withRipple < IconButtonProps < IconButtonTypes > , IconButtonTypes > ( IconButtonBase ) ; export default IconButton ; export { IconToggle , IconButtonBase } ; </s>
<s> import { <EOL> ISignal , <EOL> Signal <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IDebugger <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * A model for a list of breakpoints . <EOL> * / <EOL> export class BreakpointsModel implements IDebugger . Model . IBreakpoints { <EOL> / ** <EOL> * Signal emitted when the model changes . <EOL> * / <EOL> get changed ( ) : ISignal < this , <EOL> IDebugger . IBreakpoint [ ] > { <EOL> return this . _changed ; <EOL> } <EOL> / ** <EOL> * Signal emitted when the breakpoints are restored . <EOL> * / <EOL> get restored ( ) : ISignal < this , <EOL> void > { <EOL> return this . _restored ; <EOL> } <EOL> / ** <EOL> * Signal emitted when a breakpoint is clicked . <EOL> * / <EOL> get clicked ( ) : Signal < this , <EOL> IDebugger . IBreakpoint > { <EOL> return this . _clicked ; <EOL> } <EOL> / ** <EOL> * Get all the breakpoints . <EOL> * / <EOL> get breakpoints ( ) : Map < string , <EOL> IDebugger . IBreakpoint [ ] > { <EOL> return this . _breakpoints ; <EOL> } <EOL> param id param breakpoints setBreakpoints ( id , breakpoints ) { <EOL> this . _breakpoints . set ( id , breakpoints ) ; <EOL> this . _changed . emit ( breakpoints ) ; <EOL> } <EOL> param id getBreakpoints ( id ) { <EOL> return this . _breakpoints . get ( id )   ? ? [ ] ; <EOL> } <EOL> param breakpoints restoreBreakpoints ( breakpoints ) { <EOL> this . _breakpoints = breakpoints ; <EOL> this . _restored . emit ( ) ; <EOL> } <EOL> private _breakpoints = new Map < string , <EOL> IDebugger . IBreakpoint [ ] > ( ) ; private _changed = new Signal < this , <EOL> IDebugger . IBreakpoint [ ] > ( this ) ; private _restored = new Signal < this , <EOL> void > ( this ) ; private _clicked = new Signal < this , <EOL> IDebugger . IBreakpoint > ( this ) ; <EOL> } </s>
<s> import { <EOL> createReducer , <EOL> createAction <EOL> } from '<STR_LIT>' ; <EOL> export const actions = { <EOL> increment : createAction ( '<STR_LIT>' ) , <EOL> decrement : createAction ( '<STR_LIT>' ) , <EOL> } ; <EOL> const initialState = { <EOL> count : <NUM_LIT> <EOL> } ; <EOL> export const counterReducer = createReducer ( initialState , { <EOL> [ actions . increment ] : ( state , action ) = > { <EOL> return { <EOL> ... state , <EOL> count : state . count + <NUM_LIT> <EOL> } ; <EOL> } , <EOL> [ actions . decrement ] : ( state , action ) = > { <EOL> return { <EOL> ... state , <EOL> count : state . count - <NUM_LIT> <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> INodeType , <EOL> INodeTypeData , <EOL> INodeTypes , <EOL> NodeHelpers , <EOL> } from '<STR_LIT>' ; <EOL> export interface INodeTypesObject { <EOL> [ key ] : INodeType ; <EOL> } <EOL> class NodeTypesClass implements INodeTypes { <EOL> nodeTypes : INodeTypeData = { <EOL> '<STR_LIT>' : { <EOL> sourcePath : '<STR_LIT>' , <EOL> type : { <EOL> description : { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> group : [ '<STR_LIT>' ] , <EOL> version : <NUM_LIT> , <EOL> description : '<STR_LIT>' , <EOL> defaults : { <EOL> name : '<STR_LIT>' , <EOL> color : '<STR_LIT>' , <EOL> } , <EOL> inputs : [ '<STR_LIT>' ] , <EOL> outputs : [ '<STR_LIT>' ] , <EOL> properties : [ { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> default : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> default : '<STR_LIT>' , <EOL> } , ] , <EOL> } , <EOL> } , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> sourcePath : '<STR_LIT>' , <EOL> type : { <EOL> description : { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> group : [ '<STR_LIT>' ] , <EOL> version : <NUM_LIT> , <EOL> description : '<STR_LIT>' , <EOL> defaults : { <EOL> name : '<STR_LIT>' , <EOL> color : '<STR_LIT>' , <EOL> } , <EOL> inputs : [ '<STR_LIT>' ] , <EOL> outputs : [ '<STR_LIT>' ] , <EOL> properties : [ { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> typeOptions : { <EOL> multipleValues : true , <EOL> } , <EOL> default : { } , <EOL> options : [ { <EOL> name : '<STR_LIT>' , <EOL> displayName : '<STR_LIT>' , <EOL> values : [ { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> default : '<STR_LIT>' , <EOL> placeholder : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> default : '<STR_LIT>' , <EOL> placeholder : '<STR_LIT>' , <EOL> } , ] , <EOL> } , ] , <EOL> } , ] , <EOL> } , <EOL> } , <EOL> } , <EOL> } ; async init ( nodeTypes ) { } <EOL> getAll ( ) { <EOL> return Object . values ( this . nodeTypes ) . map ( ( data ) = > NodeHelpers . getVersionedNodeType ( data . type ) ) ; <EOL> } <EOL> getByName ( nodeType ) { <EOL> return this . getByNameAndVersion ( nodeType ) ; <EOL> } <EOL> getByNameAndVersion ( nodeType , version   ? ) { <EOL> return NodeHelpers . getVersionedNodeType ( this . nodeTypes [ nodeType ] . type , version ) ; <EOL> } <EOL> } <EOL> let nodeTypesInstance ; <EOL> export function NodeTypes ( ) { <EOL> if ( nodeTypesInstance == = undefined ) { <EOL> nodeTypesInstance = new NodeTypesClass ( ) ; <EOL> } <EOL> return nodeTypesInstance ; <EOL> } </s>
<s> import { <EOL> parseOpenSearchInterval <EOL> } from '<STR_LIT>' ; <EOL> param interval returns <EOL> export function isValidOpenSearchInterval ( interval ) { <EOL> try { <EOL> parseOpenSearchInterval ( interval ) ; <EOL> return true ; <EOL> } catch { <EOL> return false ; <EOL> } <EOL> } </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> IFieldType , <EOL> IIndexPattern , <EOL> Filter , <EOL> isExistsFilter , <EOL> isPhraseFilter , <EOL> getPhraseFilterValue , <EOL> getPhraseFilterField , <EOL> isScriptedPhraseFilter , <EOL> buildFilter , <EOL> FilterStateStore , <EOL> FILTERS , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FilterManager <EOL> } from '<STR_LIT>' ; <EOL> function getExistingFilter ( appFilters , fieldName , value ) { <EOL> return _ . find ( appFilters , function ( filter ) { <EOL> if ( ! filter ) return ; <EOL> if ( fieldName == = '<STR_LIT>' & & isExistsFilter ( filter ) ) { <EOL> return filter . exists ! . field == = value ; <EOL> } <EOL> if ( isPhraseFilter ( filter ) ) { <EOL> return getPhraseFilterField ( filter ) == = fieldName & & getPhraseFilterValue ( filter ) == = value ; <EOL> } <EOL> if ( isScriptedPhraseFilter ( filter ) ) { <EOL> return filter . meta . field == = fieldName & & filter . script ! . script . params . value == = value ; <EOL> } <EOL> } ) as any ; <EOL> } <EOL> function updateExistingFilter ( existingFilter , negate ) { <EOL> existingFilter . meta . disabled = false ; <EOL> if ( existingFilter . meta . negate != = negate ) { <EOL> existingFilter . meta . negate =   ! existingFilter . meta . negate ; <EOL> } <EOL> } <EOL> param { <EOL> FilterManager <EOL> } <EOL> filterManager param { <EOL> Field | string <EOL> } <EOL> field param { <EOL> any <EOL> } <EOL> values param { <EOL> string <EOL> } <EOL> operation param { <EOL> string <EOL> } <EOL> index returns { <EOL> object <EOL> } <EOL> export function generateFilters ( filterManager , field , values , operation , index ) { <EOL> values = Array . isArray ( values )   ? values : [ values ] ; <EOL> const fieldObj = ( _ . isObject ( field )   ? field : { <EOL> name : field , <EOL> } ) as IFieldType ; <EOL> const fieldName = fieldObj . name ; <EOL> const newFilters = [ ] ; <EOL> const appFilters = filterManager . getAppFilters ( ) ; <EOL> const negate = operation == = '<STR_LIT>' ; <EOL> let filter ; <EOL> _ . each ( values , function ( value ) { <EOL> const existing = getExistingFilter ( appFilters , fieldName , value ) ; <EOL> if ( existing ) { <EOL> updateExistingFilter ( existing , negate ) ; <EOL> filter = existing ; <EOL> } else { <EOL> const tmpIndexPattern = { <EOL> id : index <EOL> } <EOL> as IIndexPattern ; <EOL> const filterType = fieldName == = '<STR_LIT>'   ? FILTERS . EXISTS : FILTERS . PHRASE ; <EOL> const actualFieldObj = fieldName == = '<STR_LIT>'   ? ( { <EOL> name : value <EOL> } <EOL> as IFieldType ) : fieldObj ; <EOL> const isNullFilter = value == = null | | value == = undefined ; <EOL> filter = buildFilter ( tmpIndexPattern , actualFieldObj , isNullFilter   ? FILTERS . EXISTS : filterType , isNullFilter   ?   ! negate : negate , false , value , null , FilterStateStore . APP_STATE ) ; <EOL> } <EOL> newFilters . push ( filter ) ; <EOL> } ) ; <EOL> return newFilters ; <EOL> } </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import { <EOL> useParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Columns , <EOL> Column <EOL> } from '<STR_LIT>' ; <EOL> import Heading from '<STR_LIT>' ; <EOL> import Quantity from '<STR_LIT>' ; <EOL> import Tiles from '<STR_LIT>' ; <EOL> import StarRatings from '<STR_LIT>' ; <EOL> import ProductImage from '<STR_LIT>' ; <EOL> import ShoppingCartButton from '<STR_LIT>' ; <EOL> import { <EOL> useShoppingCart <EOL> } from '<STR_LIT>' ; <EOL> import ProductTile from '<STR_LIT>' ; <EOL> import { <EOL> Product <EOL> } from '<STR_LIT>' ; <EOL> import api from '<STR_LIT>' ; <EOL> function ProductProfile ( ) { <EOL> let { <EOL> productId <EOL> } = useParams ( ) ; <EOL> productId = parseInt ( productId , <NUM_LIT> ) ; <EOL> let product = null ; <EOL> api . products . getProduct ( productId ) ; <EOL> let { <EOL> addToCart , <EOL> updateQuantity , <EOL> getQuantity <EOL> } = useShoppingCart ( ) ; <EOL> let quantity = getQuantity ( productId ) ; <EOL> if ( ! product ) { <EOL> return < div > Loading ... < / div > ; } return ( < div className = "<STR_LIT>" > < Columns gutters > < Column > < ProductImage src = { product . imagePath } alt = { product . name } size = { <NUM_LIT> } / > < / Column > < Column flex className = "<STR_LIT>" > < Heading > { product . name } < / Heading > < StarRatings rating = { product . rating } / > < hr / > < Columns split > < Column > < div className = "<STR_LIT>" > < div > Brand : { product . brand } < / div > < div > Category : { product . category } < / div > < div > Condition : { product . condition } < / div > < / div > < / Column > < Column className = "<STR_LIT>" > < ShoppingCartButton onClick = { ( ) = > addToCart ( productId , product . name , product . price ) } quantity = { quantity } / > { quantity > <NUM_LIT> & & ( < div className = "<STR_LIT>" > < Quantity onChange = { ( q ) = > updateQuantity ( productId , q ) } quantity = { quantity } / > < / div > ) } < / Column > < / Columns > < p > { product . description } < / p > < / Column > < / Columns > { Array . isArray ( product . relatedProducts ) & & ( < > < hr / > < div > < Heading as = "<STR_LIT>" size = { <NUM_LIT> } > Related Products < / Heading > < Tiles > { product . relatedProducts . map ( ( productId ) = > ( < ProductTile key = { productId } productId = { productId } / > ) ) } < / Tiles > < / div > < / > ) } < / div > ) ; } export default ProductProfile ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Assign <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . SERIAL_DIFF > ; <EOL> type Arguments = Assign < AggArgs , { <EOL> customMetric   ? : AggExpressionType ; <EOL> } > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , Arguments , Output > ; <EOL> export const aggSerialDiff = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> metricAgg : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customMetric : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> buckets_path : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . SERIAL_DIFF , <EOL> params : { <EOL> ... rest , <EOL> customMetric : args . customMetric ? . value , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> get , <EOL> isEqual <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IContextObject , <EOL> INode , <EOL> INodeCredentialDescription , <EOL> INodeExecutionData , <EOL> INodeIssueObjectProperty , <EOL> INodeIssues , <EOL> INodeParameters , <EOL> INodeProperties , <EOL> INodePropertyCollection , <EOL> INodeType , <EOL> INodeVersionedType , <EOL> IParameterDependencies , <EOL> IRunExecutionData , <EOL> IWebhookData , <EOL> IWorkflowExecuteAdditionalData , <EOL> NodeParameterValue , <EOL> WebhookHttpMethod , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Workflow <EOL> } from '<STR_LIT>' ; <EOL> export param { <EOL> INodeType <EOL> } <EOL> nodeType returns <EOL> export function getSpecialNodeParameters ( nodeType ) { <EOL> if ( nodeType . description . polling == = true ) { <EOL> return [ { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> typeOptions : { <EOL> multipleValues : true , <EOL> multipleValueButtonText : '<STR_LIT>' , <EOL> } , <EOL> default : { } , <EOL> description : '<STR_LIT>' , <EOL> placeholder : '<STR_LIT>' , <EOL> options : [ { <EOL> name : '<STR_LIT>' , <EOL> displayName : '<STR_LIT>' , <EOL> values : [ { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> options : [ { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , ] , <EOL> default : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> typeOptions : { <EOL> minValue : <NUM_LIT> , <EOL> maxValue : <NUM_LIT> , <EOL> } , <EOL> displayOptions : { <EOL> hide : { <EOL> mode : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , <EOL> } , <EOL> default : <NUM_LIT> , <EOL> description : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> typeOptions : { <EOL> minValue : <NUM_LIT> , <EOL> maxValue : <NUM_LIT> , <EOL> } , <EOL> displayOptions : { <EOL> hide : { <EOL> mode : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } , <EOL> } , <EOL> default : <NUM_LIT> , <EOL> description : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> displayOptions : { <EOL> show : { <EOL> mode : [ '<STR_LIT>' ] , <EOL> } , <EOL> } , <EOL> typeOptions : { <EOL> minValue : <NUM_LIT> , <EOL> maxValue : <NUM_LIT> , <EOL> } , <EOL> default : <NUM_LIT> , <EOL> description : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> displayOptions : { <EOL> show : { <EOL> mode : [ '<STR_LIT>' ] , <EOL> } , <EOL> } , <EOL> options : [ { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , ] , <EOL> default : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> displayOptions : { <EOL> show : { <EOL> mode : [ '<STR_LIT>' ] , <EOL> } , <EOL> } , <EOL> default : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> typeOptions : { <EOL> minValue : <NUM_LIT> , <EOL> maxValue : <NUM_LIT> , <EOL> } , <EOL> displayOptions : { <EOL> show : { <EOL> mode : [ '<STR_LIT>' ] , <EOL> } , <EOL> } , <EOL> default : <NUM_LIT> , <EOL> description : '<STR_LIT>' , <EOL> } , { <EOL> displayName : '<STR_LIT>' , <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> displayOptions : { <EOL> show : { <EOL> mode : [ '<STR_LIT>' ] , <EOL> } , <EOL> } , <EOL> options : [ { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> } , ] , <EOL> default : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> } , ] , <EOL> } , ] , <EOL> } , ] ; <EOL> } <EOL> return [ ] ; <EOL> } <EOL> export param { <EOL> INodeParameters <EOL> } <EOL> nodeValues param { <EOL> ( INodeProperties | INodeCredentialDescription ) <EOL> } <EOL> parameter param { <EOL> INodeParameters <EOL> } <EOL> nodeValuesRoot returns <EOL> export function displayParameter ( nodeValues , parameter , nodeValuesRoot   ? ) { <EOL> if ( ! parameter . displayOptions ) { <EOL> return true ; <EOL> } <EOL> nodeValuesRoot = nodeValuesRoot | | nodeValues ; <EOL> let value ; <EOL> const values = [ ] ; <EOL> if ( parameter . displayOptions . show ) { <EOL> for ( const propertyName of Object . keys ( parameter . displayOptions . show ) ) { <EOL> if ( propertyName . charAt ( <NUM_LIT> ) == = '<STR_LIT>' ) { <EOL> value = get ( nodeValuesRoot , propertyName . slice ( <NUM_LIT> ) ) ; <EOL> } else { <EOL> value = get ( nodeValues , propertyName ) ; <EOL> } <EOL> values . length = <NUM_LIT> ; <EOL> if ( ! Array . isArray ( value ) ) { <EOL> values . push ( value ) ; <EOL> } else { <EOL> values . push . apply ( values , value ) ; <EOL> } <EOL> if ( values . some ( ( v ) = > typeof v == = '<STR_LIT>' & & v . charAt ( <NUM_LIT> ) == = '<STR_LIT>' ) ) { <EOL> return true ; <EOL> } <EOL> if ( values . length == = <NUM_LIT> | |   ! parameter . displayOptions . show [ propertyName ]   ! . some ( ( v ) = > values . includes ( v ) ) ) { <EOL> return false ; <EOL> } <EOL> } <EOL> } <EOL> if ( parameter . displayOptions . hide ) { <EOL> for ( const propertyName of Object . keys ( parameter . displayOptions . hide ) ) { <EOL> if ( propertyName . charAt ( <NUM_LIT> ) == = '<STR_LIT>' ) { <EOL> value = get ( nodeValuesRoot , propertyName . slice ( <NUM_LIT> ) ) ; <EOL> } else { <EOL> value = get ( nodeValues , propertyName ) ; <EOL> } <EOL> values . length = <NUM_LIT> ; <EOL> if ( ! Array . isArray ( value ) ) { <EOL> values . push ( value ) ; <EOL> } else { <EOL> values . push . apply ( values , value ) ; <EOL> } <EOL> if ( values . length != = <NUM_LIT> & & parameter . displayOptions . hide [ propertyName ]   ! . some ( ( v ) = > values . includes ( v ) ) ) { <EOL> return false ; <EOL> } <EOL> } <EOL> } <EOL> return true ; <EOL> } <EOL> export param { <EOL> INodeParameters <EOL> } <EOL> nodeValues param { <EOL> ( INodeProperties | INodeCredentialDescription ) <EOL> } <EOL> parameter param { <EOL> string <EOL> } <EOL> path returns <EOL> export function displayParameterPath ( nodeValues , parameter , path ) { <EOL> let resolvedNodeValues = nodeValues ; <EOL> if ( path != = '<STR_LIT>' ) { <EOL> resolvedNodeValues = get ( nodeValues , path ) as INodeParameters ; <EOL> } <EOL> let nodeValuesRoot = nodeValues ; <EOL> if ( path & & path . split ( '<STR_LIT>' ) . indexOf ( '<STR_LIT>' ) == = <NUM_LIT> ) { <EOL> nodeValuesRoot = get ( nodeValues , '<STR_LIT>' ) as INodeParameters ; <EOL> } <EOL> return displayParameter ( resolvedNodeValues , parameter , nodeValuesRoot ) ; <EOL> } <EOL> export param { <EOL> IRunExecutionData <EOL> } <EOL> runExecutionData param { <EOL> string <EOL> } <EOL> type param { <EOL> INode <EOL> } <EOL> node returns { <EOL> IContextObject <EOL> } <EOL> export function getContext ( runExecutionData , type , node   ? ) { <EOL> if ( runExecutionData . executionData == = undefined ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> let key ; <EOL> if ( type == = '<STR_LIT>' ) { <EOL> key = '<STR_LIT>' ; <EOL> } else if ( type == = '<STR_LIT>' ) { <EOL> if ( node == = undefined ) { <EOL> throw new Error ( ` The request data of context type "<STR_LIT>" the node parameter has to be set ! ` ) ; <EOL> } <EOL> key =   ` node : $ { node . name } ` ; <EOL> } else { <EOL> throw new Error ( ` The context type "<STR_LIT>" is not know . Only "<STR_LIT>" and node " are supported ! ` ) ; <EOL> } <EOL> if ( runExecutionData . executionData . contextData [ key ] == = undefined ) { <EOL> runExecutionData . executionData . contextData [ key ] = { } ; <EOL> } <EOL> return runExecutionData . executionData . contextData [ key ] ; <EOL> } <EOL> export param { <EOL> INodeProperties [ ] <EOL> } <EOL> nodePropertiesArray returns { <EOL> IParameterDependencies <EOL> } <EOL> export function getParamterDependencies ( nodePropertiesArray ) { <EOL> const dependencies = { } ; <EOL> let displayRule ; <EOL> let parameterName ; <EOL> for ( const nodeProperties of nodePropertiesArray ) { <EOL> if ( dependencies [ nodeProperties . name ] == = undefined ) { <EOL> dependencies [ nodeProperties . name ] = [ ] ; <EOL> } <EOL> if ( nodeProperties . displayOptions == = undefined ) { <EOL> continue ; <EOL> } <EOL> for ( displayRule of Object . keys ( nodeProperties . displayOptions ) ) { <EOL> for ( parameterName of Object . keys ( nodeProperties . displayOptions [ displayRule ] ) ) { <EOL> if ( ! dependencies [ nodeProperties . name ] . includes ( parameterName ) ) { <EOL> dependencies [ nodeProperties . name ] . push ( parameterName ) ; <EOL> } <EOL> } <EOL> } <EOL> } <EOL> return dependencies ; <EOL> } <EOL> export param { <EOL> INodeProperties [ ] <EOL> } <EOL> nodePropertiesArray param { <EOL> IParameterDependencies <EOL> } <EOL> parameterDependencies returns { <EOL> number [ ] <EOL> } <EOL> export function getParamterResolveOrder ( nodePropertiesArray , parameterDependencies ) { <EOL> const executionOrder = [ ] ; <EOL> const indexToResolve = Array . from ( { <EOL> length : nodePropertiesArray . length <EOL> } , ( v , k ) = > k ) ; <EOL> const resolvedParamters = [ ] ; <EOL> let index ; <EOL> let property ; <EOL> let lastIndexLength = indexToResolve . length ; <EOL> let lastIndexReduction = - <NUM_LIT> ; <EOL> let iterations = <NUM_LIT> ; <EOL> while ( indexToResolve . length != = <NUM_LIT> ) { <EOL> iterations += <NUM_LIT> ; <EOL> index = indexToResolve . shift ( ) as number ; <EOL> property = nodePropertiesArray [ index ] ; <EOL> if ( parameterDependencies [ property . name ] . length == = <NUM_LIT> ) { <EOL> executionOrder . push ( index ) ; <EOL> resolvedParamters . push ( property . name ) ; <EOL> continue ; <EOL> } <EOL> for ( const dependency of parameterDependencies [ property . name ] ) { <EOL> if ( ! resolvedParamters . includes ( dependency ) ) { <EOL> if ( dependency . charAt ( <NUM_LIT> ) == = '<STR_LIT>' ) { <EOL> continue ; <EOL> } <EOL> indexToResolve . push ( index ) ; <EOL> continue ; <EOL> } <EOL> } <EOL> executionOrder . push ( index ) ; <EOL> resolvedParamters . push ( property . name ) ; <EOL> if ( indexToResolve . length < lastIndexLength ) { <EOL> lastIndexReduction = iterations ; <EOL> } <EOL> if ( iterations > lastIndexReduction + nodePropertiesArray . length ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> lastIndexLength = indexToResolve . length ; <EOL> } <EOL> return executionOrder ; <EOL> } <EOL> export param { <EOL> INodeProperties [ ] <EOL> } <EOL> nodePropertiesArray param { <EOL> INodeParameters <EOL> } <EOL> nodeValues param { <EOL> boolean <EOL> } <EOL> returnDefaults param { <EOL> boolean <EOL> } <EOL> returnNoneDisplayed param { <EOL> boolean <EOL> } <EOL> onlySimpleTypes param { <EOL> boolean <EOL> } <EOL> dataIsResolved param { <EOL> INodeParameters <EOL> } <EOL> nodeValuesRoot returns { <EOL> ( INodeParameters | null ) <EOL> } <EOL> export function getNodeParameters ( nodePropertiesArray , nodeValues , returnDefaults , returnNoneDisplayed , onlySimpleTypes = false , dataIsResolved = false , nodeValuesRoot   ? , parentType   ? , parameterDependencies   ? ) { <EOL> if ( parameterDependencies == = undefined ) { <EOL> parameterDependencies = getParamterDependencies ( nodePropertiesArray ) ; <EOL> } <EOL> const duplicateParameterNames = [ ] ; <EOL> const parameterNames = [ ] ; <EOL> for ( const nodeProperties of nodePropertiesArray ) { <EOL> if ( parameterNames . includes ( nodeProperties . name ) ) { <EOL> if ( ! duplicateParameterNames . includes ( nodeProperties . name ) ) { <EOL> duplicateParameterNames . push ( nodeProperties . name ) ; <EOL> } <EOL> } else { <EOL> parameterNames . push ( nodeProperties . name ) ; <EOL> } <EOL> } <EOL> const nodeParameters = { } ; <EOL> const nodeParametersFull = { } ; <EOL> let nodeValuesDisplayCheck = nodeParametersFull ; <EOL> if ( ! dataIsResolved & &   ! returnNoneDisplayed ) { <EOL> nodeValuesDisplayCheck = getNodeParameters ( nodePropertiesArray , nodeValues , true , true , true , true , nodeValuesRoot , parentType , parameterDependencies ) as INodeParameters ; <EOL> } <EOL> nodeValuesRoot = nodeValuesRoot | | nodeValuesDisplayCheck ; <EOL> const parameterItterationOrderIndex = getParamterResolveOrder ( nodePropertiesArray , parameterDependencies ) ; <EOL> for ( const parameterIndex of parameterItterationOrderIndex ) { <EOL> const nodeProperties = nodePropertiesArray [ parameterIndex ] ; <EOL> if ( nodeValues [ nodeProperties . name ] == = undefined & & ( ! returnDefaults | | parentType == = '<STR_LIT>' ) ) { <EOL> continue ; <EOL> } <EOL> if ( ! returnNoneDisplayed & &   ! displayParameter ( nodeValuesDisplayCheck , nodeProperties , nodeValuesRoot ) ) { <EOL> if ( ! returnNoneDisplayed | |   ! returnDefaults ) { <EOL> continue ; <EOL> } <EOL> } <EOL> if ( ! [ '<STR_LIT>' , '<STR_LIT>' ] . includes ( nodeProperties . type ) ) { <EOL> if ( duplicateParameterNames . includes ( nodeProperties . name ) ) { <EOL> if ( ! displayParameter ( nodeValuesDisplayCheck , nodeProperties , nodeValuesRoot ) ) { <EOL> continue ; <EOL> } <EOL> } <EOL> if ( returnDefaults ) { <EOL> if ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( nodeProperties . type ) ) { <EOL> nodeParameters [ nodeProperties . name ] = nodeValues [ nodeProperties . name ] != = undefined   ? nodeValues [ nodeProperties . name ] : nodeProperties . default ; <EOL> } else { <EOL> nodeParameters [ nodeProperties . name ] = nodeValues [ nodeProperties . name ] | | nodeProperties . default ; <EOL> } <EOL> nodeParametersFull [ nodeProperties . name ] = nodeParameters [ nodeProperties . name ] ; <EOL> } else if ( ( nodeValues [ nodeProperties . name ] != = nodeProperties . default & & typeof nodeValues [ nodeProperties . name ] != = '<STR_LIT>' ) | | ( typeof nodeValues [ nodeProperties . name ] == = '<STR_LIT>' & &   ! isEqual ( nodeValues [ nodeProperties . name ] , nodeProperties . default ) ) | | ( nodeValues [ nodeProperties . name ] != = undefined & & parentType == = '<STR_LIT>' ) ) { <EOL> nodeParameters [ nodeProperties . name ] = nodeValues [ nodeProperties . name ] ; <EOL> nodeParametersFull [ nodeProperties . name ] = nodeParameters [ nodeProperties . name ] ; <EOL> continue ; <EOL> } <EOL> } <EOL> if ( onlySimpleTypes ) { <EOL> continue ; <EOL> } <EOL> let tempValue ; <EOL> if ( nodeProperties . type == = '<STR_LIT>' ) { <EOL> if ( nodeProperties . typeOptions != = undefined & & nodeProperties . typeOptions . multipleValues == = true ) { <EOL> if ( nodeValues [ nodeProperties . name ] != = undefined ) { <EOL> nodeParameters [ nodeProperties . name ] = nodeValues [ nodeProperties . name ] ; <EOL> } else if ( returnDefaults ) { <EOL> if ( Array . isArray ( nodeProperties . default ) ) { <EOL> nodeParameters [ nodeProperties . name ] = JSON . parse ( JSON . stringify ( nodeProperties . default ) ) ; <EOL> } else { <EOL> nodeParameters [ nodeProperties . name ] = [ ] ; <EOL> } <EOL> } <EOL> nodeParametersFull [ nodeProperties . name ] = nodeParameters [ nodeProperties . name ] ; <EOL> } else if ( nodeValues [ nodeProperties . name ] != = undefined ) { <EOL> const tempNodeParameters = getNodeParameters ( nodeProperties . options as INodeProperties [ ] , nodeValues [ nodeProperties . name ] as INodeParameters , returnDefaults , returnNoneDisplayed , false , false , nodeValuesRoot , nodeProperties . type ) ; <EOL> if ( tempNodeParameters != = null ) { <EOL> nodeParameters [ nodeProperties . name ] = tempNodeParameters ; <EOL> nodeParametersFull [ nodeProperties . name ] = nodeParameters [ nodeProperties . name ] ; <EOL> } <EOL> } else if ( returnDefaults ) { <EOL> nodeParameters [ nodeProperties . name ] = JSON . parse ( JSON . stringify ( nodeProperties . default ) ) ; <EOL> nodeParametersFull [ nodeProperties . name ] = nodeParameters [ nodeProperties . name ] ; <EOL> } <EOL> } else if ( nodeProperties . type == = '<STR_LIT>' ) { <EOL> const collectionValues = { } ; <EOL> let tempNodeParameters ; <EOL> let tempNodePropertiesArray ; <EOL> let nodePropertyOptions ; <EOL> let propertyValues = nodeValues [ nodeProperties . name ] ; <EOL> if ( returnDefaults ) { <EOL> if ( propertyValues == = undefined ) { <EOL> propertyValues = JSON . parse ( JSON . stringify ( nodeProperties . default ) ) ; <EOL> } <EOL> } <EOL> for ( const itemName of Object . keys ( propertyValues | | { } ) ) { <EOL> if ( nodeProperties . typeOptions != = undefined & & nodeProperties . typeOptions . multipleValues == = true ) { <EOL> const tempArrayValue = [ ] ; <EOL> for ( const nodeValue of ( propertyValues as INodeParameters ) [ itemName ] as INodeParameters [ ] ) { <EOL> nodePropertyOptions = nodeProperties . options ! . find ( ( nodePropertyOptions ) = > nodePropertyOptions . name == = itemName ) as INodePropertyCollection ; <EOL> if ( nodePropertyOptions == = undefined ) { <EOL> throw new Error ( ` Could not find property option "<STR_LIT>" for "<STR_LIT>" ` ) ; <EOL> } <EOL> tempNodePropertiesArray = nodePropertyOptions . values ! ; <EOL> tempValue = getNodeParameters ( tempNodePropertiesArray , nodeValue , returnDefaults , returnNoneDisplayed , false , false , nodeValuesRoot , nodeProperties . type ) ; <EOL> if ( tempValue != = null ) { <EOL> tempArrayValue . push ( tempValue ) ; <EOL> } <EOL> } <EOL> collectionValues [ itemName ] = tempArrayValue ; <EOL> } else { <EOL> tempNodeParameters = { } ; <EOL> const nodePropertyOptions = nodeProperties . options ! . find ( ( data ) = > data . name == = itemName ) ; <EOL> if ( nodePropertyOptions != = undefined ) { <EOL> tempNodePropertiesArray = ( nodePropertyOptions as INodePropertyCollection ) . values ! ; <EOL> tempValue = getNodeParameters ( tempNodePropertiesArray , ( nodeValues [ nodeProperties . name ] as INodeParameters ) [ itemName ] as INodeParameters , returnDefaults , returnNoneDisplayed , false , false , nodeValuesRoot , nodeProperties . type ) ; <EOL> if ( tempValue != = null ) { <EOL> Object . assign ( tempNodeParameters , tempValue ) ; <EOL> } <EOL> } <EOL> if ( Object . keys ( tempNodeParameters ) . length != = <NUM_LIT> ) { <EOL> collectionValues [ itemName ] = tempNodeParameters ; <EOL> } <EOL> } <EOL> } <EOL> if ( Object . keys ( collectionValues ) . length != = <NUM_LIT> | | returnDefaults ) { <EOL> if ( returnDefaults ) { <EOL> if ( collectionValues == = undefined ) { <EOL> nodeParameters [ nodeProperties . name ] = JSON . parse ( JSON . stringify ( nodeProperties . default ) ) ; <EOL> } else { <EOL> nodeParameters [ nodeProperties . name ] = collectionValues ; <EOL> } <EOL> nodeParametersFull [ nodeProperties . name ] = nodeParameters [ nodeProperties . name ] ; <EOL> } else if ( collectionValues != = nodeProperties . default ) { <EOL> nodeParameters [ nodeProperties . name ] = collectionValues ; <EOL> nodeParametersFull [ nodeProperties . name ] = nodeParameters [ nodeProperties . name ] ; <EOL> } <EOL> } <EOL> } <EOL> } <EOL> return nodeParameters ; <EOL> } <EOL> export param { <EOL> INodeExecutionData [ ] <EOL> } <EOL> outputData param { <EOL> number <EOL> } <EOL> outputIndex returns { <EOL> Promise < INodeExecutionData [ ] [ ] > <EOL> } <EOL> export async function prepareOutputData ( outputData , outputIndex = <NUM_LIT> ) { <EOL> const returnData = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < outputIndex ; i + + ) { <EOL> returnData . push ( [ ] ) ; <EOL> } <EOL> returnData . push ( outputData ) ; <EOL> return returnData ; <EOL> } <EOL> export param { <EOL> INode <EOL> } <EOL> node returns { <EOL> IWebhookData [ ] <EOL> } <EOL> export function getNodeWebhooks ( workflow , node , additionalData , ignoreRestartWehbooks = false ) { <EOL> if ( node . disabled == = true ) { <EOL> return [ ] ; <EOL> } <EOL> const nodeType = workflow . nodeTypes . getByNameAndVersion ( node . type , node . typeVersion ) as INodeType ; <EOL> if ( nodeType . description . webhooks == = undefined ) { <EOL> return [ ] ; <EOL> } <EOL> const workflowId = workflow . id | | '<STR_LIT>' ; <EOL> const mode = '<STR_LIT>' ; <EOL> const returnData = [ ] ; <EOL> for ( const webhookDescription of nodeType . description . webhooks ) { <EOL> if ( ignoreRestartWehbooks & & webhookDescription . restartWebhook == = true ) { <EOL> continue ; <EOL> } <EOL> let nodeWebhookPath = workflow . expression . getSimpleParameterValue ( node , webhookDescription . path , mode , { } ) ; <EOL> if ( nodeWebhookPath == = undefined ) { <EOL> console . error ( ` No webhook path could be found for node "<STR_LIT>" in workflow "<STR_LIT>" . ` ) ; <EOL> continue ; <EOL> } <EOL> nodeWebhookPath = nodeWebhookPath . toString ( ) ; <EOL> if ( nodeWebhookPath . startsWith ( '<STR_LIT>' ) ) { <EOL> nodeWebhookPath = nodeWebhookPath . slice ( <NUM_LIT> ) ; <EOL> } <EOL> if ( nodeWebhookPath . endsWith ( '<STR_LIT>' ) ) { <EOL> nodeWebhookPath = nodeWebhookPath . slice ( <NUM_LIT> , - <NUM_LIT> ) ; <EOL> } <EOL> const isFullPath = workflow . expression . getSimpleParameterValue ( node , webhookDescription . isFullPath , '<STR_LIT>' , { } , false ) as boolean ; <EOL> const restartWebhook = workflow . expression . getSimpleParameterValue ( node , webhookDescription . restartWebhook , '<STR_LIT>' , { } , false ) as boolean ; <EOL> const path = getNodeWebhookPath ( workflowId , node , nodeWebhookPath , isFullPath , restartWebhook ) ; <EOL> const httpMethod = workflow . expression . getSimpleParameterValue ( node , webhookDescription . httpMethod , mode , { } , '<STR_LIT>' ) ; <EOL> if ( httpMethod == = undefined ) { <EOL> console . error ( ` The webhook "<STR_LIT>" for node "<STR_LIT>" in workflow "<STR_LIT>" could not be added because the httpMethod is not defined . ` ) ; <EOL> continue ; <EOL> } <EOL> let webhookId ; <EOL> if ( ( path . startsWith ( '<STR_LIT>' ) | | path . includes ( '<STR_LIT>' ) ) & & node . webhookId ) { <EOL> webhookId = node . webhookId ; <EOL> } <EOL> returnData . push ( { <EOL> httpMethod : httpMethod . toString ( ) as WebhookHttpMethod , <EOL> node : node . name , <EOL> path , <EOL> webhookDescription , <EOL> workflowId , <EOL> workflowExecuteAdditionalData : additionalData , <EOL> webhookId , <EOL> } ) ; <EOL> } <EOL> return returnData ; <EOL> } <EOL> export function getNodeWebhooksBasic ( workflow , node ) { <EOL> if ( node . disabled == = true ) { <EOL> return [ ] ; <EOL> } <EOL> const nodeType = workflow . nodeTypes . getByNameAndVersion ( node . type , node . typeVersion ) as INodeType ; <EOL> if ( nodeType . description . webhooks == = undefined ) { <EOL> return [ ] ; <EOL> } <EOL> const workflowId = workflow . id | | '<STR_LIT>' ; <EOL> const mode = '<STR_LIT>' ; <EOL> const returnData = [ ] ; <EOL> for ( const webhookDescription of nodeType . description . webhooks ) { <EOL> let nodeWebhookPath = workflow . expression . getSimpleParameterValue ( node , webhookDescription . path , mode , { } ) ; <EOL> if ( nodeWebhookPath == = undefined ) { <EOL> console . error ( ` No webhook path could be found for node "<STR_LIT>" in workflow "<STR_LIT>" . ` ) ; <EOL> continue ; <EOL> } <EOL> nodeWebhookPath = nodeWebhookPath . toString ( ) ; <EOL> if ( nodeWebhookPath . startsWith ( '<STR_LIT>' ) ) { <EOL> nodeWebhookPath = nodeWebhookPath . slice ( <NUM_LIT> ) ; <EOL> } <EOL> if ( nodeWebhookPath . endsWith ( '<STR_LIT>' ) ) { <EOL> nodeWebhookPath = nodeWebhookPath . slice ( <NUM_LIT> , - <NUM_LIT> ) ; <EOL> } <EOL> const isFullPath = workflow . expression . getSimpleParameterValue ( node , webhookDescription . isFullPath , mode , { } , false ) as boolean ; <EOL> const path = getNodeWebhookPath ( workflowId , node , nodeWebhookPath , isFullPath ) ; <EOL> const httpMethod = workflow . expression . getSimpleParameterValue ( node , webhookDescription . httpMethod , mode , { } ) ; <EOL> if ( httpMethod == = undefined ) { <EOL> console . error ( ` The webhook "<STR_LIT>" for node "<STR_LIT>" in workflow "<STR_LIT>" could not be added because the httpMethod is not defined . ` ) ; <EOL> continue ; <EOL> } <EOL> returnData . push ( { <EOL> httpMethod : httpMethod . toString ( ) as WebhookHttpMethod , <EOL> node : node . name , <EOL> path , <EOL> webhookDescription , <EOL> workflowId , <EOL> } ) ; <EOL> } <EOL> return returnData ; <EOL> } <EOL> export param { <EOL> string <EOL> } <EOL> workflowId param { <EOL> string <EOL> } <EOL> nodeTypeName param { <EOL> string <EOL> } <EOL> path returns { <EOL> string <EOL> } <EOL> export function getNodeWebhookPath ( workflowId , node , path , isFullPath   ? , restartWebhook   ? ) { <EOL> let webhookPath = '<STR_LIT>' ; <EOL> if ( restartWebhook == = true ) { <EOL> return path ; <EOL> } <EOL> if ( node . webhookId == = undefined ) { <EOL> webhookPath =   ` $ { workflowId } / $ { encodeURIComponent ( node . name . toLowerCase ( ) ) } / $ { path } ` ; <EOL> } else { <EOL> if ( isFullPath == = true ) { <EOL> return path ; <EOL> } <EOL> webhookPath =   ` $ { node . webhookId } / $ { path } ` ; <EOL> } <EOL> return webhookPath ; <EOL> } <EOL> export param { <EOL> string <EOL> } <EOL> baseUrl param { <EOL> string <EOL> } <EOL> workflowId param { <EOL> string <EOL> } <EOL> nodeTypeName param { <EOL> string <EOL> } <EOL> path param { <EOL> boolean <EOL> } <EOL> isFullPath returns { <EOL> string <EOL> } <EOL> export function getNodeWebhookUrl ( baseUrl , workflowId , node , path , isFullPath   ? ) { <EOL> if ( ( path . startsWith ( '<STR_LIT>' ) | | path . includes ( '<STR_LIT>' ) ) & & node . webhookId ) { <EOL> isFullPath = false ; <EOL> } <EOL> if ( path . startsWith ( '<STR_LIT>' ) ) { <EOL> path = path . slice ( <NUM_LIT> ) ; <EOL> } <EOL> return   ` $ { baseUrl } / $ { getNodeWebhookPath ( workflowId , node , path , isFullPath ) } ` ; <EOL> } <EOL> export param { <EOL> INodeProperties [ ] <EOL> } <EOL> nodePropertiesArray param { <EOL> INode <EOL> } <EOL> node returns { <EOL> ( INodeIssues | null ) <EOL> } <EOL> export function getNodeParametersIssues ( nodePropertiesArray , node ) { <EOL> const foundIssues = { } ; <EOL> let propertyIssues ; <EOL> if ( node . disabled == = true ) { <EOL> return null ; <EOL> } <EOL> for ( const nodeProperty of nodePropertiesArray ) { <EOL> propertyIssues = getParameterIssues ( nodeProperty , node . parameters , '<STR_LIT>' ) ; <EOL> mergeIssues ( foundIssues , propertyIssues ) ; <EOL> } <EOL> if ( Object . keys ( foundIssues ) . length == = <NUM_LIT> ) { <EOL> return null ; <EOL> } <EOL> return foundIssues ; <EOL> } <EOL> export param { <EOL> INodeIssues <EOL> } <EOL> issues param { <EOL> INode <EOL> } <EOL> node returns { <EOL> string [ ] <EOL> } <EOL> export function nodeIssuesToString ( issues , node   ? ) { <EOL> const nodeIssues = [ ] ; <EOL> if ( issues . execution != = undefined ) { <EOL> nodeIssues . push ( ` Execution Error . ` ) ; <EOL> } <EOL> const objectProperties = [ '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> let issueText ; <EOL> let parameterName ; <EOL> for ( const propertyName of objectProperties ) { <EOL> if ( issues [ propertyName ] != = undefined ) { <EOL> for ( parameterName of Object . keys ( issues [ propertyName ] as object ) ) { <EOL> for ( issueText of ( issues [ propertyName ] as INodeIssueObjectProperty ) [ parameterName ] ) { <EOL> nodeIssues . push ( issueText ) ; <EOL> } <EOL> } <EOL> } <EOL> } <EOL> if ( issues . typeUnknown != = undefined ) { <EOL> if ( node != = undefined ) { <EOL> nodeIssues . push ( ` Node Type "<STR_LIT>" is not known . ` ) ; <EOL> } else { <EOL> nodeIssues . push ( ` Node Type is not known . ` ) ; <EOL> } <EOL> } <EOL> return nodeIssues ; <EOL> } <EOL> export param { <EOL> INodeIssues <EOL> } <EOL> foundIssues param { <EOL> INodeProperties <EOL> } <EOL> nodeProperties param { <EOL> NodeParameterValue <EOL> } <EOL> value <EOL> export function addToIssuesIfMissing ( foundIssues , nodeProperties , value ) { <EOL> if ( ( nodeProperties . type == = '<STR_LIT>' & & ( value == = '<STR_LIT>' | | value == = undefined ) ) | | ( nodeProperties . type == = '<STR_LIT>' & & Array . isArray ( value ) & & value . length == = <NUM_LIT> ) | | ( nodeProperties . type == = '<STR_LIT>' & & value == = undefined ) ) { <EOL> if ( foundIssues . parameters == = undefined ) { <EOL> foundIssues . parameters = { } ; <EOL> } <EOL> if ( foundIssues . parameters [ nodeProperties . name ] == = undefined ) { <EOL> foundIssues . parameters [ nodeProperties . name ] = [ ] ; <EOL> } <EOL> foundIssues . parameters [ nodeProperties . name ] . push ( ` Parameter "<STR_LIT>" is required . ` ) ; <EOL> } <EOL> } <EOL> export param { <EOL> INodeParameters <EOL> } <EOL> nodeValues param { <EOL> string <EOL> } <EOL> parameterName param { <EOL> string <EOL> } <EOL> path returns <EOL> export function getParameterValueByPath ( nodeValues , parameterName , path ) { <EOL> return get ( nodeValues , path   ?   ` $ { path } . $ { parameterName } ` : parameterName ) ; <EOL> } <EOL> export param { <EOL> INodeProperties <EOL> } <EOL> nodeProperties param { <EOL> INodeParameters <EOL> } <EOL> nodeValues param { <EOL> string <EOL> } <EOL> path returns { <EOL> INodeIssues <EOL> } <EOL> export function getParameterIssues ( nodeProperties , nodeValues , path ) { <EOL> const foundIssues = { } ; <EOL> let value ; <EOL> if ( nodeProperties . required == = true ) { <EOL> if ( displayParameterPath ( nodeValues , nodeProperties , path ) ) { <EOL> value = getParameterValueByPath ( nodeValues , nodeProperties . name , path ) ; <EOL> if ( nodeProperties . typeOptions != = undefined & & nodeProperties . typeOptions . multipleValues != = undefined ) { <EOL> if ( Array . isArray ( value ) ) { <EOL> for ( const singleValue of value as NodeParameterValue [ ] ) { <EOL> addToIssuesIfMissing ( foundIssues , nodeProperties , singleValue ) ; <EOL> } <EOL> } <EOL> } else { <EOL> addToIssuesIfMissing ( foundIssues , nodeProperties , value as NodeParameterValue ) ; <EOL> } <EOL> } <EOL> } <EOL> if ( nodeProperties . options == = undefined ) { <EOL> return foundIssues ; <EOL> } <EOL> let basePath = path   ?   ` $ { path } . ` : '<STR_LIT>' ; <EOL> const checkChildNodeProperties = [ ] ; <EOL> if ( nodeProperties . type == = '<STR_LIT>' ) { <EOL> for ( const option of nodeProperties . options ) { <EOL> checkChildNodeProperties . push ( { <EOL> basePath , <EOL> data : option as INodeProperties , <EOL> } ) ; <EOL> } <EOL> } else if ( nodeProperties . type == = '<STR_LIT>' ) { <EOL> basePath = basePath   ?   ` $ { basePath } . ` :   ` $ { nodeProperties . name } . ` ; <EOL> let propertyOptions ; <EOL> for ( propertyOptions of nodeProperties . options as INodePropertyCollection [ ] ) { <EOL> value = getParameterValueByPath ( nodeValues , propertyOptions . name , basePath . slice ( <NUM_LIT> , - <NUM_LIT> ) ) ; <EOL> if ( value == = undefined ) { <EOL> continue ; <EOL> } <EOL> if ( nodeProperties . typeOptions != = undefined & & nodeProperties . typeOptions . multipleValues != = undefined ) { <EOL> if ( Array . isArray ( value ) ) { <EOL> for ( let i = <NUM_LIT> ; i < ( value as INodeParameters [ ] ) . length ; i + + ) { <EOL> for ( const option of propertyOptions . values ) { <EOL> checkChildNodeProperties . push ( { <EOL> basePath :   ` $ { basePath } $ { propertyOptions . name } [ $ { i } ] ` , <EOL> data : option , <EOL> } ) ; <EOL> } <EOL> } <EOL> } <EOL> } else { <EOL> for ( const option of propertyOptions . values ) { <EOL> checkChildNodeProperties . push ( { <EOL> basePath : basePath + propertyOptions . name , <EOL> data : option , <EOL> } ) ; <EOL> } <EOL> } <EOL> } <EOL> } else { <EOL> return foundIssues ; <EOL> } <EOL> let propertyIssues ; <EOL> for ( const optionData of checkChildNodeProperties ) { <EOL> propertyIssues = getParameterIssues ( optionData . data , nodeValues , optionData . basePath ) ; <EOL> mergeIssues ( foundIssues , propertyIssues ) ; <EOL> } <EOL> return foundIssues ; <EOL> } <EOL> export param { <EOL> INodeIssues <EOL> } <EOL> destination param { <EOL> ( INodeIssues | null ) <EOL> } <EOL> source returns <EOL> export function mergeIssues ( destination , source ) { <EOL> if ( source == = null ) { <EOL> return ; <EOL> } <EOL> if ( source . execution == = true ) { <EOL> destination . execution = true ; <EOL> } <EOL> const objectProperties = [ '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> let destinationProperty ; <EOL> for ( const propertyName of objectProperties ) { <EOL> if ( source [ propertyName ] != = undefined ) { <EOL> if ( destination [ propertyName ] == = undefined ) { <EOL> destination [ propertyName ] = { } ; <EOL> } <EOL> let parameterName ; <EOL> for ( parameterName of Object . keys ( source [ propertyName ] as INodeIssueObjectProperty ) ) { <EOL> destinationProperty = destination [ propertyName ] as INodeIssueObjectProperty ; <EOL> if ( destinationProperty [ parameterName ] == = undefined ) { <EOL> destinationProperty [ parameterName ] = [ ] ; <EOL> } <EOL> destinationProperty [ parameterName ] . push . apply ( destinationProperty [ parameterName ] , ( source [ propertyName ] as INodeIssueObjectProperty ) [ parameterName ] ) ; <EOL> } <EOL> } <EOL> } <EOL> if ( source . typeUnknown == = true ) { <EOL> destination . typeUnknown = true ; <EOL> } <EOL> } <EOL> export param { <EOL> INodeProperties [ ] <EOL> } <EOL> mainProperties param { <EOL> INodeProperties [ ] <EOL> } <EOL> addProperties <EOL> export function mergeNodeProperties ( mainProperties , addProperties ) { <EOL> let existingIndex ; <EOL> for ( const property of addProperties ) { <EOL> existingIndex = mainProperties . findIndex ( ( element ) = > element . name == = property . name ) ; <EOL> if ( existingIndex == = - <NUM_LIT> ) { <EOL> mainProperties . push ( property ) ; <EOL> } else { <EOL> mainProperties [ existingIndex ] = property ; <EOL> } <EOL> } <EOL> } <EOL> export function getVersionedNodeType ( object , version   ? ) { <EOL> if ( isNodeTypeVersioned ( object ) ) { <EOL> return ( object as INodeVersionedType ) . getNodeType ( version ) ; <EOL> } <EOL> return object as INodeType ; <EOL> } <EOL> export function getVersionedNodeTypeAll ( object ) { <EOL> if ( isNodeTypeVersioned ( object ) ) { <EOL> return Object . values ( ( object as INodeVersionedType ) . nodeVersions ) . map ( ( element ) = > { <EOL> element . description . name = object . description . name ; <EOL> return element ; <EOL> } ) ; <EOL> } <EOL> return [ object as INodeType ] ; <EOL> } <EOL> export function isNodeTypeVersioned ( object ) { <EOL> return   ! ! ( '<STR_LIT>' in object ) ; <EOL> } </s>
<s> import { <EOL> ExpressionTypeDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionValueRender <EOL> } from '<STR_LIT>' ; <EOL> const name = '<STR_LIT>' ; <EOL> export interface ExpressionImage { <EOL> type : '<STR_LIT>' ; mode : string ; dataurl : string ; <EOL> } <EOL> export const image = { <EOL> name , <EOL> to : { <EOL> render : ( input ) : ExpressionValueRender < Pick < ExpressionImage , <EOL> '<STR_LIT>' | '<STR_LIT>' > > = > { <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> as : '<STR_LIT>' , <EOL> value : input , <EOL> } ; <EOL> } , <EOL> } , <EOL> } ; </s>
<s> import { <EOL> instance , <EOL> mock , <EOL> when <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MissingWhen , <EOL> UnfinishedExpectation <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> clearActiveMock <EOL> } from '<STR_LIT>' ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> beforeEach ( ( ) = > { <EOL> clearActiveMock ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const fn = mock < ( ) = > void > ( ) ; <EOL> when ( fn ( ) ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const fn = mock < ( ) = > void > ( ) ; <EOL> when ( fn ( ) ) ; <EOL> expect ( ( ) = > when ( fn ( ) ) ) . toThrow ( UnfinishedExpectation ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const fn1 = mock < ( ) = > number > ( ) ; <EOL> const { <EOL> thenReturn : returns1 <EOL> } = when ( fn1 ( ) ) ; <EOL> const fn2 = mock < ( ) = > number > ( ) ; <EOL> returns1 ( <NUM_LIT> ) ; <EOL> when ( fn2 ( ) ) . thenReturn ( <NUM_LIT> ) ; <EOL> expect ( instance ( fn1 ) ( ) ) . toEqual ( <NUM_LIT> ) ; <EOL> expect ( instance ( fn2 ) ( ) ) . toEqual ( <NUM_LIT> ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const fn = mock < ( x : number ) = > number > ( ) ; <EOL> const stub = when ( fn ( <NUM_LIT> ) ) ; <EOL> stub . thenReturn ( <NUM_LIT> ) ; <EOL> expect ( ( ) = > stub . thenReturn ( <NUM_LIT> ) ) . toThrow ( MissingWhen ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const fn = mock < ( ) = > void > ( ) ; <EOL> fn ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const fn = mock < ( ) = > number > ( ) ; <EOL> when ( fn ( ) ) . thenReturn ( <NUM_LIT> ) ; <EOL> when ( fn ( ) ) . thenReturn ( <NUM_LIT> ) ; <EOL> expect ( instance ( fn ) ( ) ) . toEqual ( <NUM_LIT> ) ; <EOL> expect ( instance ( fn ) ( ) ) . toEqual ( <NUM_LIT> ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const fn1 = mock < ( ) = > number > ( ) ; <EOL> const fn2 = mock < ( ) = > number > ( ) ; <EOL> when ( fn1 ( ) ) . thenReturn ( <NUM_LIT> ) ; <EOL> when ( fn2 ( ) ) . thenReturn ( <NUM_LIT> ) ; <EOL> expect ( instance ( fn2 ) ( ) ) . toEqual ( <NUM_LIT> ) ; <EOL> expect ( instance ( fn1 ) ( ) ) . toEqual ( <NUM_LIT> ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> BucketAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggTypesDependencies <EOL> } from '<STR_LIT>' ; <EOL> export type AggTypesRegistrySetup = ReturnType < AggTypesRegistry [ '<STR_LIT>' ] > ; <EOL> internal <EOL> export interface AggTypesRegistryStart { <EOL> get : ( id : string ) = > BucketAggType < any > | MetricAggType < any > ; getAll : ( ) = > { <EOL> buckets : Array < BucketAggType < any > > ; metrics : Array < MetricAggType < any > > ; <EOL> } ; <EOL> } <EOL> export class AggTypesRegistry { <EOL> private readonly bucketAggs = new Map ( ) ; <EOL> private readonly metricAggs = new Map ( ) ; <EOL> setup = ( ) = > { <EOL> return { <EOL> registerBucket : < N extends string , T extends ( deps : AggTypesDependencies ) = > BucketAggType < any > > ( name , type ) : void = > { if ( this . bucketAggs . get ( name ) | | this . metricAggs . get ( name ) ) { throw new Error (   ` Agg has already been registered with name :   $ { name } ` ) ; } this . bucketAggs . set ( name , type ) ; } , registerMetric : < N extends string , T extends ( deps : AggTypesDependencies ) = > MetricAggType < any > > ( name , type ) : void = > { if ( this . bucketAggs . get ( name ) | | this . metricAggs . get ( name ) ) { throw new Error (   ` Agg has already been registered with name :   $ { name } ` ) ; } this . metricAggs . set ( name , type ) ; } , } ; } ; start = ( ) = > { return { get : ( name ) = > { return this . bucketAggs . get ( name ) | | this . metricAggs . get ( name ) ; } , getAll : ( ) = > { return { buckets : Array . from ( this . bucketAggs . values ( ) ) , metrics : Array . from ( this . metricAggs . values ( ) ) , } ; } , } ; } ; } </s>
<s> import { <EOL> OpenSearchQueryConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GetConfigFn , <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> interface OpenSearchDashboardsConfig { <EOL> get : GetConfigFn ; <EOL> } <EOL> export function getOpenSearchQueryConfig ( config ) { <EOL> const allowLeadingWildcards = config . get ( UI_SETTINGS . QUERY_ALLOW_LEADING_WILDCARDS ) ; <EOL> const queryStringOptions = config . get ( UI_SETTINGS . QUERY_STRING_OPTIONS ) ; <EOL> const ignoreFilterIfFieldNotInIndex = config . get ( UI_SETTINGS . COURIER_IGNORE_FILTER_IF_FIELD_NOT_IN_INDEX ) ; <EOL> const dateFormatTZ = config . get ( '<STR_LIT>' ) ; <EOL> return { <EOL> allowLeadingWildcards , <EOL> queryStringOptions , <EOL> ignoreFilterIfFieldNotInIndex , <EOL> dateFormatTZ , <EOL> } <EOL> as OpenSearchQueryConfig ; <EOL> } </s>
<s> import { <EOL> PluginInitializerContext , <EOL> CoreSetup , <EOL> CoreStart , <EOL> Plugin , <EOL> Logger <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomIntegrationsPluginSetup , <EOL> CustomIntegrationsPluginStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomIntegration <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomIntegrationRegistry <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> defineRoutes <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> registerLanguageClients <EOL> } from '<STR_LIT>' ; <EOL> export class CustomIntegrationsPlugin implements Plugin < CustomIntegrationsPluginSetup , CustomIntegrationsPluginStart > { <EOL> private readonly logger : Logger ; private readonly customIngegrationRegistry : CustomIntegrationRegistry ; private readonly branch : string ; constructor ( initializerContext ) { <EOL> this . logger = initializerContext . logger . get ( ) ; <EOL> this . customIngegrationRegistry = new CustomIntegrationRegistry ( this . logger , initializerContext . env . mode . dev ) ; <EOL> this . branch = initializerContext . env . packageInfo . branch ; <EOL> } <EOL> public setup ( core ) { <EOL> this . logger . debug ( '<STR_LIT>' ) ; <EOL> const router = core . http . createRouter ( ) ; <EOL> defineRoutes ( router , this . customIngegrationRegistry ) ; <EOL> registerLanguageClients ( core , this . customIngegrationRegistry , this . branch ) ; <EOL> return { <EOL> registerCustomIntegration : ( integration ) = > { <EOL> this . customIngegrationRegistry . registerCustomIntegration ( { <EOL> type : '<STR_LIT>' , <EOL> ... integration , <EOL> } ) ; <EOL> } , <EOL> getAppendCustomIntegrations : ( ) = > { <EOL> return this . customIngegrationRegistry . getAppendCustomIntegrations ( ) ; <EOL> } , <EOL> } <EOL> as CustomIntegrationsPluginSetup ; <EOL> } <EOL> public start ( core ) { <EOL> this . logger . debug ( '<STR_LIT>' ) ; <EOL> return { } ; <EOL> } <EOL> public stop ( ) { } <EOL> } </s>
<s> import { <EOL> GetAllProductHandlerQuery <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GetBySkuProductHandlerQuery <EOL> } from '<STR_LIT>' ; <EOL> export const QueriesHandlers = [ GetAllProductHandlerQuery , GetBySkuProductHandlerQuery ] ; </s>
<s> import Debug from '<STR_LIT>' ; <EOL> import { <EOL> Task , <EOL> TaskExecuteOptions <EOL> } from '<STR_LIT>' ; <EOL> import * as fs from '<STR_LIT>' ; <EOL> import { <EOL> splitEvery <EOL> } from '<STR_LIT>' ; <EOL> export async function execute ( tasks , options   ? ) { <EOL> const { <EOL> indent = <NUM_LIT> , singleResult = true , domain = '<STR_LIT>' , parallel = false , batchSize = <NUM_LIT> <EOL> } = options | | { } ; <EOL> const debug = Debug ( '<STR_LIT>' ) . extend ( domain ) ; <EOL> const debugError = Debug ( '<STR_LIT>' ) . extend ( domain ) ; <EOL> const indentation = '<STR_LIT>' . repeat ( indent ) ; <EOL> const ctx = { } ; <EOL> const results = [ ] ; <EOL> for ( const taskBatch of splitEvery ( batchSize , tasks ) ) { <EOL> const taskPromises = [ ] ; <EOL> for ( const task of taskBatch ) { <EOL> debug ( ` $ { indentation }   $ { task . name } ` ) ; <EOL> const taskProm = ( ) = > new Promise ( ( resolve , reject ) = > task . task ( ctx ) . then ( ( res = { } ) = > { <EOL> if ( res . errors ) { <EOL> reject ( res ) ; <EOL> } else { <EOL> resolve ( res ) ; <EOL> } <EOL> return res ; <EOL> } ) . catch ( reject ) ) . then ( ( res ) = > results . push ( res ) ) . catch ( ( error ) = > { <EOL> results . push ( { <EOL> error <EOL> } ) ; <EOL> debugError ( ` $ { indentation } error :   $ { task . name } :   $ { error . message } ` ) ; <EOL> try { <EOL> if ( process . env . SAVE_LOG ) { <EOL> fs . appendFileSync ( '<STR_LIT>' , domain ) ; <EOL> fs . appendFileSync ( '<STR_LIT>' , JSON . stringify ( JSON . parse ( error . requestResult . responseRaw ) , null , <NUM_LIT> ) ) ; <EOL> } <EOL> debugError ( JSON . stringify ( JSON . parse ( error . requestResult . responseRaw ) , null , <NUM_LIT> ) ) ; <EOL> } catch ( error ) { <EOL> if ( process . env . SAVE_LOG ) { <EOL> fs . appendFileSync ( '<STR_LIT>' , domain ) ; <EOL> fs . appendFileSync ( '<STR_LIT>' , JSON . stringify ( error , null , <NUM_LIT> ) ) ; <EOL> } <EOL> debugError ( JSON . stringify ( error , null , <NUM_LIT> ) ) ; <EOL> } <EOL> if ( task . fullError ) { <EOL> try { <EOL> debugError ( JSON . stringify ( JSON . parse ( error . requestResult . responseRaw ) , null , <NUM_LIT> ) ) ; <EOL> } catch ( e ) { <EOL> debugError ( JSON . stringify ( error , null , <NUM_LIT> ) ) ; <EOL> } <EOL> } <EOL> } ) ; <EOL> if ( parallel ) { <EOL> taskPromises . push ( taskProm ( ) ) ; <EOL> } else { <EOL> await taskProm ( ) ; <EOL> } <EOL> } <EOL> if ( parallel ) { <EOL> await Promise . all ( taskPromises ) ; <EOL> } <EOL> } <EOL> if ( singleResult ) { <EOL> try { <EOL> return results [ results . length - <NUM_LIT> ] ; <EOL> } catch ( error ) { <EOL> return { } ; <EOL> } <EOL> } <EOL> return results ; <EOL> } </s>
<s> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer , <EOL> getUnitAndNum <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UNIT_ENUM_STR , <EOL> NONNEGATIVE_NUMBER_REGEX_STR <EOL> } from '<STR_LIT>' ; <EOL> export const fontSize = ( ) = > [ <EOL> [ new RegExp ( ` ^ ( font - size | fs ) - ( ? < num > $ { NONNEGATIVE_NUMBER_REGEX_STR } ) ( ? < unit > $ { UNIT_ENUM_STR } ) ? $ ` ) , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> num , <EOL> unit <EOL> } = groups as { <EOL> num : string ; unit   ? : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` font - size :   $ { getUnitAndNum ( unit , num ) } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import { <EOL> VoyagerConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ReduxAction <EOL> } from '<STR_LIT>' ; <EOL> export type ConfigAction = SetConfig ; <EOL> export const SET_CONFIG = '<STR_LIT>' ; <EOL> export type SetConfig = ReduxAction < typeof SET_CONFIG , { <EOL> config : VoyagerConfig ; <EOL> } > ; </s>
<s> const DOT_PREFIX_RE = / ( . ) . + ? \ . / g ; <EOL> / ** <EOL> * Convert a dot . notated . string into a short <EOL> * version ( d . n . string ) <EOL> * / <EOL> export const shortenDottedString = ( input ) = > input . replace ( DOT_PREFIX_RE , '<STR_LIT>' ) ; </s>
<s> import { <EOL> Toolbar <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PanelLayout , <EOL> Widget <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * The header for a Callstack Panel . <EOL> * / <EOL> export class CallstackHeader extends Widget { <EOL> / ** <EOL> * Instantiate a new CallstackHeader . <EOL> * / <EOL> constructor ( ) { <EOL> super ( { <EOL> node : document . createElement ( '<STR_LIT>' ) <EOL> } ) ; <EOL> const title = new Widget ( { <EOL> node : document . createElement ( '<STR_LIT>' ) <EOL> } ) ; <EOL> title . node . textContent = '<STR_LIT>' ; <EOL> const layout = new PanelLayout ( ) ; <EOL> layout . addWidget ( title ) ; <EOL> layout . addWidget ( this . toolbar ) ; <EOL> this . layout = layout ; <EOL> } <EOL> / ** <EOL> * The toolbar for the callstack header . <EOL> * / <EOL> readonly toolbar = new Toolbar ( ) ; <EOL> } </s>
<s> import type { <EOL> VariantFunction <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PSEUDO_STR <EOL> } from '<STR_LIT>' ; <EOL> export function getVariantPseudo ( ) { <EOL> return ( matcher ) = > { <EOL> const [ , pseudo = '<STR_LIT>' ] = matcher . match ( new RegExp ( ` ( $ { PSEUDO_STR } ) : ` ) )   ? ? [ ] ; <EOL> if ( ! pseudo ) { <EOL> return { <EOL> matcher <EOL> } ; <EOL> } <EOL> return { <EOL> matcher : matcher . replace ( / ^ . + ? : ( . * ) $ / , '<STR_LIT>' ) , <EOL> selector : ( s ) = >   ` $ { s } : $ { pseudo } ` , <EOL> } ; <EOL> } ; <EOL> } </s>
<s> const id = Symbol ( '<STR_LIT>' ) ; <EOL> export class RangeKey { <EOL> [ id ] : string ; <EOL> gte : string | number ; <EOL> lt : string | number ; <EOL> constructor ( bucket ) { <EOL> this . gte = bucket . from == null   ? - Infinity : bucket . from ; <EOL> this . lt = bucket . to == null   ? + Infinity : bucket . to ; <EOL> this [ id ] = RangeKey . idBucket ( bucket ) ; <EOL> } <EOL> static idBucket ( bucket ) { <EOL> return   ` from : $ { bucket . from } , to : $ { bucket . to } ` ; <EOL> } <EOL> toString ( ) { <EOL> return this [ id ] ; <EOL> } <EOL> } </s>
<s> import { <EOL> SavedObjectsClientContract , <EOL> SavedObjectAttributes <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SavedQueryAttributes , <EOL> SavedQuery , <EOL> SavedQueryService <EOL> } from '<STR_LIT>' ; <EOL> type SerializedSavedQueryAttributes = SavedObjectAttributes & SavedQueryAttributes & { <EOL> query : { <EOL> query : string ; language : string ; <EOL> } ; <EOL> } ; <EOL> export const createSavedQueryService = ( savedObjectsClient ) : SavedQueryService = > { <EOL> const saveQuery = async ( attributes , { <EOL> overwrite = false <EOL> } = { } ) = > { <EOL> if ( ! attributes . title . length ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> const query = { <EOL> query : typeof attributes . query . query == = '<STR_LIT>'   ? attributes . query . query : JSON . stringify ( attributes . query . query ) , <EOL> language : attributes . query . language , <EOL> } ; <EOL> const queryObject = { <EOL> title : attributes . title . trim ( ) , <EOL> description : attributes . description , <EOL> query , <EOL> } ; <EOL> if ( attributes . filters ) { <EOL> queryObject . filters = attributes . filters ; <EOL> } <EOL> if ( attributes . timefilter ) { <EOL> queryObject . timefilter = attributes . timefilter ; <EOL> } <EOL> let rawQueryResponse ; <EOL> if ( ! overwrite ) { <EOL> rawQueryResponse = await savedObjectsClient . create ( '<STR_LIT>' , queryObject , { <EOL> id : attributes . title , <EOL> } ) ; <EOL> } else { <EOL> rawQueryResponse = await savedObjectsClient . create ( '<STR_LIT>' , queryObject , { <EOL> id : attributes . title , <EOL> overwrite : true , <EOL> } ) ; <EOL> } <EOL> if ( rawQueryResponse . error ) { <EOL> throw new Error ( rawQueryResponse . error . message ) ; <EOL> } <EOL> return parseSavedQueryObject ( rawQueryResponse ) ; <EOL> } ; <EOL> const getAllSavedQueries = async ( ) : Promise < SavedQuery [ ] > = > { <EOL> const count = await getSavedQueryCount ( ) ; <EOL> const response = await savedObjectsClient . find < SerializedSavedQueryAttributes > ( { <EOL> type : '<STR_LIT>' , <EOL> perPage : count , <EOL> page : <NUM_LIT> , <EOL> } ) ; <EOL> return response . savedObjects . map ( ( savedObject ) = > parseSavedQueryObject ( savedObject ) ) ; <EOL> } ; <EOL> const findSavedQueries = async ( searchText = '<STR_LIT>' , perPage = <NUM_LIT> , activePage = <NUM_LIT> ) : Promise < { <EOL> total : number ; queries : SavedQuery [ ] ; <EOL> } > = > { <EOL> const response = await savedObjectsClient . find < SerializedSavedQueryAttributes > ( { <EOL> type : '<STR_LIT>' , <EOL> search : searchText , <EOL> searchFields : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> sortField : '<STR_LIT>' , <EOL> perPage , <EOL> page : activePage , <EOL> } ) ; <EOL> return { <EOL> total : response . total , <EOL> queries : response . savedObjects . map ( ( savedObject ) = > parseSavedQueryObject ( savedObject ) ) , <EOL> } ; <EOL> } ; <EOL> const getSavedQuery = async ( id ) : Promise < SavedQuery > = > { <EOL> const savedObject = await savedObjectsClient . get < SerializedSavedQueryAttributes > ( '<STR_LIT>' , id ) ; <EOL> if ( savedObject . error ) { <EOL> throw new Error ( savedObject . error . message ) ; <EOL> } <EOL> return parseSavedQueryObject ( savedObject ) ; <EOL> } ; <EOL> const deleteSavedQuery = async ( id ) = > { <EOL> return await savedObjectsClient . delete ( '<STR_LIT>' , id ) ; <EOL> } ; <EOL> const parseSavedQueryObject = ( savedQuery ) = > { <EOL> let queryString ; <EOL> try { <EOL> queryString = JSON . parse ( savedQuery . attributes . query . query ) ; <EOL> } catch ( error ) { <EOL> queryString = savedQuery . attributes . query . query ; <EOL> } <EOL> const savedQueryItems = { <EOL> title : savedQuery . attributes . title | | '<STR_LIT>' , <EOL> description : savedQuery . attributes . description | | '<STR_LIT>' , <EOL> query : { <EOL> query : queryString , <EOL> language : savedQuery . attributes . query . language , <EOL> } , <EOL> } ; <EOL> if ( savedQuery . attributes . filters ) { <EOL> savedQueryItems . filters = savedQuery . attributes . filters ; <EOL> } <EOL> if ( savedQuery . attributes . timefilter ) { <EOL> savedQueryItems . timefilter = savedQuery . attributes . timefilter ; <EOL> } <EOL> return { <EOL> id : savedQuery . id , <EOL> attributes : savedQueryItems , <EOL> } ; <EOL> } ; <EOL> const getSavedQueryCount = async ( ) : Promise < number > = > { <EOL> const response = await savedObjectsClient . find < SerializedSavedQueryAttributes > ( { <EOL> type : '<STR_LIT>' , <EOL> perPage : <NUM_LIT> , <EOL> page : <NUM_LIT> , <EOL> } ) ; <EOL> return response . total ; <EOL> } ; <EOL> return { <EOL> saveQuery , <EOL> getAllSavedQueries , <EOL> findSavedQueries , <EOL> getSavedQuery , <EOL> deleteSavedQuery , <EOL> getSavedQueryCount , <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> IRegistry <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionRenderer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AnyExpressionRenderDefinition <EOL> } from '<STR_LIT>' ; <EOL> export class ExpressionRendererRegistry implements IRegistry < ExpressionRenderer > { <EOL> private readonly renderers : Map < string , <EOL> ExpressionRenderer > = new Map < string , <EOL> ExpressionRenderer > ( ) ; register ( definition ) { <EOL> if ( typeof definition == = '<STR_LIT>' ) definition = definition ( ) ; <EOL> const renderer = new ExpressionRenderer ( definition ) ; <EOL> this . renderers . set ( renderer . name , renderer ) ; <EOL> } <EOL> public get ( id ) { <EOL> return this . renderers . get ( id ) | | null ; <EOL> } <EOL> public toJS ( ) { <EOL> return this . toArray ( ) . reduce ( ( acc , renderer ) = > ( { <EOL> ... acc , <EOL> [ renderer . name ] : renderer , <EOL> } ) , { } <EOL> as Record < string , ExpressionRenderer > ) ; <EOL> } <EOL> public toArray ( ) { <EOL> return [ ... this . renderers . values ( ) ] ; <EOL> } <EOL> } </s>
<s> import { <EOL> IUiSettingsClient <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IStorageWrapper <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeHistory , <EOL> Timefilter , <EOL> TimeHistoryContract , <EOL> TimefilterContract <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> internal <EOL> export interface TimeFilterServiceDependencies { <EOL> uiSettings : IUiSettingsClient ; storage : IStorageWrapper ; <EOL> } <EOL> export class TimefilterService { <EOL> public setup ( { <EOL> uiSettings , <EOL> storage <EOL> } ) { <EOL> const timefilterConfig = { <EOL> timeDefaults : uiSettings . get ( UI_SETTINGS . TIMEPICKER_TIME_DEFAULTS ) , <EOL> refreshIntervalDefaults : uiSettings . get ( UI_SETTINGS . TIMEPICKER_REFRESH_INTERVAL_DEFAULTS ) , <EOL> } ; <EOL> const history = new TimeHistory ( storage ) ; <EOL> const timefilter = new Timefilter ( timefilterConfig , history ) ; <EOL> return { <EOL> timefilter , <EOL> history , <EOL> } ; <EOL> } <EOL> public start ( ) { } <EOL> public stop ( ) { } <EOL> } <EOL> public <EOL> export interface TimefilterSetup { <EOL> timefilter : TimefilterContract ; history : TimeHistoryContract ; <EOL> } </s>
<s> import { <EOL> pluck <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Layout <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Header <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Stream <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> header , <EOL> div , <EOL> hr , <EOL> main <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> style <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> rem <EOL> } from '<STR_LIT>' ; <EOL> const className = style ( { <EOL>         $ nest : { <EOL> '<STR_LIT>' : { <EOL> padding : rem ( <NUM_LIT> ) , <EOL> } , <EOL> '<STR_LIT>' : { <EOL> padding : rem ( <NUM_LIT> ) <EOL> } <EOL> } <EOL> } ) ; <EOL> const xs = Stream ; <EOL> export const HeaderLayout = ( { <EOL> dom , <EOL> history , <EOL> github , <EOL> component : { <EOL> dom : componentDom , <EOL> ... component <EOL> } <EOL> } ) = > { <EOL> const headerComponent = Header ( { <EOL> dom , <EOL> history <EOL> } ) ; <EOL> const vdom $ = xs . combine ( headerComponent . dom , componentDom | | xs . empty ( ) ) . map ( ( [ headerDom , component ] ) = > div ( ` . header . layout . $ { className } ` , [ header ( headerDom ) , hr ( ) , main ( component ) ] ) ) ; <EOL> return { <EOL> dom : vdom $ , <EOL> ... component <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> parseQueryString <EOL> } from '<STR_LIT>' ; <EOL> internal <EOL> export function getForceNow ( ) { <EOL> const forceNow = parseQueryString ( ) . forceNow as string ; <EOL> if ( ! forceNow ) { <EOL> return ; <EOL> } <EOL> const ticks = Date . parse ( forceNow ) ; <EOL> if ( isNaN ( ticks ) ) { <EOL> throw new Error ( ` forceNow query parameter ,   $ { forceNow } , can ' t be parsed by Date . parse ` ) ; <EOL> } <EOL> return new Date ( ticks ) ; <EOL> } </s>
<s> import dateMath from '<STR_LIT>' ; <EOL> import { <EOL> leastCommonMultiple <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parseOpenSearchInterval <EOL> } from '<STR_LIT>' ; <EOL> returns { <EOL> string <EOL> } <EOL> export function leastCommonInterval ( a , b ) { <EOL> const { <EOL> unitsMap , <EOL> unitsDesc <EOL> } = dateMath ; <EOL> const aInt = parseOpenSearchInterval ( a ) ; <EOL> const bInt = parseOpenSearchInterval ( b ) ; <EOL> if ( a == = b ) { <EOL> return a ; <EOL> } <EOL> const aUnit = unitsMap [ aInt . unit ] ; <EOL> const bUnit = unitsMap [ bInt . unit ] ; <EOL> if ( aInt . type != = bInt . type ) { <EOL> throw Error ( ` Incompatible intervals :   $ { a } ( $ { aInt . type } ) ,   $ { b } ( $ { bInt . type } ) ` ) ; <EOL> } <EOL> if ( aInt . type == = '<STR_LIT>' | | bInt . type == = '<STR_LIT>' ) { <EOL> return aUnit . weight > bUnit . weight   ?   ` $ { aInt . value } $ { aInt . unit } ` :   ` $ { bInt . value } $ { bInt . unit } ` ; <EOL> } <EOL> const aMs = aInt . value * aUnit . base ; <EOL> const bMs = bInt . value * bUnit . base ; <EOL> const lcmMs = leastCommonMultiple ( aMs , bMs ) ; <EOL> if ( lcmMs == = bMs ) { <EOL> return b . replace ( / \ s / g , '<STR_LIT>' ) ; <EOL> } <EOL> if ( lcmMs == = aMs ) { <EOL> return a . replace ( / \ s / g , '<STR_LIT>' ) ; <EOL> } <EOL> const lcmUnit = unitsDesc . find ( ( unit ) = > { <EOL> const unitInfo = unitsMap [ unit ] ; <EOL> return   ! ! ( unitInfo . type != = '<STR_LIT>' & & lcmMs % unitInfo . base == = <NUM_LIT> ) ; <EOL> } ) ; <EOL> if ( ! lcmUnit ) { <EOL> throw Error ( ` Unable to find common interval for :   $ { a } ,   $ { b } ` ) ; <EOL> } <EOL> return   ` $ { lcmMs / unitsMap [ lcmUnit ] . base } $ { lcmUnit } ` ; <EOL> } </s>
<s> import BitMatrix from '<STR_LIT>' ; <EOL> export enum DataMaskValues { <EOL> DATA_MASK_000 , <EOL> DATA_MASK_001 , <EOL> DATA_MASK_010 , <EOL> DATA_MASK_011 , <EOL> DATA_MASK_100 , <EOL> DATA_MASK_101 , <EOL> DATA_MASK_110 , <EOL> DATA_MASK_111 <EOL> } <EOL> author Sean Owen <EOL> export default class DataMask { <EOL> public constructor ( private value , private isMasked ) { } <EOL> public static values = new Map < DataMaskValues , DataMask > ( [ <EOL> [ DataMaskValues . DATA_MASK_000 , new DataMask ( DataMaskValues . DATA_MASK_000 , ( i , j ) = > { <EOL> return ( ( i + j ) & <NUM_LIT> ) == = <NUM_LIT> ; <EOL> } ) ] , <EOL> [ DataMaskValues . DATA_MASK_001 , new DataMask ( DataMaskValues . DATA_MASK_001 , ( i , j ) = > { <EOL> return ( i & <NUM_LIT> ) == = <NUM_LIT> ; <EOL> } ) ] , <EOL> [ DataMaskValues . DATA_MASK_010 , new DataMask ( DataMaskValues . DATA_MASK_010 , ( i , j ) = > { <EOL> return j % <NUM_LIT> == = <NUM_LIT> ; <EOL> } ) ] , <EOL> [ DataMaskValues . DATA_MASK_011 , new DataMask ( DataMaskValues . DATA_MASK_011 , ( i , j ) = > { <EOL> return ( i + j ) % <NUM_LIT> == = <NUM_LIT> ; <EOL> } ) ] , <EOL> [ DataMaskValues . DATA_MASK_100 , new DataMask ( DataMaskValues . DATA_MASK_100 , ( i , j ) = > { <EOL> return ( ( Math . floor ( i / <NUM_LIT> ) + Math . floor ( j / <NUM_LIT> ) ) & <NUM_LIT> ) == = <NUM_LIT> ; <EOL> } ) ] , <EOL> [ DataMaskValues . DATA_MASK_101 , new DataMask ( DataMaskValues . DATA_MASK_101 , ( i , j ) = > { <EOL> return ( i * j ) % <NUM_LIT> == = <NUM_LIT> ; <EOL> } ) ] , <EOL> [ DataMaskValues . DATA_MASK_110 , new DataMask ( DataMaskValues . DATA_MASK_110 , ( i , j ) = > { <EOL> return ( ( i * j ) % <NUM_LIT> ) < <NUM_LIT> ; <EOL> } ) ] , <EOL> [ DataMaskValues . DATA_MASK_111 , new DataMask ( DataMaskValues . DATA_MASK_111 , ( i , j ) = > { <EOL> return ( ( i + j + ( ( i * j ) % <NUM_LIT> ) ) & <NUM_LIT> ) == = <NUM_LIT> ; <EOL> } ) ] , <EOL> ] ) ; <EOL> param bits param dimension public unmaskBitMatrix ( bits , dimension ) { <EOL> for ( let i = <NUM_LIT> ; i < dimension ; i + + ) { <EOL> for ( let j = <NUM_LIT> ; j < dimension ; j + + ) { <EOL> if ( this . isMasked ( i , j ) ) { <EOL> bits . flip ( j , i ) ; <EOL> } <EOL> } <EOL> } <EOL> } <EOL> } </s>
<s> import '<STR_LIT>' ; <EOL> import React , { <EOL> useEffect , <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GiStrikingArrows <EOL> } from '<STR_LIT>' ; <EOL> export const ToggleSequenceFlowButton = ( { <EOL> onToggleSequenceFlow <EOL> } ) = > { <EOL> const [ showSequenceFlow , setShowSequenceFlow ] = useState ( false ) ; <EOL> useEffect ( ( ) = > { <EOL> onToggleSequenceFlow ( showSequenceFlow ) ; <EOL> } , [ showSequenceFlow ] ) ; <EOL> return ( < button className = "<STR_LIT>" title = {   ! showSequenceFlow   ? '<STR_LIT>' : '<STR_LIT>' } aria - label = {   ! showSequenceFlow   ? '<STR_LIT>' : '<STR_LIT>' } onClick = { ( ) = > setShowSequenceFlow (   ! showSequenceFlow ) } > < GiStrikingArrows style = { { opacity :   ! showSequenceFlow   ? '<STR_LIT>' : '<STR_LIT>' , fontSize : '<STR_LIT>' } } / > < / button > ) ; } ; </s>
<s> import { <EOL> EnUs <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ZhCn <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> I18n <EOL> } from '<STR_LIT>' ; <EOL> export const sentenceKey = { <EOL> auto : '<STR_LIT>' , <EOL> beta : '<STR_LIT>' , <EOL> betaDesc : '<STR_LIT>' , <EOL> browser : '<STR_LIT>' , <EOL> browserPathDescPrefix : '<STR_LIT>' , <EOL> cloud : '<STR_LIT>' , <EOL> cloudDesc : '<STR_LIT>' , <EOL> configFileAt : '<STR_LIT>' , <EOL> configPrefix : '<STR_LIT>' , <EOL> configSuffix : '<STR_LIT>' , <EOL> devTip : '<STR_LIT>' , <EOL> emptyTipsDesc : '<STR_LIT>' , <EOL> emptyTipsTitle : '<STR_LIT>' , <EOL> enableDesc : '<STR_LIT>' , <EOL> enableLabel : '<STR_LIT>' , <EOL> error : '<STR_LIT>' , <EOL> errorArgs : '<STR_LIT>' , <EOL> errorInfoToClipboard : '<STR_LIT>' , <EOL> evernoteUserId : '<STR_LIT>' , <EOL> evernoteUserIdDesc : '<STR_LIT>' , <EOL> evernoteUserIdPlaceholder : '<STR_LIT>' , <EOL> executorFileAt : '<STR_LIT>' , <EOL> executorPrefix : '<STR_LIT>' , <EOL> executorSuffix : '<STR_LIT>' , <EOL> file : '<STR_LIT>' , <EOL> fileOpening : '<STR_LIT>' , <EOL> filePathNonExistsTips : '<STR_LIT>' , <EOL> fileSelectorPlaceholder : '<STR_LIT>' , <EOL> filterNonExistsFiles : '<STR_LIT>' , <EOL> filterNonExistsFilesDesc : '<STR_LIT>' , <EOL> getFavicon : '<STR_LIT>' , <EOL> getFaviconDesc : '<STR_LIT>' , <EOL> getFileIcon : '<STR_LIT>' , <EOL> getFileIconDesc : '<STR_LIT>' , <EOL> getProjectsError : '<STR_LIT>' , <EOL> historyLimit : '<STR_LIT>' , <EOL> historyLimitDesc : '<STR_LIT>' , <EOL> inputDirectlyPlaceholder : '<STR_LIT>' , <EOL> inputPathDirectly : '<STR_LIT>' , <EOL> inputPathDirectlyDesc : '<STR_LIT>' , <EOL> languageSetting : '<STR_LIT>' , <EOL> languageSettingDesc : '<STR_LIT>' , <EOL> local : '<STR_LIT>' , <EOL> localDesc : '<STR_LIT>' , <EOL> nativeId : '<STR_LIT>' , <EOL> nativeIdDesc : '<STR_LIT>' , <EOL> needReboot : '<STR_LIT>' , <EOL> needRebootDesc : '<STR_LIT>' , <EOL> nonExistsFileOrDeleted : '<STR_LIT>' , <EOL> nonExistsPathOrCancel : '<STR_LIT>' , <EOL> notifyFileOpen : '<STR_LIT>' , <EOL> notifyFileOpenDesc : '<STR_LIT>' , <EOL> openInNew : '<STR_LIT>' , <EOL> openInNewDesc : '<STR_LIT>' , <EOL> pathNotFound : '<STR_LIT>' , <EOL> pinyinIndex : '<STR_LIT>' , <EOL> pinyinIndexDesc : '<STR_LIT>' , <EOL> placeholder : '<STR_LIT>' , <EOL> pluginSetting : '<STR_LIT>' , <EOL> ready : '<STR_LIT>' , <EOL> requestMoreApplication : '<STR_LIT>' , <EOL> safariBookmarkDesc : '<STR_LIT>' , <EOL> search : '<STR_LIT>' , <EOL> settingBetaDesc : '<STR_LIT>' , <EOL> settingDocument : '<STR_LIT>' , <EOL> smartTag : '<STR_LIT>' , <EOL> sourceCodeRepository : '<STR_LIT>' , <EOL> sqlite3 : '<STR_LIT>' , <EOL> sqlite3Desc : '<STR_LIT>' , <EOL> systemInformation : '<STR_LIT>' , <EOL> systemUser : '<STR_LIT>' , <EOL> systemVersion : '<STR_LIT>' , <EOL> tag : '<STR_LIT>' , <EOL> unknownError : '<STR_LIT>' , <EOL> unknownInputError : '<STR_LIT>' , <EOL> unready : '<STR_LIT>' , <EOL> unSupportTipsDesc : '<STR_LIT>' , <EOL> unSupportTipsTitle : '<STR_LIT>' , <EOL> utoolsVersion : '<STR_LIT>' , <EOL> } ; <EOL> export interface Sentence { <EOL> readonly auto : string ; <EOL> readonly beta : string ; <EOL> readonly betaDesc : string ; <EOL> readonly browser : string ; <EOL> readonly browserPathDescPrefix : string ; <EOL> readonly cloud : string ; <EOL> readonly cloudDesc : string ; <EOL> readonly configFileAt : string ; <EOL> readonly configPrefix : string ; <EOL> readonly configSuffix : string ; <EOL> readonly devTip : string ; <EOL> readonly emptyTipsDesc : string ; <EOL> readonly emptyTipsTitle : string ; <EOL> readonly enableDesc : string ; <EOL> readonly enableLabel : string ; <EOL> readonly error : string ; <EOL> readonly errorArgs : string ; <EOL> readonly errorInfoToClipboard : string ; <EOL> readonly evernoteUserId : string ; <EOL> readonly evernoteUserIdDesc : string ; <EOL> readonly executorFileAt : string ; <EOL> readonly executorPrefix : string ; <EOL> readonly executorSuffix : string ; <EOL> readonly file : string ; <EOL> readonly fileOpening : string ; <EOL> readonly filePathNonExistsTips : string ; <EOL> readonly fileSelectorPlaceholder : string ; <EOL> readonly filterNonExistsFiles : string ; <EOL> readonly filterNonExistsFilesDesc : string ; <EOL> readonly getFavicon : string ; <EOL> readonly getFaviconDesc : string ; <EOL> readonly getFileIcon : string ; <EOL> readonly getFileIconDesc : string ; <EOL> readonly getProjectsError : string ; <EOL> readonly historyLimit : string ; <EOL> readonly historyLimitDesc : string ; <EOL> readonly inputDirectlyPlaceholder : string ; <EOL> readonly inputPathDirectly : string ; <EOL> readonly inputPathDirectlyDesc : string ; <EOL> readonly languageSetting : string ; <EOL> readonly languageSettingDesc : string ; <EOL> readonly local : string ; <EOL> readonly localDesc : string ; <EOL> readonly nativeId : string ; <EOL> readonly nativeIdDesc : string ; <EOL> readonly needReboot : string ; <EOL> readonly needRebootDesc : string ; <EOL> readonly nonExistsFileOrDeleted : string ; <EOL> readonly nonExistsPathOrCancel : string ; <EOL> readonly notifyFileOpen : string ; <EOL> readonly notifyFileOpenDesc : string ; <EOL> readonly openInNew : string ; <EOL> readonly openInNewDesc : string ; <EOL> readonly pathNotFound : string ; <EOL> readonly pinyinIndex : string ; <EOL> readonly pinyinIndexDesc : string ; <EOL> readonly placeholder : string ; <EOL> readonly pluginSetting : string ; <EOL> readonly ready : string ; <EOL> readonly requestMoreApplication : string ; <EOL> readonly safariBookmarkDesc : string ; <EOL> readonly search : string ; <EOL> readonly settingBetaDesc : string ; <EOL> readonly settingDocument : string ; <EOL> readonly smartTag : string ; <EOL> readonly sourceCodeRepository : string ; <EOL> readonly sqlite3 : string ; <EOL> readonly sqlite3Desc : string ; <EOL> readonly systemInformation : string ; <EOL> readonly systemUser : string ; <EOL> readonly systemVersion : string ; <EOL> readonly tag : string ; <EOL> readonly unknownError : string ; <EOL> readonly unknownInputError : string ; <EOL> readonly unready : string ; <EOL> readonly unSupportTipsDesc : string ; <EOL> readonly unSupportTipsTitle : string ; <EOL> readonly utoolsVersion : string ; <EOL> } <EOL> let languageData = new I18n ( '<STR_LIT>' , { <EOL> '<STR_LIT>' : { <EOL> ... ( new ZhCn ( ) ) <EOL> } , <EOL> '<STR_LIT>' : { <EOL> ... ( new EnUs ( ) ) <EOL> } , <EOL> } ) ; <EOL> languageData . locale ( navigator . language ) ; <EOL> export const i18n = languageData ; </s>
<s> import { <EOL> CommanderStatic <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AbstractAction <EOL> } from '<STR_LIT>' ; <EOL> export abstract class AbstractCommand { <EOL> constructor ( protected action ) { } <EOL> public abstract load ( program ) ; <EOL> } </s>
<s> import { <EOL> Component , <EOL> EventEmitter , <EOL> Input , <EOL> OnChanges , <EOL> Output , <EOL> SimpleChanges , <EOL> ViewEncapsulation <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> IMyOptions <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> UtilService <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> OPTS , <EOL> SPACE_STR , <EOL> EMPTY_STR <EOL> } from "<STR_LIT>" ; <EOL> @ Component ( { <EOL> selector : "<STR_LIT>" , <EOL> templateUrl : "<STR_LIT>" , <EOL> providers : [ UtilService ] , <EOL> encapsulation : ViewEncapsulation . None <EOL> } ) export class FooterBarComponent implements OnChanges { <EOL> @ Input ( ) opts : IMyOptions ; <EOL> @ Output ( ) footerBarTxtClicked : EventEmitter < void > = new EventEmitter < void > ( ) ; <EOL> footerBarTxt : string = EMPTY_STR ; <EOL> constructor ( private utilService ) { } <EOL> ngOnChanges ( changes ) { <EOL> if ( changes . hasOwnProperty ( OPTS ) ) { <EOL> this . opts = changes [ OPTS ] . currentValue ; <EOL> const { <EOL> dateFormat , <EOL> monthLabels , <EOL> todayTxt <EOL> } = this . opts ; <EOL> const today = this . utilService . getToday ( ) ; <EOL> this . footerBarTxt = todayTxt + ( todayTxt . length > <NUM_LIT>   ? SPACE_STR : EMPTY_STR ) + this . utilService . formatDate ( today , dateFormat , monthLabels ) ; <EOL> } <EOL> } <EOL> onFooterBarTxtClicked ( ) { <EOL> this . footerBarTxtClicked . emit ( ) ; <EOL> } <EOL> } </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> nodeTypes <EOL> } from '<STR_LIT>' ; <EOL> import * as ast from '<STR_LIT>' ; <EOL> import { <EOL> getRangeScript , <EOL> RangeFilterParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getFields <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getTimeZoneFromSettings <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getFullFieldNameNode <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> KueryNode , <EOL> IFieldType <EOL> } from '<STR_LIT>' ; <EOL> export function buildNodeParams ( fieldName , params ) { <EOL> const paramsToMap = _ . pick ( params , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> const fieldNameArg = typeof fieldName == = '<STR_LIT>'   ? ast . fromLiteralExpression ( fieldName ) : nodeTypes . literal . buildNode ( fieldName ) ; <EOL> const args = _ . map ( paramsToMap , ( value , key ) = > { <EOL> return nodeTypes . namedArg . buildNode ( key , value ) ; <EOL> } ) ; <EOL> return { <EOL> arguments : [ fieldNameArg , ... args ] , <EOL> } ; <EOL> } <EOL> export function toOpenSearchQuery ( node , indexPattern   ? , config = { } , context = { } ) { <EOL> const [ fieldNameArg , ... args ] = node . arguments ; <EOL> const fullFieldNameArg = getFullFieldNameNode ( fieldNameArg , indexPattern , context ? . nested   ? context . nested . path : undefined ) ; <EOL> const fields = indexPattern   ? getFields ( fullFieldNameArg , indexPattern ) : [ ] ; <EOL> const namedArgs = extractArguments ( args ) ; <EOL> const queryParams = _ . mapValues ( namedArgs , ( arg ) = > { <EOL> return ast . toOpenSearchQuery ( arg ) ; <EOL> } ) ; <EOL> if ( fields & & fields . length == = <NUM_LIT> ) { <EOL> fields . push ( { <EOL> name : ( ast . toOpenSearchQuery ( fullFieldNameArg ) as unknown ) as string , <EOL> scripted : false , <EOL> type : '<STR_LIT>' , <EOL> } ) ; <EOL> } <EOL> const queries = fields ! . map ( ( field ) = > { <EOL> const wrapWithNestedQuery = ( query ) = > { <EOL> if ( ! ( fullFieldNameArg . type == = '<STR_LIT>' ) | |   ! _ . get ( field , '<STR_LIT>' ) | | context ! . nested ) { <EOL> return query ; <EOL> } else { <EOL> return { <EOL> nested : { <EOL> path : field . subType ! . nested ! . path , <EOL> query , <EOL> score_mode : '<STR_LIT>' , <EOL> } , <EOL> } ; <EOL> } <EOL> } ; <EOL> if ( field . scripted ) { <EOL> return { <EOL> script : getRangeScript ( field , queryParams ) , <EOL> } ; <EOL> } else if ( field . type == = '<STR_LIT>' ) { <EOL> const timeZoneParam = config . dateFormatTZ   ? { <EOL> time_zone : getTimeZoneFromSettings ( config ! . dateFormatTZ ) <EOL> } : { } ; <EOL> return wrapWithNestedQuery ( { <EOL> range : { <EOL> [ field . name ] : { <EOL> ... queryParams , <EOL> ... timeZoneParam , <EOL> } , <EOL> } , <EOL> } ) ; <EOL> } <EOL> return wrapWithNestedQuery ( { <EOL> range : { <EOL> [ field . name ] : queryParams , <EOL> } , <EOL> } ) ; <EOL> } ) ; <EOL> return { <EOL> bool : { <EOL> should : queries , <EOL> minimum_should_match : <NUM_LIT> , <EOL> } , <EOL> } ; <EOL> } <EOL> function extractArguments ( args ) { <EOL> if ( ( args . gt & & args . gte ) | | ( args . lt & & args . lte ) ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> const unnamedArgOrder = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> return args . reduce ( ( acc , arg , index ) = > { <EOL> if ( arg . type == = '<STR_LIT>' ) { <EOL> acc [ arg . name ] = arg . value ; <EOL> } else { <EOL> acc [ unnamedArgOrder [ index ] ] = arg ; <EOL> } <EOL> return acc ; <EOL> } , { } ) ; <EOL> } </s>
<s> import { <EOL> clearAllReducers , <EOL> Definitions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> makeStoreAndDefineState <EOL> } from '<STR_LIT>' ; <EOL> const { <EOL> FormField <EOL> } = Definitions . labs ; <EOL> const formField = FormField ( { <EOL> initialState : { <EOL> value : '<STR_LIT>' <EOL> } , <EOL> validators : [ <EOL> [ ( val ) = > typeof val == = '<STR_LIT>' , '<STR_LIT>' ] , <EOL> [ ( val ) = > val . length > <NUM_LIT> , '<STR_LIT>' ] , <EOL> ] , <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> beforeEach ( ( ) = > { <EOL> clearAllReducers ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> models , <EOL> store <EOL> } = makeStoreAndDefineState ( { <EOL> space : { <EOL> field : formField <EOL> } <EOL> } ) ; <EOL> const { <EOL> actions , <EOL> selectors <EOL> } = models . space ; <EOL> const state = { <EOL> error : null , <EOL> isDirty : false , <EOL> isValid : false , <EOL> value : '<STR_LIT>' , <EOL> } ; <EOL> expect ( selectors . field . get ( store . getState ( ) ) ) . toEqual ( state ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> models , <EOL> store <EOL> } = makeStoreAndDefineState ( { <EOL> space : { <EOL> field : formField <EOL> } <EOL> } ) ; <EOL> const { <EOL> actions , <EOL> selectors <EOL> } = models . space ; <EOL> store . dispatch ( actions . field . set ( '<STR_LIT>' ) ) ; <EOL> expect ( selectors . field . value ( store . getState ( ) ) ) . toEqual ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> Pipe , <EOL> PipeTransform <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimeUnit <EOL> } from '<STR_LIT>' ; <EOL> @ Pipe ( { <EOL> name : '<STR_LIT>' <EOL> } ) export class TimeAgoPipe implements PipeTransform { <EOL> transform ( value ) { <EOL> const timeValues = [ { <EOL> hrsInThatPeriod : + TimeUnit . Year , <EOL> name : '<STR_LIT>' <EOL> } , { <EOL> hrsInThatPeriod : + TimeUnit . Month , <EOL> name : '<STR_LIT>' <EOL> } , { <EOL> hrsInThatPeriod : + TimeUnit . Week , <EOL> name : '<STR_LIT>' <EOL> } , { <EOL> hrsInThatPeriod : + TimeUnit . Day , <EOL> name : '<STR_LIT>' <EOL> } , { <EOL> hrsInThatPeriod : + TimeUnit . Hour , <EOL> name : '<STR_LIT>' <EOL> } ] ; <EOL> let timeLabel , incr = <NUM_LIT> ; <EOL> while ( ! timeLabel ) { <EOL> if ( ! timeValues [ incr ] ) break ; <EOL> const numOfGivenTimePeriodUnitsInGivenHoursValue = Math . floor ( value / timeValues [ incr ] . hrsInThatPeriod ) ; <EOL> if ( numOfGivenTimePeriodUnitsInGivenHoursValue > <NUM_LIT> ) { <EOL> timeLabel =   ` $ { numOfGivenTimePeriodUnitsInGivenHoursValue }   $ { timeValues [ incr ] . name } s ` ; <EOL> break ; <EOL> } <EOL> if ( numOfGivenTimePeriodUnitsInGivenHoursValue > <NUM_LIT> ) timeLabel =   ` $ { numOfGivenTimePeriodUnitsInGivenHoursValue }   $ { timeValues [ incr ] . name } ` ; <EOL> incr + + ; <EOL> } <EOL> return timeLabel | |   ` less than an hour ` ; <EOL> } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldFormat <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TextContextTypeConvert , <EOL> FIELD_FORMAT_IDS <EOL> } from '<STR_LIT>' ; <EOL> function convertLookupEntriesToMap ( lookupEntries ) { <EOL> return lookupEntries . reduce ( ( lookupMap , lookupEntry ) = > { <EOL> lookupMap [ lookupEntry . key ] = lookupEntry . value ; <EOL> return lookupMap ; <EOL> } , { } ) ; <EOL> } <EOL> export class StaticLookupFormat extends FieldFormat { <EOL> static id = FIELD_FORMAT_IDS . STATIC_LOOKUP ; <EOL> static title = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> static fieldType = [ OSD_FIELD_TYPES . STRING , OSD_FIELD_TYPES . NUMBER , OSD_FIELD_TYPES . IP , OSD_FIELD_TYPES . BOOLEAN , ] ; <EOL> getParamDefaults ( ) { <EOL> return { <EOL> lookupEntries : [ { } ] , <EOL> unknownKeyValue : null , <EOL> } ; <EOL> } <EOL> textConvert : TextContextTypeConvert = ( val ) = > { <EOL> const lookupEntries = this . param ( '<STR_LIT>' ) ; <EOL> const unknownKeyValue = this . param ( '<STR_LIT>' ) ; <EOL> const lookupMap = convertLookupEntriesToMap ( lookupEntries ) ; <EOL> return lookupMap [ val ] | | unknownKeyValue | | val ; <EOL> } ; <EOL> } </s>
<s> import Nano , { <EOL> Component , <EOL> Fragment <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n , <EOL> sentenceKey <EOL> } from '<STR_LIT>' ; <EOL> export class CloudSyncChip extends Component { <EOL> override render ( ) { <EOL> return ( < Fragment > < span class = "<STR_LIT>" data - tooltip = { i18n . t ( sentenceKey . cloudDesc ) } > < span class = "<STR_LIT>" > { i18n . t ( sentenceKey . cloud ) } < / span > < / span > < / Fragment > ) ; } } export class NativeChip extends Component { override render ( ) { return ( < Fragment > < span class = "<STR_LIT>" data - tooltip = { i18n . t ( sentenceKey . localDesc ) } > < span class = "<STR_LIT>" > { i18n . t ( sentenceKey . local ) } < / span > < / span > < / Fragment > ) ; } } export class RebootNeededChip extends Component { override render ( ) { return ( < Fragment > < span class = "<STR_LIT>" data - tooltip = { i18n . t ( sentenceKey . needRebootDesc ) } > < span class = "<STR_LIT>" > { i18n . t ( sentenceKey . needReboot ) } < / span > < / span > < / Fragment > ) ; } } export class TestChip extends Component { override render ( ) { return ( < Fragment > < span class = "<STR_LIT>" data - tooltip = { i18n . t ( sentenceKey . settingBetaDesc ) } > < span class = "<STR_LIT>" > { i18n . t ( sentenceKey . beta ) } < / span > < / span > < / Fragment > ) ; } } </s>
<s> export const DEFAULT_COLUMNS_SETTING = '<STR_LIT>' ; <EOL> export const SAMPLE_SIZE_SETTING = '<STR_LIT>' ; <EOL> export const AGGS_TERMS_SIZE_SETTING = '<STR_LIT>' ; <EOL> export const SORT_DEFAULT_ORDER_SETTING = '<STR_LIT>' ; <EOL> export const SEARCH_ON_PAGE_LOAD_SETTING = '<STR_LIT>' ; <EOL> export const DOC_HIDE_TIME_COLUMN_SETTING = '<STR_LIT>' ; <EOL> export const FIELDS_LIMIT_SETTING = '<STR_LIT>' ; <EOL> export const CONTEXT_DEFAULT_SIZE_SETTING = '<STR_LIT>' ; <EOL> export const CONTEXT_STEP_SETTING = '<STR_LIT>' ; <EOL> export const CONTEXT_TIE_BREAKER_FIELDS_SETTING = '<STR_LIT>' ; <EOL> export const MODIFY_COLUMNS_ON_SWITCH = '<STR_LIT>' ; </s>
<s> import { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> latLng , <EOL> MapOptions , <EOL> tileLayer <EOL> } from '<STR_LIT>' ; <EOL> interface MapSpec { <EOL> options : MapOptions ; <EOL> } <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' <EOL> } ) export class LeafletMultiMapDemoComponent { <EOL> optionsSpec : any = { <EOL> layers : [ { <EOL> url : '<STR_LIT>' , <EOL> attribution : '<STR_LIT>' <EOL> } ] , <EOL> zoom : <NUM_LIT> , <EOL> center : [ <NUM_LIT> , - <NUM_LIT> ] <EOL> } ; maps : MapSpec [ ] = [ ] ; doAddMap ( ) { <EOL> this . maps . push ( this . createMapSpec ( this . optionsSpec ) ) ; <EOL> } <EOL> doRemoveMap ( ) { <EOL> this . maps . pop ( ) ; <EOL> } <EOL> private createMapSpec ( optionsSpec ) { <EOL> return { <EOL> options : { <EOL> layers : [ tileLayer ( optionsSpec . layers [ <NUM_LIT> ] . url , { <EOL> attribution : optionsSpec . layers [ <NUM_LIT> ] . attribution <EOL> } ) ] , <EOL> zoom : optionsSpec . zoom , <EOL> center : latLng ( optionsSpec . center ) <EOL> } <EOL> } ; <EOL> } <EOL> } </s>
<s> import * as inquirer from '<STR_LIT>' ; <EOL> import { <EOL> Answers , <EOL> Question <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getValueOrDefault <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Configuration , <EOL> ProjectConfiguration <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> generateSelect <EOL> } from '<STR_LIT>' ; <EOL> export function shouldAskForProject ( schematic , configurationProjects , appName ) { <EOL> return ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( schematic ) == = false & & configurationProjects & & Object . entries ( configurationProjects ) . length != = <NUM_LIT> & &   ! appName ) ; <EOL> } <EOL> export function shouldGenerateSpec ( configuration , schematic , appName , specValue , specPassedAsInput   ? ) { <EOL> if ( specPassedAsInput == = true | | specPassedAsInput == = undefined ) { <EOL> return specValue ; <EOL> } <EOL> let specConfiguration = getValueOrDefault ( configuration , '<STR_LIT>' , appName | | '<STR_LIT>' ) ; <EOL> if ( typeof specConfiguration == = '<STR_LIT>' ) { <EOL> return specConfiguration ; <EOL> } <EOL> if ( typeof specConfiguration == = '<STR_LIT>' & & specConfiguration [ schematic ] != = undefined ) { <EOL> return specConfiguration [ schematic ] ; <EOL> } <EOL> if ( typeof specConfiguration == = '<STR_LIT>' & & appName ) { <EOL> specConfiguration = getValueOrDefault ( configuration , '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> if ( typeof specConfiguration == = '<STR_LIT>' ) { <EOL> return specConfiguration ; <EOL> } <EOL> if ( typeof specConfiguration == = '<STR_LIT>' & & specConfiguration [ schematic ] != = undefined ) { <EOL> return specConfiguration [ schematic ] ; <EOL> } <EOL> } <EOL> return specValue ; <EOL> } <EOL> export async function askForProjectName ( promptQuestion , projects ) { <EOL> const questions = [ generateSelect ( '<STR_LIT>' ) ( promptQuestion ) ( projects ) , ] ; <EOL> const prompt = inquirer . createPromptModule ( ) ; <EOL> return prompt ( questions ) ; <EOL> } <EOL> export function moveDefaultProjectToStart ( configuration , defaultProjectName , defaultLabel ) { <EOL> let projects = configuration . projects != null   ? Object . keys ( configuration . projects ) : [ ] ; <EOL> if ( configuration . sourceRoot != = '<STR_LIT>' ) { <EOL> projects = projects . filter ( ( p ) = > p != = defaultProjectName . replace ( defaultLabel , '<STR_LIT>' ) ) ; <EOL> } <EOL> projects . unshift ( defaultProjectName ) ; <EOL> return projects ; <EOL> } </s>
<s> import { <EOL> h <EOL> } from "<STR_LIT>" ; <EOL> import "<STR_LIT>" ; <EOL> import { <EOL> State , <EOL> Actions , <EOL> Run <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> RunsPaneItem <EOL> } from "<STR_LIT>" ; <EOL> export interface RunsPaneProps { <EOL> state : State ; actions : Actions ; runs : Run [ ] ; <EOL> } <EOL> export function RunsPane ( props ) { <EOL> const { <EOL> state , <EOL> actions , <EOL> runs <EOL> } = props ; <EOL> const items = [ ] ; <EOL> const lastId = runs . length - <NUM_LIT> ; <EOL> runs . forEach ( ( run , i ) = > { <EOL> items . unshift ( RunsPaneItem ( { <EOL> state , <EOL> actions , <EOL> run , <EOL> current : i == = lastId <EOL> } ) ) ; <EOL> } ) ; <EOL> return ( < div class = "<STR_LIT>" > < ul class = "<STR_LIT>" > { items } < / ul > < / div > ) ; } </s>
<s> import { <EOL> UrlForwardingPlugin <EOL> } from '<STR_LIT>' ; <EOL> export const plugin = ( ) = > new UrlForwardingPlugin ( ) ; <EOL> export * from '<STR_LIT>' ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> Linking , <EOL> StyleSheet , <EOL> TouchableOpacity <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> storiesOf <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FadeInImage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> files , <EOL> text <EOL> } from '<STR_LIT>' ; <EOL> const styles = StyleSheet . create ( { <EOL> imageStyle : { <EOL> width : <NUM_LIT> , <EOL> height : <NUM_LIT> , <EOL> marginTop : <NUM_LIT> <EOL> } , <EOL> imageContainer : { <EOL> alignItems : '<STR_LIT>' <EOL> } <EOL> } ) ; <EOL> const deepLink = ( deepLinkText ) = > ( ) = > { <EOL> Linking . openURL ( deepLinkText ) ; <EOL> } ; <EOL> storiesOf ( '<STR_LIT>' , module ) . add ( '<STR_LIT>' , ( ) = > { <EOL> const deepLinkText = text ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> const label = '<STR_LIT>' ; <EOL> const accept = '<STR_LIT>' ; <EOL> const defaultValue = [ '<STR_LIT>' ] ; <EOL> const value = files ( label , accept , defaultValue ) ; <EOL> return ( < TouchableOpacity onPress = { deepLink ( deepLinkText ) } style = { styles . imageContainer } > < FadeInImage source = { { uri : value [ <NUM_LIT> ] } } resizeMode = '<STR_LIT>' resizeMethod = '<STR_LIT>' style = { styles . imageStyle } / > < / TouchableOpacity > ) ; } ) ; </s>
<s> import { <EOL> TableHeader <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getServices <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SORT_DEFAULT_ORDER_SETTING , <EOL> DOC_HIDE_TIME_COLUMN_SETTING <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> export function createTableHeaderDirective ( reactDirective ) { <EOL> const { <EOL> uiSettings : config <EOL> } = getServices ( ) ; <EOL> return reactDirective ( TableHeader , [ <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> [ '<STR_LIT>' , { <EOL> watchDepth : '<STR_LIT>' <EOL> } ] , <EOL> ] , { <EOL> restrict : '<STR_LIT>' <EOL> } , { <EOL> hideTimeColumn : config . get ( DOC_HIDE_TIME_COLUMN_SETTING , false ) , <EOL> isShortDots : config . get ( UI_SETTINGS . SHORT_DOTS_ENABLE ) , <EOL> defaultSortOrder : config . get ( SORT_DEFAULT_ORDER_SETTING , '<STR_LIT>' ) , <EOL> } ) ; <EOL> } </s>
<s> import { <EOL> CoreSetup , <EOL> PluginInitializerContext <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> QuerySuggestionGetFn <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getEmptyValueSuggestions , <EOL> setupValueSuggestionProvider , <EOL> ValueSuggestionsGetFn , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConfigSchema <EOL> } from '<STR_LIT>' ; <EOL> export class AutocompleteService { <EOL> autocompleteConfig : ConfigSchema [ '<STR_LIT>' ] ; constructor ( initializerContext ) { <EOL> const { <EOL> autocomplete <EOL> } = initializerContext . config . get < ConfigSchema > ( ) ; <EOL> this . autocompleteConfig = autocomplete ; <EOL> } <EOL> private readonly querySuggestionProviders : Map < string , <EOL> QuerySuggestionGetFn > = new Map ( ) ; private getValueSuggestions   ? : ValueSuggestionsGetFn ; private addQuerySuggestionProvider = ( language , provider ) : void = > { <EOL> if ( language & & provider & & this . autocompleteConfig . querySuggestions . enabled ) { <EOL> this . querySuggestionProviders . set ( language , provider ) ; <EOL> } <EOL> } ; private getQuerySuggestions : QuerySuggestionGetFn = ( args ) = > { <EOL> const { <EOL> language <EOL> } = args ; <EOL> const provider = this . querySuggestionProviders . get ( language ) ; <EOL> if ( provider ) { <EOL> return provider ( args ) ; <EOL> } <EOL> } ; private hasQuerySuggestions = ( language ) = > this . querySuggestionProviders . has ( language ) ; public public setup ( core ) { <EOL> this . getValueSuggestions = this . autocompleteConfig . valueSuggestions . enabled   ? setupValueSuggestionProvider ( core ) : getEmptyValueSuggestions ; <EOL> return { <EOL> addQuerySuggestionProvider : this . addQuerySuggestionProvider , <EOL> obsolete / ** please use "<STR_LIT>" only from the start contract ** / getQuerySuggestions : this . getQuerySuggestions , <EOL> } ; <EOL> } <EOL> public public start ( ) { <EOL> return { <EOL> getQuerySuggestions : this . getQuerySuggestions , <EOL> hasQuerySuggestions : this . hasQuerySuggestions , <EOL> getValueSuggestions : this . getValueSuggestions ! , <EOL> } ; <EOL> } <EOL> internal public clearProviders ( ) { <EOL> this . querySuggestionProviders . clear ( ) ; <EOL> } <EOL> } <EOL> public <EOL> export type AutocompleteSetup = ReturnType < AutocompleteService [ '<STR_LIT>' ] > ; <EOL> public <EOL> export type AutocompleteStart = ReturnType < AutocompleteService [ '<STR_LIT>' ] > ; </s>
<s> import { <EOL> FieldSchema , <EOL> Schema , <EOL> TableSchema <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> StateWithHistory <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Bookmark , <EOL> DEFAULT_BOOKMARK <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DEFAULT_VOYAGER_CONFIG , <EOL> VoyagerConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomWildcardField , <EOL> DEFAULT_CUSTOM_WILDCARD_FIELDS <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Dataset , <EOL> DatasetWithoutSchema , <EOL> DEFAULT_DATASET <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DEFAULT_LOG , <EOL> Log <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DEFAULT_RELATED_VIEWS , <EOL> RelatedViews <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DEFAULT_SHELF_PREVIEW , <EOL> ShelfPreview <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DEFAULT_TAB , <EOL> Tab <EOL> } from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> / ** <EOL> * Application state . <EOL> * / <EOL> export interface PersistentState { <EOL> bookmark : Bookmark ; config : VoyagerConfig ; log : Log ; relatedViews : RelatedViews ; shelfPreview : ShelfPreview ; <EOL> } <EOL> export interface UndoableStateBaseWithoutDataset { <EOL> customWildcardFields : CustomWildcardField [ ] ; tab : Tab ; <EOL> } <EOL> export interface UndoableStateBase extends UndoableStateBaseWithoutDataset { <EOL> dataset : Dataset ; <EOL> } <EOL> / ** <EOL> * Application state ( wrapped with redux - undo ' s StateWithHistory interface ) . <EOL> * / <EOL> export interface GenericState < U extends UndoableStateBase > { <EOL> persistent : PersistentState ; undoable : StateWithHistory < U > ; <EOL> } ; <EOL> export type State = GenericState < UndoableStateBase > ; <EOL> export const DEFAULT_UNDOABLE_STATE_BASE = { <EOL> customWildcardFields : DEFAULT_CUSTOM_WILDCARD_FIELDS , <EOL> dataset : DEFAULT_DATASET , <EOL> tab : DEFAULT_TAB , <EOL> } ; <EOL> export const DEFAULT_UNDOABLE_STATE = { <EOL> past : [ ] , <EOL> present : DEFAULT_UNDOABLE_STATE_BASE , <EOL> future : [ ] , <EOL> _latestUnfiltered : null , <EOL> group : null , <EOL> index : null , <EOL> limit : <NUM_LIT> <EOL> } ; <EOL> export const DEFAULT_PERSISTENT_STATE = { <EOL> bookmark : DEFAULT_BOOKMARK , <EOL> config : DEFAULT_VOYAGER_CONFIG , <EOL> log : DEFAULT_LOG , <EOL> relatedViews : DEFAULT_RELATED_VIEWS , <EOL> shelfPreview : DEFAULT_SHELF_PREVIEW <EOL> } ; <EOL> export const DEFAULT_STATE = { <EOL> persistent : DEFAULT_PERSISTENT_STATE , <EOL> undoable : DEFAULT_UNDOABLE_STATE <EOL> } ; <EOL> export interface SerializableState extends PersistentState , UndoableStateBaseWithoutDataset { <EOL> dataset : DatasetWithoutSchema ; tableschema : TableSchema < FieldSchema > ; <EOL> } <EOL> export function toSerializable ( state ) { <EOL> const { <EOL> dataset , <EOL> ... undoableStateBaseWithoutDataset <EOL> } = state . undoable . present ; <EOL> const { <EOL> schema , <EOL> ... datasetWithoutSchema <EOL> } = dataset ; <EOL> return { <EOL> ... state . persistent , <EOL> ... undoableStateBaseWithoutDataset , <EOL> dataset : datasetWithoutSchema , <EOL> tableschema : schema . tableSchema ( ) , <EOL> } ; <EOL> } <EOL> export function fromSerializable ( serializable ) { <EOL> const { <EOL> dataset : datasetWithoutSchema , <EOL> tableschema , <EOL> bookmark , <EOL> config , <EOL> log , <EOL> relatedViews , <EOL> shelfPreview , <EOL> ... undoableStateBaseWithoutDataset <EOL> } = serializable ; <EOL> const persistent = { <EOL> bookmark , <EOL> config , <EOL> relatedViews , <EOL> shelfPreview , <EOL> log <EOL> } ; <EOL> const undoableBase = { <EOL> ... undoableStateBaseWithoutDataset , <EOL> dataset : { <EOL> ... datasetWithoutSchema , <EOL> schema : new Schema ( serializable . tableschema ) <EOL> } <EOL> } ; <EOL> return { <EOL> persistent , <EOL> undoable : { <EOL> ... DEFAULT_UNDOABLE_STATE , <EOL> present : undoableBase <EOL> } <EOL> } ; <EOL> } </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import StarRatings from '<STR_LIT>' ; <EOL> import Heading from '<STR_LIT>' ; <EOL> import api from '<STR_LIT>' ; <EOL> function useApi ( api ) { <EOL> const [ results , setResults ] = React . useState ( null ) ; <EOL> React . useEffect ( ( ) = > { <EOL> let isCurrent = true ; <EOL> api ( ) . then ( ( results ) = > { <EOL> if ( ! isCurrent ) return ; <EOL> setResults ( results ) ; <EOL> } ) ; <EOL> return ( ) = > ( isCurrent = false ) ; <EOL> } , [ api ] ) ; <EOL> return results ; <EOL> } <EOL> function ProductProfile ( { <EOL> productId <EOL> } ) { <EOL> const product = useApi ( React . useCallback ( ( ) = > api . products . getProduct ( productId ) , [ productId ] ) ) ; <EOL> if ( ! product ) return < div > Loading ... < / div > ; return ( < div className = "<STR_LIT>" > < Heading > { product . name } < / Heading > < StarRatings rating = { product . rating } / > < / div > ) ; } export default function App ( ) { return ( < div className = "<STR_LIT>" > < ProductProfile productId = { <NUM_LIT> } / > < / div > ) ; } </s>
<s> import { <EOL> Observable , <EOL> Subscription <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map , <EOL> tap <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimefilterSetup <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FilterManager <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> QueryState , <EOL> QueryStateChange <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createStateContainer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isFilterPinned , <EOL> compareFilters , <EOL> COMPARE_ALL_OPTIONS <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> QueryStringContract <EOL> } from '<STR_LIT>' ; <EOL> export function createQueryStateObservable ( { <EOL> timefilter : { <EOL> timefilter <EOL> } , <EOL> filterManager , <EOL> queryString , <EOL> } ) { <EOL> return new Observable ( ( subscriber ) = > { <EOL> const state = createStateContainer < QueryState > ( { <EOL> time : timefilter . getTime ( ) , <EOL> refreshInterval : timefilter . getRefreshInterval ( ) , <EOL> filters : filterManager . getFilters ( ) , <EOL> query : queryString . getQuery ( ) , <EOL> } ) ; <EOL> let currentChange = { } ; <EOL> const subs = [ queryString . getUpdates $ ( ) . subscribe ( ( ) = > { <EOL> currentChange . query = true ; <EOL> state . set ( { <EOL> ... state . get ( ) , <EOL> query : queryString . getQuery ( ) <EOL> } ) ; <EOL> } ) , timefilter . getTimeUpdate $ ( ) . subscribe ( ( ) = > { <EOL> currentChange . time = true ; <EOL> state . set ( { <EOL> ... state . get ( ) , <EOL> time : timefilter . getTime ( ) <EOL> } ) ; <EOL> } ) , timefilter . getRefreshIntervalUpdate $ ( ) . subscribe ( ( ) = > { <EOL> currentChange . refreshInterval = true ; <EOL> state . set ( { <EOL> ... state . get ( ) , <EOL> refreshInterval : timefilter . getRefreshInterval ( ) <EOL> } ) ; <EOL> } ) , filterManager . getUpdates $ ( ) . subscribe ( ( ) = > { <EOL> currentChange . filters = true ; <EOL> const { <EOL> filters <EOL> } = state . get ( ) ; <EOL> const globalOld = filters ? . filter ( ( f ) = > isFilterPinned ( f ) ) ; <EOL> const appOld = filters ? . filter ( ( f ) = >   ! isFilterPinned ( f ) ) ; <EOL> const globalNew = filterManager . getGlobalFilters ( ) ; <EOL> const appNew = filterManager . getAppFilters ( ) ; <EOL> if ( ! globalOld | |   ! compareFilters ( globalOld , globalNew , COMPARE_ALL_OPTIONS ) ) { <EOL> currentChange . globalFilters = true ; <EOL> } <EOL> if ( ! appOld | |   ! compareFilters ( appOld , appNew , COMPARE_ALL_OPTIONS ) ) { <EOL> currentChange . appFilters = true ; <EOL> } <EOL> state . set ( { <EOL> ... state . get ( ) , <EOL> filters : filterManager . getFilters ( ) , <EOL> } ) ; <EOL> } ) , state . state $ . pipe ( map ( ( newState ) = > ( { <EOL> state : newState , <EOL> changes : currentChange <EOL> } ) ) , tap ( ( ) = > { <EOL> currentChange = { } ; <EOL> } ) ) . subscribe ( subscriber ) , ] ; <EOL> return ( ) = > { <EOL> subs . forEach ( ( s ) = > s . unsubscribe ( ) ) ; <EOL> } ; <EOL> } ) ; <EOL> } </s>
<s> import { <EOL> migrateLegacyQuery <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SearchSource , <EOL> SearchSourceDependencies <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternsContract <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SearchSourceFields <EOL> } from '<STR_LIT>' ; <EOL> param indexPatterns param searchSourceDependencies <EOL> return public <EOL> export const createSearchSource = ( indexPatterns , searchSourceDependencies ) = > async ( searchSourceFields = { } ) = > { <EOL> const fields = { <EOL> ... searchSourceFields <EOL> } ; <EOL> if ( fields . index & & typeof fields . index == = '<STR_LIT>' ) { <EOL> fields . index = await indexPatterns . get ( searchSourceFields . index as any ) ; <EOL> } <EOL> const searchSource = new SearchSource ( fields , searchSourceDependencies ) ; <EOL> const query = searchSource . getOwnField ( '<STR_LIT>' ) ; <EOL> if ( typeof query != = '<STR_LIT>' ) { <EOL> searchSource . setField ( '<STR_LIT>' , migrateLegacyQuery ( query ) ) ; <EOL> } <EOL> return searchSource ; <EOL> } ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . GEO_BOUNDS > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , AggArgs , Output > ; <EOL> export const aggGeoBounds = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> field : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . GEO_BOUNDS , <EOL> params : { <EOL> ... rest , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> export const wordBreak = ( ) = > [ <EOL> [ / ^ word - break - ( ? < value > normal | break - all | keep - all | break - word | inherit | initial | unset ) $ / , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> value <EOL> } = groups as { <EOL> value : string ; <EOL> } ; <EOL> return ConvertToCssObject ( [ ` word - break :   $ { value } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import { <EOL> get , <EOL> omit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getConvertedValueForField <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern <EOL> } from '<STR_LIT>' ; <EOL> export interface DeprecatedMatchPhraseFilter extends Filter { <EOL> query : { <EOL> match : { <EOL> [ field ] : { <EOL> query : any ; type : '<STR_LIT>' ; <EOL> } ; <EOL> } ; <EOL> } ; <EOL> } <EOL> function isDeprecatedMatchPhraseFilter ( filter ) { <EOL> const fieldName = filter . query & & filter . query . match & & Object . keys ( filter . query . match ) [ <NUM_LIT> ] ; <EOL> return Boolean ( fieldName & & get ( filter , [ '<STR_LIT>' , '<STR_LIT>' , fieldName , '<STR_LIT>' ] ) == = '<STR_LIT>' ) ; <EOL> } <EOL> export function migrateFilter ( filter , indexPattern   ? ) { <EOL> if ( isDeprecatedMatchPhraseFilter ( filter ) ) { <EOL> const fieldName = Object . keys ( filter . query . match ) [ <NUM_LIT> ] ; <EOL> const params = get ( filter , [ '<STR_LIT>' , '<STR_LIT>' , fieldName ] ) ; <EOL> let query = params . query ; <EOL> if ( indexPattern ) { <EOL> const field = indexPattern . fields . find ( ( f ) = > f . name == = fieldName ) ; <EOL> if ( field ) { <EOL> query = getConvertedValueForField ( field , params . query ) ; <EOL> } <EOL> } <EOL> return { <EOL> ... filter , <EOL> query : { <EOL> match_phrase : { <EOL> [ fieldName ] : omit ( { <EOL> ... params , <EOL> query , <EOL> } , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } <EOL> return filter ; <EOL> } </s>
<s> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PhraseFilter , <EOL> FilterValueFormatter , <EOL> getPhraseFilterValue , <EOL> getPhraseFilterField , <EOL> FILTERS , <EOL> isScriptedPhraseFilter , <EOL> Filter , <EOL> isPhraseFilter , <EOL> } from '<STR_LIT>' ; <EOL> const getScriptedPhraseValue = ( filter ) = > get ( filter , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> const getFormattedValueFn = ( value ) = > { <EOL> return ( formatter   ? ) = > { <EOL> return formatter   ? formatter . convert ( value ) : value ; <EOL> } ; <EOL> } ; <EOL> const getParams = ( filter ) = > { <EOL> const scriptedPhraseValue = getScriptedPhraseValue ( filter ) ; <EOL> const isScriptedFilter = Boolean ( scriptedPhraseValue ) ; <EOL> const key = isScriptedFilter   ? filter . meta . field | | '<STR_LIT>' : getPhraseFilterField ( filter ) ; <EOL> const query = scriptedPhraseValue | | getPhraseFilterValue ( filter ) ; <EOL> const params = { <EOL> query <EOL> } ; <EOL> return { <EOL> key , <EOL> params , <EOL> type : FILTERS . PHRASE , <EOL> value : getFormattedValueFn ( query ) , <EOL> } ; <EOL> } ; <EOL> export const isMapPhraseFilter = ( filter ) : filter is PhraseFilter = > isPhraseFilter ( filter ) | | isScriptedPhraseFilter ( filter ) ; <EOL> export const mapPhrase = ( filter ) = > { <EOL> if ( ! isMapPhraseFilter ( filter ) ) { <EOL> throw filter ; <EOL> } <EOL> return getParams ( filter ) ; <EOL> } ; </s>
<s> import '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> import { <EOL> EuiTabbedContent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getDocViewsRegistry <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DocViewerTab <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DocView , <EOL> DocViewRenderProps <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * Rendering tabs with different views of <NUM_LIT> OpenSearch hit in Discover . <EOL> * The tabs are provided by the   ` docs_views ` registry . <EOL> * A view can contain a React   ` component ` , or any JS framework by using <EOL> * a   ` render ` function . <EOL> * / <EOL> export function DocViewer ( renderProps ) { <EOL> const docViewsRegistry = getDocViewsRegistry ( ) ; <EOL> const tabs = docViewsRegistry . getDocViewsSorted ( renderProps . hit ) . map ( ( { <EOL> title , <EOL> render , <EOL> component <EOL> } , idx ) = > { <EOL> return { <EOL> id :   ` osd_doc_viewer_tab_ $ { idx } ` , <EOL> name : title , <EOL> content : ( < DocViewerTab id = { idx } title = { title } component = { component } renderProps = { renderProps } render = { render } / > ) , <EOL> } ; <EOL> } ) ; <EOL> if ( ! tabs . length ) { <EOL> return null ; <EOL> } <EOL> return ( < div className = "<STR_LIT>" > < EuiTabbedContent tabs = { tabs } / > < / div > ) ; } </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Actions , <EOL> Effect , <EOL> ofType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> User <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuthState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> of <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> catchError , <EOL> filter , <EOL> map , <EOL> switchMap , <EOL> withLatestFrom <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UsersService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> load , <EOL> loadAuthSuccess , <EOL> loadSuccess , <EOL> patchOne , <EOL> patchOneSuccess , <EOL> select , <EOL> serverErrorAuth , <EOL> serverErrorLoad , <EOL> serverErrorUpdate , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EntitiesState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getEntities <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class EntitiesEffects { <EOL> entities $ = this . store . select ( getEntities ) ; <EOL> @ Effect ( ) selected $ = this . actions $ . pipe ( ofType ( select ) , withLatestFrom ( this . entities $ ) , filter ( ( [ { <EOL> selectedId <EOL> } , entities ] ) = >   ! entities [ selectedId ] ) , map ( ( [ { <EOL> selectedId <EOL> } ] ) = > load ( { <EOL> id : selectedId <EOL> } ) ) ) ; <EOL> @ Effect ( ) updateOne $ = this . actions $ . pipe ( ofType ( patchOne ) , map ( ( { <EOL> user <EOL> } ) = > user ) , switchMap ( ( user ) = > this . service . patchMe ( user ) . pipe ( map ( ( updatedUser ) = > patchOneSuccess ( { <EOL> user : updatedUser <EOL> } ) ) , catchError ( error = > of ( serverErrorUpdate ( { <EOL> error <EOL> } ) ) ) ) ) ) ; <EOL> @ Effect ( ) authenticated $ = this . actions $ . pipe ( ofType ( AuthState . authIn ) , switchMap ( ( ) = > this . service . getMe ( ) . pipe ( map ( ( user ) = > loadAuthSuccess ( { <EOL> user <EOL> } ) ) , catchError ( error = > of ( serverErrorAuth ( { <EOL> error <EOL> } ) ) ) ) ) ) ; <EOL> @ Effect ( ) load $ = this . actions $ . pipe ( ofType ( load ) , switchMap ( ( { <EOL> id <EOL> } ) = > this . service . getOne ( id ) . pipe ( map ( user = > loadSuccess ( { <EOL> user <EOL> } ) ) , catchError ( error = > of ( serverErrorLoad ( { <EOL> error <EOL> } ) ) ) ) ) ) ; <EOL> constructor ( private store , private actions $ , private service ) { } <EOL> } </s>
<s> import { <EOL> BrowserCodeReader <EOL> } from '<STR_LIT>' ; <EOL> import MultiFormatReader from '<STR_LIT>' ; <EOL> import BinaryBitmap from '<STR_LIT>' ; <EOL> import Result from '<STR_LIT>' ; <EOL> import DecodeHintType from '<STR_LIT>' ; <EOL> export class BrowserMultiFormatReader extends BrowserCodeReader { <EOL> protected readonly reader : MultiFormatReader ; <EOL> public constructor ( hints = null , timeBetweenScansMillis = <NUM_LIT> ) { <EOL> const reader = new MultiFormatReader ( ) ; <EOL> reader . setHints ( hints ) ; <EOL> super ( reader , timeBetweenScansMillis ) ; <EOL> } <EOL> / ** <EOL> * Overwrite decodeBitmap to call decodeWithState , which will pay <EOL> * attention to the hints set in the constructor function <EOL> * / <EOL> public decodeBitmap ( binaryBitmap ) { <EOL> return this . reader . decodeWithState ( binaryBitmap ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> memoize <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CoreSetup <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> IFieldType , <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> function resolver ( title , field , query , boolFilter ) { <EOL> const ttl = Math . floor ( Date . now ( ) / <NUM_LIT> / <NUM_LIT> ) ; <EOL> return [ ttl , query , title , field . name , JSON . stringify ( boolFilter ) ] . join ( '<STR_LIT>' ) ; <EOL> } <EOL> export type ValueSuggestionsGetFn = ( args : ValueSuggestionsGetFnArgs ) = > Promise < any [ ] > ; <EOL> interface ValueSuggestionsGetFnArgs { <EOL> indexPattern : IIndexPattern ; field : IFieldType ; query : string ; boolFilter   ? : any [ ] ; signal   ? : AbortSignal ; <EOL> } <EOL> export const getEmptyValueSuggestions = ( ( ) = > Promise . resolve ( [ ] ) ) as ValueSuggestionsGetFn ; <EOL> export const setupValueSuggestionProvider = ( core ) : ValueSuggestionsGetFn = > { <EOL> const requestSuggestions = memoize ( ( index , field , query , boolFilter = [ ] , signal   ? ) = > core . http . fetch ( ` / api / opensearch - dashboards / suggestions / values / $ { index } ` , { <EOL> method : '<STR_LIT>' , <EOL> body : JSON . stringify ( { <EOL> query , <EOL> field : field . name , <EOL> boolFilter <EOL> } ) , <EOL> signal , <EOL> } ) , resolver ) ; <EOL> return async ( { <EOL> indexPattern , <EOL> field , <EOL> query , <EOL> boolFilter , <EOL> signal , <EOL> } ) : Promise < any [ ] > = > { <EOL> const shouldSuggestValues = core ! . uiSettings . get < boolean > ( UI_SETTINGS . FILTERS_EDITOR_SUGGEST_VALUES ) ; <EOL> const { <EOL> title <EOL> } = indexPattern ; <EOL> if ( field . type == = '<STR_LIT>' ) { <EOL> return [ true , false ] ; <EOL> } else if ( ! shouldSuggestValues | |   ! field . aggregatable | | field . type != = '<STR_LIT>' ) { <EOL> return [ ] ; <EOL> } <EOL> return await requestSuggestions ( title , field , query , boolFilter , signal ) ; <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> ExpressionTypeDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionValueRender <EOL> } from '<STR_LIT>' ; <EOL> const name = '<STR_LIT>' ; <EOL> export const shape = { <EOL> name : '<STR_LIT>' , <EOL> to : { <EOL> render : ( input ) = > { <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> as : name , <EOL> value : input , <EOL> } ; <EOL> } , <EOL> } , <EOL> } ; </s>
<s> import { <EOL> ExpressionValueError <EOL> } from '<STR_LIT>' ; <EOL> type ErrorLike = Partial < Pick < Error , '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' > > ; <EOL> export const createError = ( err ) : ExpressionValueError = > ( { <EOL> type : '<STR_LIT>' , <EOL> error : { <EOL> stack : process . env . NODE_ENV == = '<STR_LIT>'   ? undefined : typeof err == = '<STR_LIT>'   ? err . stack : undefined , <EOL> message : typeof err == = '<STR_LIT>'   ? err : String ( err . message ) , <EOL> name : typeof err == = '<STR_LIT>'   ? err . name | | '<STR_LIT>' : '<STR_LIT>' , <EOL> original : err instanceof Error   ? err : typeof err == = '<STR_LIT>' & & '<STR_LIT>' in err & & err . original instanceof Error   ? err . original : undefined , <EOL> } , <EOL> } ) ; </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import * as storage from '<STR_LIT>' ; <EOL> export const FavoriteProductProvider = ( { <EOL> children <EOL> } ) = > { <EOL> return ( < React . Fragment > { children } < / React . Fragment > ) ; } ; export function useFavoriteProduct ( ) { } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL>         $ Values <EOL> } from '<STR_LIT>' ; <EOL> export const AggGroupNames = Object . freeze ( { <EOL> Buckets : '<STR_LIT>' <EOL> as '<STR_LIT>' , <EOL> Metrics : '<STR_LIT>' <EOL> as '<STR_LIT>' , <EOL> None : '<STR_LIT>' <EOL> as '<STR_LIT>' , <EOL> } ) ; <EOL> export type AggGroupName =   $ Values < typeof AggGroupNames > ; <EOL> export const AggGroupLabels = { <EOL> [ AggGroupNames . Buckets ] : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> [ AggGroupNames . Metrics ] : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> [ AggGroupNames . None ] : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } ; </s>
<s> import { <EOL> createOsdFieldTypes , <EOL> OsdFieldTypeUnknown <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OsdFieldType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OPENSEARCH_FIELD_TYPES , <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> private <EOL> const registeredOsdTypes = createOsdFieldTypes ( ) ; <EOL> param { <EOL> string <EOL> } <EOL> typeName <EOL> return { <EOL> OsdFieldType <EOL> } <EOL> export const getOsdFieldType = ( typeName ) : OsdFieldType = > registeredOsdTypes . find ( ( t ) = > t . name == = typeName ) | | OsdFieldTypeUnknown ; <EOL> return { <EOL> Array < string > <EOL> } <EOL> export const getOsdTypeNames = ( ) : string [ ] = > registeredOsdTypes . filter ( ( type ) = > type . name ) . map ( ( type ) = > type . name ) ; <EOL> param { <EOL> string <EOL> } <EOL> opensearchType <EOL> return { <EOL> string <EOL> } <EOL> export const castOpenSearchToOsdFieldTypeName = ( opensearchType ) : OSD_FIELD_TYPES = > { <EOL> const type = registeredOsdTypes . find ( ( t ) = > t . esTypes . includes ( opensearchType as OPENSEARCH_FIELD_TYPES ) ) ; <EOL> return type & & type . name   ? ( type . name as OSD_FIELD_TYPES ) : OSD_FIELD_TYPES . UNKNOWN ; <EOL> } ; <EOL> return { <EOL> Array < string > <EOL> } <EOL> export const getFilterableOsdTypeNames = ( ) : string [ ] = > registeredOsdTypes . filter ( ( type ) = > type . filterable ) . map ( ( type ) = > type . name ) ; </s>
<s> import { <EOL> Injectable , <EOL> Injector , <EOL> ComponentFactoryResolver , <EOL> EmbeddedViewRef , <EOL> ApplicationRef <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class DomService { <EOL> private childComponentRef : any ; <EOL> constructor ( private componentFactoryResolver , private appRef , private injector ) { } <EOL> public appendComponentTo ( parentSelector , child , childConfig = { <EOL> inputs : { } , <EOL> outputs : { } <EOL> } ) { <EOL> const childComponentRef = this . componentFactoryResolver . resolveComponentFactory ( child ) . create ( this . injector ) ; <EOL> this . attachConfig ( childComponentRef , childConfig ) ; <EOL> this . childComponentRef = childComponentRef ; <EOL> this . appRef . attachView ( childComponentRef . hostView ) ; <EOL> const childDomElem = ( childComponentRef . hostView as EmbeddedViewRef < any > ) . rootNodes [ <NUM_LIT> ] as HTMLElement ; <EOL> const parentEl = document . querySelector ( parentSelector ) ; <EOL> if ( parentEl ) parentEl . appendChild ( childDomElem ) ; <EOL> } <EOL> public removeComponent ( ) { <EOL> this . appRef . detachView ( this . childComponentRef . hostView ) ; <EOL> this . childComponentRef . destroy ( ) ; <EOL> } <EOL> private attachConfig ( componentRef , { <EOL> inputs , <EOL> outputs <EOL> } ) { <EOL> const props = [ ... Object . entries ( outputs ) , ... Object . entries ( inputs ) ] ; <EOL> props . forEach ( ( [ key , val ] ) = > { <EOL> componentRef . instance [ key ] = val ; <EOL> } ) ; <EOL> } <EOL> } <EOL> export interface ChildConfig { <EOL> inputs : { <EOL> [ input ] : any ; <EOL> } ; outputs : { <EOL> [ output ] : any ; <EOL> } ; <EOL> } </s>
<s> import { <EOL> isNumber , <EOL> keys , <EOL> values , <EOL> find , <EOL> each , <EOL> cloneDeep , <EOL> flatten <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> buildExistsFilter , <EOL> buildPhrasesFilter , <EOL> buildQueryFromFilters <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggGroupNames <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IAggConfigs <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IBucketAggConfig <EOL> } from '<STR_LIT>' ; <EOL> param aggNestedDsl param startFromId <EOL> const getNestedAggDSL = ( aggNestedDsl , startFromAggId ) : any = > { <EOL> if ( aggNestedDsl [ startFromAggId ] ) { <EOL> return aggNestedDsl [ startFromAggId ] ; <EOL> } <EOL> const nestedAggs = values ( aggNestedDsl ) ; <EOL> let aggs ; <EOL> for ( let i = <NUM_LIT> ; i < nestedAggs . length ; i + + ) { <EOL> if ( nestedAggs [ i ] . aggs & & ( aggs = getNestedAggDSL ( nestedAggs [ i ] . aggs , startFromAggId ) ) ) { <EOL> return aggs ; <EOL> } <EOL> } <EOL> } ; <EOL> param aggConfigs param response param aggWithOtherBucket param key <EOL> const getAggResultBuckets = ( aggConfigs , response , aggWithOtherBucket , key ) = > { <EOL> const keyParts = key . split ( '<STR_LIT>' ) ; <EOL> let responseAgg = response ; <EOL> for ( const i in keyParts ) { <EOL> if ( keyParts [ i ] ) { <EOL> const responseAggs = values ( responseAgg ) ; <EOL> for ( let aggId = <NUM_LIT> ; aggId < responseAggs . length ; aggId + + ) { <EOL> const aggById = responseAggs [ aggId ] ; <EOL> const aggKey = keys ( responseAgg ) [ aggId ] ; <EOL> const aggConfig = find ( aggConfigs . aggs , ( agg ) = > agg . id == = aggKey ) ; <EOL> if ( aggConfig ) { <EOL> const aggResultBucket = find ( aggById . buckets , ( bucket , bucketObjKey ) = > { <EOL> const bucketKey = aggConfig . getKey ( bucket , isNumber ( bucketObjKey )   ? undefined : bucketObjKey ) . toString ( ) ; <EOL> return bucketKey == = keyParts [ i ] ; <EOL> } ) ; <EOL> if ( aggResultBucket ) { <EOL> responseAgg = aggResultBucket ; <EOL> break ; <EOL> } <EOL> } <EOL> } <EOL> } <EOL> } <EOL> if ( responseAgg [ aggWithOtherBucket . id ] ) { <EOL> return responseAgg [ aggWithOtherBucket . id ] . buckets ; <EOL> } <EOL> return [ ] ; <EOL> } ; <EOL> param responseAggs param aggId <EOL> const getAggConfigResultMissingBuckets = ( responseAggs , aggId ) = > { <EOL> const missingKey = '<STR_LIT>' ; <EOL> let resultBuckets = [ ] ; <EOL> if ( responseAggs [ aggId ] ) { <EOL> const matchingBucket = responseAggs [ aggId ] . buckets . find ( ( bucket ) = > bucket . key == = missingKey ) ; <EOL> if ( matchingBucket ) resultBuckets . push ( matchingBucket ) ; <EOL> return resultBuckets ; <EOL> } <EOL> each ( responseAggs , ( agg ) = > { <EOL> if ( agg . buckets ) { <EOL> each ( agg . buckets , ( bucket ) = > { <EOL> resultBuckets = [ ... resultBuckets , ... getAggConfigResultMissingBuckets ( bucket , aggId ) ] ; <EOL> } ) ; <EOL> } <EOL> } ) ; <EOL> return resultBuckets ; <EOL> } ; <EOL> param requestAgg param key param otherAgg <EOL> const getOtherAggTerms = ( requestAgg , key , otherAgg ) = > { <EOL> return requestAgg [ '<STR_LIT>' ] . filters . filters [ key ] . bool . must_not . filter ( ( filter ) = > filter . match_phrase & & filter . match_phrase [ otherAgg . params . field . name ] ) . map ( ( filter ) = > filter . match_phrase [ otherAgg . params . field . name ] ) ; <EOL> } ; <EOL> export const buildOtherBucketAgg = ( aggConfigs , aggWithOtherBucket , response ) = > { <EOL> const bucketAggs = aggConfigs . aggs . filter ( ( agg ) = > agg . type . type == = AggGroupNames . Buckets ) ; <EOL> const index = bucketAggs . findIndex ( ( agg ) = > agg . id == = aggWithOtherBucket . id ) ; <EOL> const aggs = aggConfigs . toDsl ( ) ; <EOL> const indexPattern = aggWithOtherBucket . aggConfigs . indexPattern ; <EOL> const filterAgg = aggConfigs . createAggConfig ( { <EOL> type : '<STR_LIT>' , <EOL> id : '<STR_LIT>' , <EOL> params : { <EOL> filters : [ ] , <EOL> } , <EOL> enabled : false , <EOL> } , { <EOL> addToAggConfigs : false , <EOL> } ) ; <EOL> const resultAgg = { <EOL> aggs : getNestedAggDSL ( aggs , aggWithOtherBucket . id ) . aggs , <EOL> filters : filterAgg . toDsl ( ) , <EOL> } ; <EOL> let noAggBucketResults = false ; <EOL> const walkBucketTree = ( aggIndex , aggregations , aggId , filters , key ) = > { <EOL> if ( aggregations [ aggId ] . buckets . length < <NUM_LIT> ) { <EOL> noAggBucketResults = true ; <EOL> return ; <EOL> } <EOL> const agg = aggregations [ aggId ] ; <EOL> const newAggIndex = aggIndex + <NUM_LIT> ; <EOL> const newAgg = bucketAggs [ newAggIndex ] ; <EOL> const currentAgg = bucketAggs [ aggIndex ] ; <EOL> if ( aggIndex < index ) { <EOL> each ( agg . buckets , ( bucket , bucketObjKey ) = > { <EOL> const bucketKey = currentAgg . getKey ( bucket , isNumber ( bucketObjKey )   ? undefined : bucketObjKey ) ; <EOL> const filter = cloneDeep ( bucket . filters ) | | currentAgg . createFilter ( bucketKey ) ; <EOL> const newFilters = flatten ( [ ... filters , filter ] ) ; <EOL> walkBucketTree ( newAggIndex , bucket , newAgg . id , newFilters ,   ` $ { key } - $ { bucketKey . toString ( ) } ` ) ; <EOL> } ) ; <EOL> return ; <EOL> } <EOL> const hasScriptedField =   ! ! aggWithOtherBucket . params . field . scripted ; <EOL> const hasMissingBucket =   ! ! aggWithOtherBucket . params . missingBucket ; <EOL> const hasMissingBucketKey = agg . buckets . some ( ( bucket ) = > bucket . key == = '<STR_LIT>' ) ; <EOL> if ( ! hasScriptedField & & ( ! hasMissingBucket | | hasMissingBucketKey ) ) { <EOL> filters . push ( buildExistsFilter ( aggWithOtherBucket . params . field , aggWithOtherBucket . aggConfigs . indexPattern ) ) ; <EOL> } <EOL> each ( agg . buckets , ( bucket ) = > { <EOL> if ( bucket . key == = '<STR_LIT>' ) return ; <EOL> const filter = currentAgg . createFilter ( bucket . key ) ; <EOL> filter . meta . negate = true ; <EOL> filters . push ( filter ) ; <EOL> } ) ; <EOL> resultAgg . filters . filters [ key ] = { <EOL> bool : buildQueryFromFilters ( filters , indexPattern ) , <EOL> } ; <EOL> } ; <EOL> walkBucketTree ( <NUM_LIT> , response . aggregations , bucketAggs [ <NUM_LIT> ] . id , [ ] , '<STR_LIT>' ) ; <EOL> if ( noAggBucketResults ) { <EOL> return false ; <EOL> } <EOL> return ( ) = > { <EOL> return { <EOL> '<STR_LIT>' : resultAgg , <EOL> } ; <EOL> } ; <EOL> } ; <EOL> export const mergeOtherBucketAggResponse = ( aggsConfig , response , otherResponse , otherAgg , requestAgg ) = > { <EOL> const updatedResponse = cloneDeep ( response ) ; <EOL> each ( otherResponse . aggregations [ '<STR_LIT>' ] . buckets , ( bucket , key ) = > { <EOL> if ( ! bucket . doc_count | | key == = undefined ) return ; <EOL> const bucketKey = key . replace ( / ^ - / , '<STR_LIT>' ) ; <EOL> const aggResultBuckets = getAggResultBuckets ( aggsConfig , updatedResponse . aggregations , otherAgg , bucketKey ) ; <EOL> const requestFilterTerms = getOtherAggTerms ( requestAgg , key , otherAgg ) ; <EOL> const phraseFilter = buildPhrasesFilter ( otherAgg . params . field , requestFilterTerms , otherAgg . aggConfigs . indexPattern ) ; <EOL> phraseFilter . meta . negate = true ; <EOL> bucket . filters = [ phraseFilter ] ; <EOL> bucket . key = '<STR_LIT>' ; <EOL> if ( aggResultBuckets . some ( ( aggResultBucket ) = > aggResultBucket . key == = '<STR_LIT>' ) ) { <EOL> bucket . filters . push ( buildExistsFilter ( otherAgg . params . field , otherAgg . aggConfigs . indexPattern ) ) ; <EOL> } <EOL> aggResultBuckets . push ( bucket ) ; <EOL> } ) ; <EOL> return updatedResponse ; <EOL> } ; <EOL> export const updateMissingBucket = ( response , aggConfigs , agg ) = > { <EOL> const updatedResponse = cloneDeep ( response ) ; <EOL> const aggResultBuckets = getAggConfigResultMissingBuckets ( updatedResponse . aggregations , agg . id ) ; <EOL> aggResultBuckets . forEach ( ( bucket ) = > { <EOL> bucket . key = '<STR_LIT>' ; <EOL> } ) ; <EOL> return updatedResponse ; <EOL> } ; </s>
<s> export class OsdError extends Error { <EOL> constructor ( message ) { <EOL> super ( message ) ; <EOL> Object . setPrototypeOf ( this , new . target . prototype ) ; <EOL> } <EOL> } <EOL> param { <EOL> String <EOL> } <EOL> name <EOL> export class DuplicateField extends OsdError { <EOL> constructor ( name ) { <EOL> super ( ` The field "<STR_LIT>" already exists in this mapping ` ) ; <EOL> } <EOL> } <EOL> / ** <EOL> * A saved object was not found <EOL> * / <EOL> export class SavedObjectNotFound extends OsdError { <EOL> public savedObjectType : string ; <EOL> public savedObjectId   ? : string ; <EOL> constructor ( type , id   ? , link   ? ) { <EOL> const idMsg = id   ?   ` ( id :   $ { id } ) ` : '<STR_LIT>' ; <EOL> let message =   ` Could not locate that   $ { type } $ { idMsg } ` ; <EOL> if ( link ) { <EOL> message +=   ` , [ click here to re - create it ] ( $ { link } ) ` ; <EOL> } <EOL> super ( message ) ; <EOL> this . savedObjectType = type ; <EOL> this . savedObjectId = id ; <EOL> } <EOL> } <EOL> / ** <EOL> * This error is for scenarios where a saved object is detected that has invalid JSON properties . <EOL> * There was a scenario where we were importing objects with double - encoded JSON , and the system <EOL> * was silently failing . This error is now thrown in those scenarios . <EOL> * / <EOL> export class InvalidJSONProperty extends OsdError { <EOL> constructor ( message ) { <EOL> super ( message ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternField <EOL> } from '<STR_LIT>' ; <EOL> export function getWarnings ( field ) { <EOL> let warnings = [ ] ; <EOL> if ( field . scripted ) { <EOL> warnings . push ( i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ) ; <EOL> } <EOL> if ( warnings . length > <NUM_LIT> ) { <EOL> warnings = warnings . map ( function ( warning , i ) { <EOL> return ( i > <NUM_LIT>   ? '<STR_LIT>' : '<STR_LIT>' ) + ( i + <NUM_LIT> ) + '<STR_LIT>' + warning ; <EOL> } ) ; <EOL> } <EOL> return warnings ; <EOL> } </s>
<s> import { <EOL> IbkrEvents <EOL> } from '<STR_LIT>' ; <EOL> const emitter = IbkrEvents . Instance ; <EOL> interface PublishToListeners { <EOL> topic : string ; data : any ; <EOL> } <EOL> export const publishDataToTopic = ( args ) : boolean = > { <EOL> const { <EOL> topic , <EOL> data <EOL> } = args ; <EOL> return emitter . emit ( topic , data ) ; <EOL> } ; </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> colors <EOL> } from "<STR_LIT>" ; <EOL> export interface ApprovedNewsroomsProps { <EOL> height   ? : string ; <EOL> width   ? : string ; <EOL> } <EOL> export const ApprovedNewsroomsIcon = props = > { <EOL> const color = colors . primary . CIVIL_GRAY_2 ; <EOL> const width = props . width | | "<STR_LIT>" ; <EOL> const height = props . height | | "<STR_LIT>" ; <EOL> return ( < svg width = { width } height = { height } viewBox = "<STR_LIT>" xmlns = "<STR_LIT>" > < circle fill = "<STR_LIT>" stroke = { color } cx = "<STR_LIT>" cy = "<STR_LIT>" r = "<STR_LIT>" / > < path fill = { color } d = "<STR_LIT>" / > < / svg > ) ; } ; </s>
<s> import { <EOL> IDataObject , <EOL> INodeExecutionData , <EOL> INodeParameters , <EOL> IRunExecutionData , <EOL> IWorkflowDataProxyAdditionalKeys , <EOL> IWorkflowDataProxyData , <EOL> NodeHelpers , <EOL> NodeParameterValue , <EOL> Workflow , <EOL> WorkflowExecuteMode , <EOL> } from '<STR_LIT>' ; <EOL> export class WorkflowDataProxy { <EOL> private workflow : Workflow ; <EOL> private runExecutionData : IRunExecutionData | null ; <EOL> private defaultReturnRunIndex : number ; <EOL> private runIndex : number ; <EOL> private itemIndex : number ; <EOL> private activeNodeName : string ; <EOL> private connectionInputData : INodeExecutionData [ ] ; <EOL> private siblingParameters : INodeParameters ; <EOL> private mode : WorkflowExecuteMode ; <EOL> private selfData : IDataObject ; <EOL> private additionalKeys : IWorkflowDataProxyAdditionalKeys ; <EOL> constructor ( workflow , runExecutionData , runIndex , itemIndex , activeNodeName , connectionInputData , siblingParameters , mode , additionalKeys , defaultReturnRunIndex = - <NUM_LIT> , selfData = { } ) { <EOL> this . workflow = workflow ; <EOL> this . runExecutionData = runExecutionData ; <EOL> this . defaultReturnRunIndex = defaultReturnRunIndex ; <EOL> this . runIndex = runIndex ; <EOL> this . itemIndex = itemIndex ; <EOL> this . activeNodeName = activeNodeName ; <EOL> this . connectionInputData = connectionInputData ; <EOL> this . siblingParameters = siblingParameters ; <EOL> this . mode = mode ; <EOL> this . selfData = selfData ; <EOL> this . additionalKeys = additionalKeys ; <EOL> } <EOL> private param { <EOL> string <EOL> } <EOL> nodeName returns memberof private nodeContextGetter ( nodeName ) { <EOL> const that = this ; <EOL> const node = this . workflow . nodes [ nodeName ] ; <EOL> return new Proxy ( { } , { <EOL> ownKeys ( target ) { <EOL> if ( Reflect . ownKeys ( target ) . length == = <NUM_LIT> ) { <EOL> Object . assign ( target , NodeHelpers . getContext ( that . runExecutionData ! , '<STR_LIT>' , node ) ) ; <EOL> } <EOL> return Reflect . ownKeys ( target ) ; <EOL> } , <EOL> getOwnPropertyDescriptor ( k ) { <EOL> return { <EOL> enumerable : true , <EOL> configurable : true , <EOL> } ; <EOL> } , <EOL> get ( target , name , receiver ) { <EOL> name = name . toString ( ) ; <EOL> const contextData = NodeHelpers . getContext ( that . runExecutionData ! , '<STR_LIT>' , node ) ; <EOL> if ( ! contextData . hasOwnProperty ( name ) ) { <EOL> throw new Error ( ` Could not find parameter "<STR_LIT>" on context of node "<STR_LIT>" ` ) ; <EOL> } <EOL> return contextData [ name ] ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> private selfGetter ( ) { <EOL> const that = this ; <EOL> return new Proxy ( { } , { <EOL> ownKeys ( target ) { <EOL> return Reflect . ownKeys ( target ) ; <EOL> } , <EOL> get ( target , name , receiver ) { <EOL> name = name . toString ( ) ; <EOL> return that . selfData [ name ] ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> private param { <EOL> string <EOL> } <EOL> nodeName returns memberof private nodeParameterGetter ( nodeName ) { <EOL> const that = this ; <EOL> const node = this . workflow . nodes [ nodeName ] ; <EOL> return new Proxy ( node . parameters , { <EOL> ownKeys ( target ) { <EOL> return Reflect . ownKeys ( target ) ; <EOL> } , <EOL> getOwnPropertyDescriptor ( k ) { <EOL> return { <EOL> enumerable : true , <EOL> configurable : true , <EOL> } ; <EOL> } , <EOL> get ( target , name , receiver ) { <EOL> name = name . toString ( ) ; <EOL> let returnValue ; <EOL> if ( name [ <NUM_LIT> ] == = '<STR_LIT>' ) { <EOL> const key = name . slice ( <NUM_LIT> ) ; <EOL> if ( ! that . siblingParameters . hasOwnProperty ( key ) ) { <EOL> throw new Error ( ` Could not find sibling parameter "<STR_LIT>" on node "<STR_LIT>" ` ) ; <EOL> } <EOL> returnValue = that . siblingParameters [ key ] ; <EOL> } else { <EOL> if ( ! node . parameters . hasOwnProperty ( name ) ) { <EOL> throw new Error ( ` Could not find parameter "<STR_LIT>" on node "<STR_LIT>" ` ) ; <EOL> } <EOL> returnValue = node . parameters [ name ] ; <EOL> } <EOL> if ( typeof returnValue == = '<STR_LIT>' & & returnValue . charAt ( <NUM_LIT> ) == = '<STR_LIT>' ) { <EOL> return that . workflow . expression . getParameterValue ( returnValue , that . runExecutionData , that . runIndex , that . itemIndex , that . activeNodeName , that . connectionInputData , that . mode , that . additionalKeys ) ; <EOL> } <EOL> return returnValue ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> private param { <EOL> string <EOL> } <EOL> nodeName param { <EOL> boolean <EOL> } <EOL> shortSyntax param { <EOL> number <EOL> } <EOL> outputIndex param { <EOL> number <EOL> } <EOL> runIndex returns { <EOL> INodeExecutionData [ ] <EOL> } <EOL> memberof private getNodeExecutionData ( nodeName , shortSyntax = false , outputIndex   ? , runIndex   ? ) { <EOL> const that = this ; <EOL> let executionData ; <EOL> if ( ! shortSyntax ) { <EOL> if ( that . runExecutionData == = null ) { <EOL> throw new Error ( ` Workflow did not run so do not have any execution - data . ` ) ; <EOL> } <EOL> if ( ! that . runExecutionData . resultData . runData . hasOwnProperty ( nodeName ) ) { <EOL> throw new Error ( ` No execution data found for node "<STR_LIT>" ` ) ; <EOL> } <EOL> runIndex = runIndex == = undefined   ? that . defaultReturnRunIndex : runIndex ; <EOL> runIndex = runIndex == = - <NUM_LIT>   ? that . runExecutionData . resultData . runData [ nodeName ] . length - <NUM_LIT> : runIndex ; <EOL> if ( that . runExecutionData . resultData . runData [ nodeName ] . length < runIndex ) { <EOL> throw new Error ( ` No execution data found for run "<STR_LIT>" of node "<STR_LIT>" ` ) ; <EOL> } <EOL> const taskData = that . runExecutionData . resultData . runData [ nodeName ] [ runIndex ] . data ! ; <EOL> if ( taskData . main == = null | |   ! taskData . main . length | | taskData . main [ <NUM_LIT> ] == = null ) { <EOL> throw new Error ( ` No data found from "<STR_LIT>" input . ` ) ; <EOL> } <EOL> if ( outputIndex == = undefined ) { <EOL> const outputIndex = that . workflow . getNodeConnectionOutputIndex ( that . activeNodeName , nodeName , '<STR_LIT>' ) ; <EOL> if ( outputIndex == = undefined ) { <EOL> throw new Error ( ` The node "<STR_LIT>" is not connected with node "<STR_LIT>" so no data can get returned from it . ` ) ; <EOL> } <EOL> } <EOL> if ( outputIndex == = undefined ) { <EOL> outputIndex = <NUM_LIT> ; <EOL> } <EOL> if ( taskData . main . length < outputIndex ) { <EOL> throw new Error ( ` No data found from "<STR_LIT>" input with index "<STR_LIT>" via which node is connected with . ` ) ; <EOL> } <EOL> executionData = taskData . main [ outputIndex ] as INodeExecutionData [ ] ; <EOL> } else { <EOL> executionData = that . connectionInputData ; <EOL> } <EOL> return executionData ; <EOL> } <EOL> private param { <EOL> string <EOL> } <EOL> nodeName param { <EOL> boolean <EOL> } <EOL> shortSyntax returns memberof private nodeDataGetter ( nodeName , shortSyntax = false ) { <EOL> const that = this ; <EOL> const node = this . workflow . nodes [ nodeName ] ; <EOL> if ( ! node ) { <EOL> throw new Error ( ` The node "<STR_LIT>" does not exist ! ` ) ; <EOL> } <EOL> return new Proxy ( { } , { <EOL> get ( target , name , receiver ) { <EOL> name = name . toString ( ) ; <EOL> if ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( name ) ) { <EOL> const executionData = that . getNodeExecutionData ( nodeName , shortSyntax , undefined ) ; <EOL> if ( executionData . length <= that . itemIndex ) { <EOL> throw new Error ( ` No data found for item - index : "<STR_LIT>" ` ) ; <EOL> } <EOL> if ( [ '<STR_LIT>' , '<STR_LIT>' ] . includes ( name ) ) { <EOL> return executionData [ that . itemIndex ] . json ; <EOL> } <EOL> if ( name == = '<STR_LIT>' ) { <EOL> const returnData = { } ; <EOL> if ( ! executionData [ that . itemIndex ] . binary ) { <EOL> return returnData ; <EOL> } <EOL> const binaryKeyData = executionData [ that . itemIndex ] . binary ! ; <EOL> for ( const keyName of Object . keys ( binaryKeyData ) ) { <EOL> returnData [ keyName ] = { } ; <EOL> const binaryData = binaryKeyData [ keyName ] ; <EOL> for ( const propertyName in binaryData ) { <EOL> if ( propertyName == = '<STR_LIT>' ) { <EOL> continue ; <EOL> } ( returnData [ keyName ] as IDataObject ) [ propertyName ] = binaryData [ propertyName ] ; <EOL> } <EOL> } <EOL> return returnData ; <EOL> } <EOL> } else if ( name == = '<STR_LIT>' ) { <EOL> return that . nodeContextGetter ( nodeName ) ; <EOL> } else if ( name == = '<STR_LIT>' ) { <EOL> return that . nodeParameterGetter ( nodeName ) ; <EOL> } else if ( name == = '<STR_LIT>' ) { <EOL> if ( that . runExecutionData == = null | |   ! that . runExecutionData . resultData . runData [ nodeName ] ) { <EOL> return - <NUM_LIT> ; <EOL> } <EOL> return that . runExecutionData . resultData . runData [ nodeName ] . length - <NUM_LIT> ; <EOL> } <EOL> return Reflect . get ( target , name , receiver ) ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> private returns memberof private envGetter ( ) { <EOL> return new Proxy ( { } , { <EOL> get ( target , name , receiver ) { <EOL> return process . env [ name . toString ( ) ] ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> private returns memberof private workflowGetter ( ) { <EOL> const allowedValues = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> const that = this ; <EOL> return new Proxy ( { } , { <EOL> ownKeys ( target ) { <EOL> return allowedValues ; <EOL> } , <EOL> getOwnPropertyDescriptor ( k ) { <EOL> return { <EOL> enumerable : true , <EOL> configurable : true , <EOL> } ; <EOL> } , <EOL> get ( target , name , receiver ) { <EOL> if ( ! allowedValues . includes ( name . toString ( ) ) ) { <EOL> throw new Error ( ` The key "<STR_LIT>" is not supported ! ` ) ; <EOL> } <EOL> return that . workflow [ name . toString ( ) ] ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> private returns memberof private nodeGetter ( ) { <EOL> const that = this ; <EOL> return new Proxy ( { } , { <EOL> get ( target , name , receiver ) { <EOL> return that . nodeDataGetter ( name . toString ( ) ) ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> returns memberof getDataProxy ( ) { <EOL> const that = this ; <EOL> const base = { <EOL>                         $ binary : { } , <EOL>                         $ data : { } , <EOL>                         $ env : this . envGetter ( ) , <EOL>                         $ evaluateExpression : ( expression , itemIndex   ? ) = > { <EOL> itemIndex = itemIndex | | that . itemIndex ; <EOL> return that . workflow . expression . getParameterValue ( ` = $ { expression } ` , that . runExecutionData , that . runIndex , itemIndex , that . activeNodeName , that . connectionInputData , that . mode , that . additionalKeys ) ; <EOL> } , <EOL>                         $ item : ( itemIndex , runIndex   ? ) = > { <EOL> const defaultReturnRunIndex = runIndex == = undefined   ? - <NUM_LIT> : runIndex ; <EOL> const dataProxy = new WorkflowDataProxy ( this . workflow , this . runExecutionData , this . runIndex , itemIndex , this . activeNodeName , this . connectionInputData , that . siblingParameters , that . mode , that . additionalKeys , defaultReturnRunIndex ) ; <EOL> return dataProxy . getDataProxy ( ) ; <EOL> } , <EOL>                         $ items : ( nodeName   ? , outputIndex   ? , runIndex   ? ) = > { <EOL> let executionData ; <EOL> if ( nodeName == = undefined ) { <EOL> executionData = that . connectionInputData ; <EOL> } else { <EOL> outputIndex = outputIndex | | <NUM_LIT> ; <EOL> runIndex = runIndex == = undefined   ? - <NUM_LIT> : runIndex ; <EOL> executionData = that . getNodeExecutionData ( nodeName , false , outputIndex , runIndex ) ; <EOL> } <EOL> return executionData ; <EOL> } , <EOL>                         $ json : { } , <EOL>                         $ node : this . nodeGetter ( ) , <EOL>                         $ self : this . selfGetter ( ) , <EOL>                         $ parameter : this . nodeParameterGetter ( this . activeNodeName ) , <EOL>                         $ position : this . itemIndex , <EOL>                         $ runIndex : this . runIndex , <EOL>                         $ mode : this . mode , <EOL>                         $ workflow : this . workflowGetter ( ) , <EOL> ... that . additionalKeys , <EOL> } ; <EOL> return new Proxy ( base , { <EOL> get ( target , name , receiver ) { <EOL> if ( [ '<STR_LIT>' , '<STR_LIT>' ] . includes ( name as string ) ) { <EOL> return that . nodeDataGetter ( that . activeNodeName , true ) . json ; <EOL> } <EOL> if ( name == = '<STR_LIT>' ) { <EOL> return that . nodeDataGetter ( that . activeNodeName , true ) . binary ; <EOL> } <EOL> return Reflect . get ( target , name , receiver ) ; <EOL> } , <EOL> } ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Team <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> User <EOL> } from '<STR_LIT>' ; <EOL> export interface IUmbrielService { <EOL> addUserToTeam ( user , team ) : Promise < void > ; <EOL> } </s>
<s> import { <EOL> SearchResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OsdError <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SearchError <EOL> } from '<STR_LIT>' ; <EOL> param { <EOL> Error <EOL> } <EOL> err param { <EOL> Object <EOL> } <EOL> resp <EOL> export class RequestFailure extends OsdError { <EOL> public resp   ? : SearchResponse < any > ; <EOL> constructor ( err = null , resp   ? ) { <EOL> super ( ` Request to OpenSearch failed :   $ { JSON . stringify ( resp | | err   ? . message ) } ` ) ; <EOL> this . resp = resp ; <EOL> } <EOL> } </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> IndexPattern <EOL> } from '<STR_LIT>' ; <EOL> function flattenHit ( indexPattern , hit , deep ) { <EOL> const flat = { } <EOL> as Record < string , any > ; <EOL> const fields = indexPattern . fields . getByName ; <EOL> ( function flatten ( obj , keyPrefix = '<STR_LIT>' ) { <EOL> keyPrefix = keyPrefix   ? keyPrefix + '<STR_LIT>' : '<STR_LIT>' ; <EOL> _ . forOwn ( obj , function ( val , key ) { <EOL> key = keyPrefix + key ; <EOL> if ( deep ) { <EOL> const field = fields ( key ) ; <EOL> const isNestedField = field & & field . type == = '<STR_LIT>' ; <EOL> const isArrayOfObjects = Array . isArray ( val ) & & _ . isPlainObject ( _ . first ( val ) ) ; <EOL> if ( isArrayOfObjects & &   ! isNestedField ) { <EOL> _ . each ( val , ( v ) = > flatten ( v , key ) ) ; <EOL> return ; <EOL> } <EOL> } else if ( flat [ key ] != = void <NUM_LIT> ) { <EOL> return ; <EOL> } <EOL> const field = fields ( key ) ; <EOL> const hasValidMapping = field & & field . type != = '<STR_LIT>' ; <EOL> const isValue =   ! _ . isPlainObject ( val ) ; <EOL> if ( hasValidMapping | | isValue ) { <EOL> if ( ! flat [ key ] ) { <EOL> flat [ key ] = val ; <EOL> } else if ( Array . isArray ( flat [ key ] ) ) { <EOL> flat [ key ] . push ( val ) ; <EOL> } else { <EOL> flat [ key ] = [ flat [ key ] , val ] ; <EOL> } <EOL> return ; <EOL> } <EOL> flatten ( val , key ) ; <EOL> } ) ; <EOL> } ) ( hit . _source ) ; <EOL> return flat ; <EOL> } <EOL> function decorateFlattenedWrapper ( hit , metaFields ) { <EOL> return function ( flattened ) { <EOL> _ . each ( metaFields , function ( meta ) { <EOL> if ( meta == = '<STR_LIT>' ) return ; <EOL> flattened [ meta ] = hit [ meta ] ; <EOL> } ) ; <EOL> _ . forOwn ( hit . fields , function ( val , key ) { <EOL> if ( key [ <NUM_LIT> ] == = '<STR_LIT>' & &   ! _ . includes ( metaFields , key ) ) return ; <EOL> if ( Array . isArray ( val ) & & val . length <= <NUM_LIT> ) { <EOL> flattened [ key ] = val [ <NUM_LIT> ] ; <EOL> } else { <EOL> flattened [ key ] = val ; <EOL> } <EOL> } ) ; <EOL> return flattened ; <EOL> } ; <EOL> } <EOL> internal <EOL> export function flattenHitWrapper ( indexPattern , metaFields = { } , cache = new WeakMap ( ) ) { <EOL> return function cachedFlatten ( hit , deep = false ) { <EOL> const decorateFlattened = decorateFlattenedWrapper ( hit , metaFields ) ; <EOL> const cached = cache . get ( hit ) ; <EOL> const flattened = cached | | flattenHit ( indexPattern , hit , deep ) ; <EOL> if ( ! cached ) { <EOL> cache . set ( hit , { <EOL> ... flattened <EOL> } ) ; <EOL> } <EOL> return decorateFlattened ( flattened ) ; <EOL> } ; <EOL> } <EOL> public <EOL> export function createFlattenHitWrapper ( ) { <EOL> const cache = new WeakMap ( ) ; <EOL> return _ . partial ( flattenHitWrapper , _ , _ , cache ) ; <EOL> } </s>
<s> import * as update from '<STR_LIT>' ; <EOL> import { <EOL> getConversationMessagesQuery as MessagesQuery , <EOL> getUserConversationConnectionThroughUserQuery as ConvosQuery , <EOL> getAllUsersQuery as UsersQuery <EOL> } from '<STR_LIT>' ; <EOL> import Message from '<STR_LIT>' ; <EOL> import UserConversation from '<STR_LIT>' ; <EOL> import User from '<STR_LIT>' ; <EOL> import * as _ from '<STR_LIT>' ; <EOL> export const constants = { <EOL> conversationFirst : <NUM_LIT> , <EOL> messageFirst : <NUM_LIT> <EOL> } ; <EOL> export function unshiftMessage ( data , message ) { <EOL> if ( ! data | |   ! _ . has ( data , '<STR_LIT>' ) ) { <EOL> return { <EOL> allMessageConnection : { <EOL> nextToken : null , <EOL> __typename : '<STR_LIT>' , <EOL> messages : [ ] <EOL> } <EOL> } ; <EOL> } <EOL> if ( data . allMessageConnection . messages . some ( m = > m . id == = message . id ) ) { <EOL> return data ; <EOL> } <EOL> return update ( data , { <EOL> allMessageConnection : { <EOL> messages : { <EOL>                                 $ unshift : [ message ] <EOL> } <EOL> } <EOL> } ) ; <EOL> } <EOL> export function pushMessages ( data , messages , nextToken ) { <EOL> if ( ! data | |   ! _ . has ( data , '<STR_LIT>' ) ) { <EOL> return { <EOL> allMessageConnection : { <EOL> nextToken : null , <EOL> __typename : '<STR_LIT>' , <EOL> messages : [ ] <EOL> } <EOL> } ; <EOL> } <EOL> return update ( data , { <EOL> allMessageConnection : { <EOL> messages : { <EOL>                                 $ push : messages <EOL> } , <EOL> nextToken : { <EOL>                                 $ set : nextToken <EOL> } <EOL> } <EOL> } ) ; <EOL> } <EOL> export function addConversation ( data , uc ) { <EOL> if ( ! data | |   ! _ . has ( data , '<STR_LIT>' ) ) { <EOL> return { <EOL> me : { <EOL> conversations : { <EOL> nextToken : null , <EOL> __typename : '<STR_LIT>' , <EOL> userConversations : [ ] <EOL> } <EOL> } <EOL> } ; <EOL> } <EOL> if ( data . me . conversations . userConversations . some ( _uc = > uc . conversationId == = _uc . conversationId ) ) { <EOL> return data ; <EOL> } <EOL> return update ( data , { <EOL> me : { <EOL> conversations : { <EOL> userConversations : { <EOL>                                         $ push : [ uc ] <EOL> } <EOL> } <EOL> } <EOL> } ) ; <EOL> } <EOL> export function addUser ( data , user ) { <EOL> if ( ! data | |   ! data . allUser ) { <EOL> return { <EOL> allUser : [ ] <EOL> } ; <EOL> } <EOL> if ( data . allUser . some ( _user = > _user . id == = user . id ) ) { <EOL> return data ; <EOL> } <EOL> return update ( data , { <EOL> allUser : { <EOL>                         $ push : [ user ] <EOL> } <EOL> } ) ; <EOL> } </s>
<s> import { <EOL> ContractDetails , <EOL> ContractSummary , <EOL> SecType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getRadomReqId <EOL> } from '<STR_LIT>' ; <EOL> import IBKRConnection from '<STR_LIT>' ; <EOL> import { <EOL> handleEventfulError <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EventName <EOL> } from '<STR_LIT>' ; <EOL> export interface ContractDetailsParams { <EOL> readonly conId   ? : number ; <EOL> readonly symbol   ? : string ; <EOL> readonly secType   ? : SecType | string ; <EOL> readonly expiry   ? : string ; <EOL> readonly strike   ? : number ; <EOL> readonly right   ? : string ; <EOL> readonly multiplier   ? : number ; <EOL> readonly exchange   ? : string ; <EOL> readonly currency   ? : string ; <EOL> readonly localSymbol   ? : string ; <EOL> readonly tradingClass   ? : string ; <EOL> readonly comboLegsDescrip   ? : string ; <EOL> readonly includeExpired   ? : any ; <EOL> readonly secIdType   ? : any ; <EOL> readonly secId   ? : any ; <EOL> } <EOL> / ** <EOL> * For some reason , NASDAQ needs to be called ISLAND in the contract request field for "<STR_LIT>" . <EOL> * / <EOL> const exchangeMap = { <EOL> NASDAQ : '<STR_LIT>' , <EOL> } ; <EOL> export function convertContractToContractDetailsParams ( contract ) { <EOL> return { <EOL> conId : contract . conId , <EOL> symbol : contract . symbol , <EOL> secType : contract . secType , <EOL> expiry : contract . expiry , <EOL> strike : contract . strike , <EOL> right : contract . right , <EOL> multiplier : contract . multiplier , <EOL> exchange : ( contract . exchange & & exchangeMap [ contract . exchange ] )   ? ? contract . exchange , <EOL> currency : contract . currency , <EOL> localSymbol : contract . localSymbol , <EOL> tradingClass : contract . tradingClass , <EOL> comboLegsDescrip : contract . comboLegsDescrip , <EOL> includeExpired : undefined , <EOL> secIdType : undefined , <EOL> secId : undefined , <EOL> } ; <EOL> } <EOL> export const getContractDetails = ( params ) : Promise < ContractDetails [ ] > = > { <EOL> const contractsLocal = [ ] ; <EOL> const reqId = getRadomReqId ( ) ; <EOL> return new Promise ( ( resolve ) = > { <EOL> const ib = IBKRConnection . Instance . getIBKR ( ) ; <EOL> const handleContract = ( reqIdX , contractReceived ) = > { <EOL> if ( reqIdX == = reqId ) { <EOL> contractsLocal . push ( contractReceived ) ; <EOL> } <EOL> } ; <EOL> ib . on ( EventName . contractDetails , handleContract ) ; <EOL> const contractDetailsEnd = ( reqIdX , isError   ? ) = > { <EOL> if ( reqIdX == = reqId ) { <EOL> if ( isError ) { <EOL> return resolve ( [ ] ) ; <EOL> } <EOL> eventfulError ( ) ; <EOL> ib . off ( EventName . contractDetails , handleContract ) ; <EOL> return resolve ( contractsLocal ) ; <EOL> } <EOL> } ; <EOL> ib . on ( EventName . contractDetailsEnd , contractDetailsEnd ) ; <EOL> const eventfulError = handleEventfulError ( reqId , [ ` No security definition has been found for the request ` ,   ` The contract description specified is ambiguous : ` , JSON . stringify ( params ) , ] , ( ) = > contractDetailsEnd ( reqId , true ) ) ; <EOL> ib . reqContractDetails ( reqId , params as any ) ; <EOL> } ) ; <EOL> } ; <EOL> export const getContractDetailsOneOrNone = async ( params ) = > { <EOL> const contractDetailsList = await getContractDetails ( params ) ; <EOL> if ( contractDetailsList . length == = <NUM_LIT> ) { <EOL> return undefined ; <EOL> } else if ( contractDetailsList . length == = <NUM_LIT> ) { <EOL> return contractDetailsList [ <NUM_LIT> ] ; <EOL> } else { <EOL> throw Error ( '<STR_LIT>' + JSON . stringify ( contractDetailsList ) ) ; <EOL> } <EOL> } ; <EOL> export const getContractDetailsOne = async ( params ) = > { <EOL> const contractDetailsList = await getContractDetails ( params ) ; <EOL> if ( contractDetailsList . length == = <NUM_LIT> ) { <EOL> throw Error ( '<STR_LIT>' + JSON . stringify ( params ) ) ; <EOL> } else if ( contractDetailsList . length == = <NUM_LIT> ) { <EOL> return contractDetailsList [ <NUM_LIT> ] ; <EOL> } else { <EOL> throw Error ( '<STR_LIT>' + JSON . stringify ( contractDetailsList ) ) ; <EOL> } <EOL> } ; <EOL> export const getContractSummaryOne = async ( params ) = > { <EOL> const contractDetailsList = await getContractDetails ( params ) ; <EOL> if ( contractDetailsList . length == = <NUM_LIT> ) { <EOL> throw Error ( '<STR_LIT>' + JSON . stringify ( params ) ) ; <EOL> } else if ( contractDetailsList . length == = <NUM_LIT> ) { <EOL> return contractDetailsList [ <NUM_LIT> ] . summary ; <EOL> } else { <EOL> throw Error ( '<STR_LIT>' + JSON . stringify ( contractDetailsList ) ) ; <EOL> } <EOL> } ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> export const getCountMetricAgg = ( ) = > new MetricAggType ( { <EOL> name : METRIC_TYPES . COUNT , <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> hasNoDsl : true , <EOL> json : false , <EOL> makeLabel ( ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> } , <EOL> getSerializedFormat ( agg ) { <EOL> return { <EOL> id : '<STR_LIT>' , <EOL> } ; <EOL> } , <EOL> getValue ( agg , bucket ) { <EOL> return bucket . doc_count ; <EOL> } , <EOL> isScalable ( ) { <EOL> return true ; <EOL> } , <EOL> } ) ; </s>
<s> import _ from '<STR_LIT>' ; <EOL> import PropTypes from '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> import { <EOL> EuiContextMenuItem , <EOL> EuiContextMenuPanel , <EOL> EuiEmptyPrompt , <EOL> EuiFieldSearch , <EOL> EuiFilterButton , <EOL> EuiFilterGroup , <EOL> EuiFlexGroup , <EOL> EuiFlexItem , <EOL> EuiListGroup , <EOL> EuiListGroupItem , <EOL> EuiLoadingSpinner , <EOL> EuiPagination , <EOL> EuiPopover , <EOL> EuiSpacer , <EOL> EuiTablePagination , <EOL> IconType , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Direction <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SimpleSavedObject , <EOL> CoreStart , <EOL> IUiSettingsClient , <EOL> SavedObjectsStart , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> LISTING_LIMIT_SETTING <EOL> } from '<STR_LIT>' ; <EOL> export interface SavedObjectMetaData < T = unknown > { <EOL> type : string ; name : string ; getIconForSavedObject ( savedObject ) : IconType ; getTooltipForSavedObject   ? ( savedObject ) : string ; showSavedObject   ? ( savedObject ) : boolean ; includeFields   ? : string [ ] ; <EOL> } <EOL> interface FinderAttributes { <EOL> title   ? : string ; <EOL> type : string ; <EOL> } <EOL> interface SavedObjectFinderState { <EOL> items : Array < { <EOL> title : string | null ; id : SimpleSavedObject [ '<STR_LIT>' ] ; type : SimpleSavedObject [ '<STR_LIT>' ] ; savedObject : SimpleSavedObject < FinderAttributes > ; <EOL> } > ; query : string ; isFetchingItems : boolean ; page : number ; perPage : number ; sortDirection   ? : Direction ; sortOpen : boolean ; filterOpen : boolean ; filteredTypes : string [ ] ; <EOL> } <EOL> interface BaseSavedObjectFinder { <EOL> onChoose   ? : ( id : SimpleSavedObject [ '<STR_LIT>' ] , type : SimpleSavedObject [ '<STR_LIT>' ] , name : string , savedObject : SimpleSavedObject ) = > void ; <EOL> noItemsMessage   ? : React . ReactNode ; <EOL> savedObjectMetaData : Array < SavedObjectMetaData < FinderAttributes > > ; <EOL> showFilter   ? : boolean ; <EOL> } <EOL> interface SavedObjectFinderFixedPage extends BaseSavedObjectFinder { <EOL> initialPageSize   ? : undefined ; <EOL> fixedPageSize : number ; <EOL> } <EOL> interface SavedObjectFinderInitialPageSize extends BaseSavedObjectFinder { <EOL> initialPageSize   ? : <NUM_LIT> | <NUM_LIT> | <NUM_LIT> | <NUM_LIT> ; <EOL> fixedPageSize   ? : undefined ; <EOL> } <EOL> export type SavedObjectFinderProps = SavedObjectFinderFixedPage | SavedObjectFinderInitialPageSize ; <EOL> export type SavedObjectFinderUiProps = { <EOL> savedObjects : CoreStart [ '<STR_LIT>' ] ; uiSettings : CoreStart [ '<STR_LIT>' ] ; <EOL> } & SavedObjectFinderProps ; <EOL> class SavedObjectFinderUi extends React . Component < SavedObjectFinderUiProps , SavedObjectFinderState > { <EOL> public static propTypes = { <EOL> onChoose : PropTypes . func , <EOL> noItemsMessage : PropTypes . node , <EOL> savedObjectMetaData : PropTypes . array . isRequired , <EOL> initialPageSize : PropTypes . oneOf ( [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] ) , <EOL> fixedPageSize : PropTypes . number , <EOL> showFilter : PropTypes . bool , <EOL> } ; private isComponentMounted : boolean = false ; private debouncedFetch = _ . debounce ( async ( query ) = > { <EOL> const metaDataMap = this . getSavedObjectMetaDataMap ( ) ; <EOL> const fields = Object . values ( metaDataMap ) . map ( ( metaData ) = > metaData . includeFields | | [ ] ) . reduce ( ( allFields , currentFields ) = > allFields . concat ( currentFields ) , [ '<STR_LIT>' ] ) ; <EOL> const perPage = this . props . uiSettings . get ( LISTING_LIMIT_SETTING ) ; <EOL> const resp = await this . props . savedObjects . client . find < FinderAttributes > ( { <EOL> type : Object . keys ( metaDataMap ) , <EOL> fields : [ ... new Set ( fields ) ] , <EOL> search : query   ?   ` $ { query } * ` : undefined , <EOL> page : <NUM_LIT> , <EOL> perPage , <EOL> searchFields : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> defaultSearchOperator : '<STR_LIT>' , <EOL> } ) ; <EOL> resp . savedObjects = resp . savedObjects . filter ( ( savedObject ) = > { <EOL> const metaData = metaDataMap [ savedObject . type ] ; <EOL> if ( metaData . showSavedObject ) { <EOL> return metaData . showSavedObject ( savedObject ) ; <EOL> } else { <EOL> return true ; <EOL> } <EOL> } ) ; <EOL> if ( ! this . isComponentMounted ) { <EOL> return ; <EOL> } <EOL> if ( query == = this . state . query ) { <EOL> this . setState ( { <EOL> isFetchingItems : false , <EOL> page : <NUM_LIT> , <EOL> items : resp . savedObjects . map ( ( savedObject ) = > { <EOL> const { <EOL> attributes : { <EOL> title <EOL> } , <EOL> id , <EOL> type , <EOL> } = savedObject ; <EOL> return { <EOL> title : typeof title == = '<STR_LIT>'   ? title : '<STR_LIT>' , <EOL> id , <EOL> type , <EOL> savedObject , <EOL> } ; <EOL> } ) , <EOL> } ) ; <EOL> } <EOL> } , <NUM_LIT> ) ; constructor ( props ) { <EOL> super ( props ) ; <EOL> this . state = { <EOL> items : [ ] , <EOL> isFetchingItems : false , <EOL> page : <NUM_LIT> , <EOL> perPage : props . initialPageSize | | props . fixedPageSize | | <NUM_LIT> , <EOL> query : '<STR_LIT>' , <EOL> filterOpen : false , <EOL> filteredTypes : [ ] , <EOL> sortOpen : false , <EOL> } ; <EOL> } <EOL> public componentWillUnmount ( ) { <EOL> this . isComponentMounted = false ; <EOL> this . debouncedFetch . cancel ( ) ; <EOL> } <EOL> public componentDidMount ( ) { <EOL> this . isComponentMounted = true ; <EOL> this . fetchItems ( ) ; <EOL> } <EOL> public render ( ) { <EOL> return ( < React . Fragment > { this . renderSearchBar ( ) } { this . renderListing ( ) } < / React . Fragment > ) ; } private getSavedObjectMetaDataMap ( ) { return this . props . savedObjectMetaData . reduce ( ( map , metaData ) = > ( { ... map , [ metaData . type ] : metaData } ) , { } ) ; } private getPageCount ( ) { return Math . ceil ( ( this . state . filteredTypes . length == = <NUM_LIT>   ? this . state . items . length : this . state . items . filter ( ( item ) = > this . state . filteredTypes . length == = <NUM_LIT> | | this . state . filteredTypes . includes ( item . type ) ) . length ) / this . state . perPage ) ; } private getPageOfItems = ( ) = > { const items = this . state . items . slice ( ) ; const { sortDirection } = this . state ; if ( sortDirection | |   ! this . state . query ) { items . sort ( ( { title : titleA } , { title : titleB } ) = > { let order = <NUM_LIT> ; if ( sortDirection == = '<STR_LIT>' ) { order = - <NUM_LIT> ; } return order * ( titleA | | '<STR_LIT>' ) . toLowerCase ( ) . localeCompare ( ( titleB | | '<STR_LIT>' ) . toLowerCase ( ) ) ; } ) ; } const startIndex = this . state . page * this . state . perPage ; const lastIndex = startIndex + this . state . perPage ; return items . filter ( ( item ) = > this . state . filteredTypes . length == = <NUM_LIT> | | this . state . filteredTypes . includes ( item . type ) ) . slice ( startIndex , lastIndex ) ; } ; private fetchItems = ( ) = > { this . setState ( { isFetchingItems : true , } , this . debouncedFetch . bind ( null , this . state . query ) ) ; } ; private getAvailableSavedObjectMetaData ( ) { const typesInItems = new Set < string > ( ) ; this . state . items . forEach ( ( item ) = > { typesInItems . add ( item . type ) ; } ) ; return this . props . savedObjectMetaData . filter ( ( metaData ) = > typesInItems . has ( metaData . type ) ) ; } private getSortOptions ( ) { const sortOptions = [ < EuiContextMenuItem key = "<STR_LIT>" icon = { this . state . sortDirection == = '<STR_LIT>' | | ( this . state . query == = '<STR_LIT>' & & this . state . sortDirection != = '<STR_LIT>' )   ? '<STR_LIT>' : '<STR_LIT>' } onClick = { ( ) = > { this . setState ( { sortDirection : '<STR_LIT>' , } ) ; } } > { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } < / EuiContextMenuItem > , < EuiContextMenuItem key = "<STR_LIT>" icon = { this . state . sortDirection == = '<STR_LIT>'   ? '<STR_LIT>' : '<STR_LIT>' } onClick = { ( ) = > { this . setState ( { sortDirection : '<STR_LIT>' , } ) ; } } > { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } < / EuiContextMenuItem > , ] ; if ( this . state . query ) { sortOptions . push ( < EuiContextMenuItem key = "<STR_LIT>" icon = {   ! this . state . sortDirection   ? '<STR_LIT>' : '<STR_LIT>' } onClick = { ( ) = > { this . setState ( { sortDirection : undefined , } ) ; } } > { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } < / EuiContextMenuItem > ) ; } return sortOptions ; } private renderSearchBar ( ) { const availableSavedObjectMetaData = this . getAvailableSavedObjectMetaData ( ) ; return ( < EuiFlexGroup gutterSize = "<STR_LIT>" > < EuiFlexItem grow = { true } > < EuiFieldSearch placeholder = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } aria - label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } fullWidth value = { this . state . query } onChange = { ( e ) = > { this . setState ( { query : e . target . value , } , this . fetchItems ) ; } } data - test - subj = "<STR_LIT>" isLoading = { this . state . isFetchingItems } / > < / EuiFlexItem > < EuiFlexItem grow = { false } > < EuiFilterGroup > < EuiPopover id = "<STR_LIT>" panelClassName = "<STR_LIT>" panelPaddingSize = "<STR_LIT>" isOpen = { this . state . sortOpen } closePopover = { ( ) = > this . setState ( { sortOpen : false } ) } button = { < EuiFilterButton onClick = { ( ) = > this . setState ( ( { sortOpen } ) = > ( { sortOpen :   ! sortOpen , } ) ) } iconType = "<STR_LIT>" isSelected = { this . state . sortOpen } data - test - subj = "<STR_LIT>" > { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } < / EuiFilterButton > } > < EuiContextMenuPanel watchedItemProps = { [ '<STR_LIT>' , '<STR_LIT>' ] } items = { this . getSortOptions ( ) } / > < / EuiPopover > { this . props . showFilter & & ( < EuiPopover id = "<STR_LIT>" panelClassName = "<STR_LIT>" panelPaddingSize = "<STR_LIT>" isOpen = { this . state . filterOpen } closePopover = { ( ) = > this . setState ( { filterOpen : false } ) } button = { < EuiFilterButton onClick = { ( ) = > this . setState ( ( { filterOpen } ) = > ( { filterOpen :   ! filterOpen , } ) ) } iconType = "<STR_LIT>" data - test - subj = "<STR_LIT>" isSelected = { this . state . filterOpen } numFilters = { this . props . savedObjectMetaData . length } hasActiveFilters = { this . state . filteredTypes . length > <NUM_LIT> } numActiveFilters = { this . state . filteredTypes . length } > { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } < / EuiFilterButton > } > < EuiContextMenuPanel watchedItemProps = { [ '<STR_LIT>' , '<STR_LIT>' ] } items = { this . props . savedObjectMetaData . map ( ( metaData ) = > ( < EuiContextMenuItem key = { metaData . type } disabled = {   ! availableSavedObjectMetaData . includes ( metaData ) } icon = { this . state . filteredTypes . includes ( metaData . type )   ? '<STR_LIT>' : '<STR_LIT>' } data - test - subj = {   ` savedObjectFinderFilter - $ { metaData . type } ` } onClick = { ( ) = > { this . setState ( ( { filteredTypes } ) = > ( { filteredTypes : filteredTypes . includes ( metaData . type )   ? filteredTypes . filter ( ( t ) = > t != = metaData . type ) : [ ... filteredTypes , metaData . type ] , page : <NUM_LIT> , } ) ) ; } } > { metaData . name } < / EuiContextMenuItem > ) ) } / > < / EuiPopover > ) } < / EuiFilterGroup > < / EuiFlexItem > { this . props . children   ? < EuiFlexItem grow = { false } > { this . props . children } < / EuiFlexItem > : null } < / EuiFlexGroup > ) ; } private renderListing ( ) { const items = this . state . items . length == = <NUM_LIT>   ? [ ] : this . getPageOfItems ( ) ; const { onChoose , savedObjectMetaData } = this . props ; return ( < > { this . state . isFetchingItems & & this . state . items . length == = <NUM_LIT> & & ( < EuiFlexGroup justifyContent = "<STR_LIT>" > < EuiFlexItem grow = { false } > < EuiSpacer / > < EuiLoadingSpinner data - test - subj = "<STR_LIT>" / > < / EuiFlexItem > < / EuiFlexGroup > ) } { items . length > <NUM_LIT>   ? ( < EuiListGroup data - test - subj = "<STR_LIT>" maxWidth = { false } > { items . map ( ( item ) = > { const currentSavedObjectMetaData = savedObjectMetaData . find ( ( metaData ) = > metaData . type == = item . type )   ! ; const fullName = currentSavedObjectMetaData . getTooltipForSavedObject   ? currentSavedObjectMetaData . getTooltipForSavedObject ( item . savedObject ) :   ` $ { item . title } ( $ { currentSavedObjectMetaData   ! . name } ) ` ; const iconType = ( currentSavedObjectMetaData | | ( { getIconForSavedObject : ( ) = > '<STR_LIT>' , } as Pick < SavedObjectMetaData < { title : string ; } > , '<STR_LIT>' > ) ) . getIconForSavedObject ( item . savedObject ) ; return ( < EuiListGroupItem key = { item . id } iconType = { iconType } label = { item . title } onClick = { onChoose   ? ( ) = > { onChoose ( item . id , item . type , fullName , item . savedObject ) ; } : undefined } title = { fullName } data - test - subj = {   ` savedObjectTitle $ { ( item . title | | '<STR_LIT>' ) . split ( '<STR_LIT>' ) . join ( '<STR_LIT>' ) } ` } / > ) ; } ) } < / EuiListGroup > ) : ( ! this . state . isFetchingItems & & < EuiEmptyPrompt body = { this . props . noItemsMessage } / > ) } { this . getPageCount ( ) > <NUM_LIT> & & ( this . props . fixedPageSize   ? ( < EuiPagination activePage = { this . state . page } pageCount = { this . getPageCount ( ) } onPageClick = { ( page ) = > { this . setState ( { page , } ) ; } } / > ) : ( < EuiTablePagination activePage = { this . state . page } pageCount = { this . getPageCount ( ) } onChangePage = { ( page ) = > { this . setState ( { page , } ) ; } } onChangeItemsPerPage = { ( perPage ) = > { this . setState ( { perPage , } ) ; } } itemsPerPage = { this . state . perPage } itemsPerPageOptions = { [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] } / > ) ) } < / > ) ; } } const getSavedObjectFinder = ( savedObject , uiSettings ) = > { return ( props ) = > ( < SavedObjectFinderUi { ... props } savedObjects = { savedObject } uiSettings = { uiSettings } / > ) ; } ; export { getSavedObjectFinder , SavedObjectFinderUi } ; </s>
<s> import { <EOL> get , <EOL> isPlainObject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter , <EOL> FilterMeta <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> IFieldType <EOL> } from '<STR_LIT>' ; <EOL> export type PhraseFilterMeta = FilterMeta & { <EOL> params   ? : { <EOL> query : string ; <EOL> } ; field   ? : any ; index   ? : any ; <EOL> } ; <EOL> export type PhraseFilter = Filter & { <EOL> meta : PhraseFilterMeta ; script   ? : { <EOL> script : { <EOL> source   ? : any ; lang   ? : string ; params : any ; <EOL> } ; <EOL> } ; <EOL> } ; <EOL> type PhraseFilterValue = string | number | boolean ; <EOL> export const isPhraseFilter = ( filter ) : filter is PhraseFilter = > { <EOL> const isMatchPhraseQuery = filter & & filter . query & & filter . query . match_phrase ; <EOL> const isDeprecatedMatchPhraseQuery = filter & & filter . query & & filter . query . match & & Object . values ( filter . query . match ) . find ( ( params ) = > params . type == = '<STR_LIT>' ) ; <EOL> return Boolean ( isMatchPhraseQuery | | isDeprecatedMatchPhraseQuery ) ; <EOL> } ; <EOL> export const isScriptedPhraseFilter = ( filter ) : filter is PhraseFilter = > Boolean ( get ( filter , '<STR_LIT>' ) ) ; <EOL> export const getPhraseFilterField = ( filter ) = > { <EOL> const queryConfig = filter . query . match_phrase | | filter . query . match ; <EOL> return Object . keys ( queryConfig ) [ <NUM_LIT> ] ; <EOL> } ; <EOL> export const getPhraseFilterValue = ( filter ) : PhraseFilterValue = > { <EOL> const queryConfig = filter . query . match_phrase | | filter . query . match ; <EOL> const queryValue = Object . values ( queryConfig ) [ <NUM_LIT> ] as any ; <EOL> return isPlainObject ( queryValue )   ? queryValue . query : queryValue ; <EOL> } ; <EOL> export const buildPhraseFilter = ( field , value , indexPattern ) : PhraseFilter = > { <EOL> const convertedValue = getConvertedValueForField ( field , value ) ; <EOL> if ( field . scripted ) { <EOL> return { <EOL> meta : { <EOL> index : indexPattern . id , <EOL> field : field . name <EOL> } <EOL> as PhraseFilterMeta , <EOL> script : getPhraseScript ( field , value ) , <EOL> } ; <EOL> } else { <EOL> return { <EOL> meta : { <EOL> index : indexPattern . id <EOL> } , <EOL> query : { <EOL> match_phrase : { <EOL> [ field . name ] : convertedValue , <EOL> } , <EOL> } , <EOL> } <EOL> as PhraseFilter ; <EOL> } <EOL> } ; <EOL> export const getPhraseScript = ( field , value ) = > { <EOL> const convertedValue = getConvertedValueForField ( field , value ) ; <EOL> const script = buildInlineScriptForPhraseFilter ( field ) ; <EOL> return { <EOL> script : { <EOL> source : script , <EOL> lang : field . lang , <EOL> params : { <EOL> value : convertedValue , <EOL> } , <EOL> } , <EOL> } ; <EOL> } ; <EOL> export const getConvertedValueForField = ( field , value ) = > { <EOL> if ( typeof value != = '<STR_LIT>' & & field . type == = '<STR_LIT>' ) { <EOL> if ( [ <NUM_LIT> , '<STR_LIT>' ] . includes ( value ) ) { <EOL> return true ; <EOL> } else if ( [ <NUM_LIT> , '<STR_LIT>' ] . includes ( value ) ) { <EOL> return false ; <EOL> } else { <EOL> throw new Error ( ` $ { value } is not a valid boolean value for boolean field   $ { field . name } ` ) ; <EOL> } <EOL> } <EOL> return value ; <EOL> } ; <EOL> param { <EOL> object <EOL> } <EOL> scriptedField returns { <EOL> string <EOL> } <EOL> export const buildInlineScriptForPhraseFilter = ( scriptedField ) = > { <EOL> if ( scriptedField . lang == = '<STR_LIT>' ) { <EOL> return ( ` boolean compare ( Supplier s , def v ) { return s . get ( ) == v ; } ` +   ` compare ( ( ) -> {   $ { scriptedField . script } } , params . value ) ; ` ) ; <EOL> } else { <EOL> return   ` ( $ { scriptedField . script } ) == value ` ; <EOL> } <EOL> } ; </s>
<s> import { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getResponseAggConfigClass , <EOL> IResponseAggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsStdDeviation extends BaseAggParams { <EOL> field : string ; <EOL> } <EOL> interface ValProp { <EOL> valProp : string [ ] ; title : string ; <EOL> } <EOL> export interface IStdDevAggConfig extends IResponseAggConfig { <EOL> keyedDetails : ( customLabel : string , fieldDisplayName   ? : string ) = > Record < string , <EOL> ValProp > ; valProp : ( ) = > string [ ] ; <EOL> } <EOL> const responseAggConfigProps = { <EOL> valProp ( this ) { <EOL> const customLabel = this . getParam ( '<STR_LIT>' ) ; <EOL> const details = this . keyedDetails ( customLabel ) [ this . key ] ; <EOL> return details . valProp ; <EOL> } , <EOL> makeLabel ( this ) { <EOL> const fieldDisplayName = this . getFieldDisplayName ( ) ; <EOL> const customLabel = this . getParam ( '<STR_LIT>' ) ; <EOL> const details = this . keyedDetails ( customLabel , fieldDisplayName ) ; <EOL> return get ( details , [ this . key , '<STR_LIT>' ] ) ; <EOL> } , <EOL> keyedDetails ( this , customLabel , fieldDisplayName ) { <EOL> const label = customLabel | | i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> fieldDisplayName <EOL> } , <EOL> } ) ; <EOL> return { <EOL> std_lower : { <EOL> valProp : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> label <EOL> } , <EOL> } ) , <EOL> } , <EOL> std_upper : { <EOL> valProp : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> label <EOL> } , <EOL> } ) , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ; <EOL> export const getStdDeviationMetricAgg = ( ) = > { <EOL> return new MetricAggType < IStdDevAggConfig > ( { <EOL> name : METRIC_TYPES . STD_DEV , <EOL> dslName : '<STR_LIT>' , <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> makeLabel ( agg ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> field : agg . getFieldDisplayName ( ) <EOL> } , <EOL> } ) ; <EOL> } , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : OSD_FIELD_TYPES . NUMBER , <EOL> } , ] , <EOL> getResponseAggs ( agg ) { <EOL> const ValueAggConfig = getResponseAggConfigClass ( agg , responseAggConfigProps ) ; <EOL> return [ new ValueAggConfig ( '<STR_LIT>' ) , new ValueAggConfig ( '<STR_LIT>' ) ] ; <EOL> } , <EOL> getValue ( agg , bucket ) { <EOL> return get ( bucket [ agg . parentId ] , agg . valProp ( ) ) ; <EOL> } , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> getPreference <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SearchStrategyProvider , <EOL> SearchStrategySearchParams <EOL> } from '<STR_LIT>' ; <EOL> export const defaultSearchStrategy = { <EOL> id : '<STR_LIT>' , <EOL> search : ( params ) = > { <EOL> return msearch ( params ) ; <EOL> } , <EOL> } ; <EOL> function msearch ( { <EOL> searchRequests , <EOL> getConfig , <EOL> legacy <EOL> } ) { <EOL> const { <EOL> callMsearch , <EOL> loadingCount $ <EOL> } = legacy ; <EOL> const requests = searchRequests . map ( ( { <EOL> index , <EOL> body <EOL> } ) = > { <EOL> return { <EOL> header : { <EOL> index : index . title | | index , <EOL> preference : getPreference ( getConfig ) , <EOL> } , <EOL> body , <EOL> } ; <EOL> } ) ; <EOL> const abortController = new AbortController ( ) ; <EOL> let resolved = false ; <EOL> loadingCount $ . next ( loadingCount $ . getValue ( ) + <NUM_LIT> ) ; <EOL> const cleanup = ( ) = > { <EOL> if ( ! resolved ) { <EOL> resolved = true ; <EOL> loadingCount $ . next ( loadingCount $ . getValue ( ) - <NUM_LIT> ) ; <EOL> loadingCount $ . complete ( ) ; <EOL> } <EOL> } ; <EOL> const searching = callMsearch ( { <EOL> body : { <EOL> searches : requests <EOL> } , <EOL> signal : abortController . signal , <EOL> } ) . then ( ( res ) = > res ? . body ? . responses ) . finally ( ( ) = > cleanup ( ) ) ; <EOL> return { <EOL> abort : ( ) = > { <EOL> abortController . abort ( ) ; <EOL> cleanup ( ) ; <EOL> } , <EOL> searching , <EOL> } ; <EOL> } </s>
<s> import React , { <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Link <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BsKanban <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Heading <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DialogConfirm <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Board as BoardType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> useTheme <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> api <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> type BrowseBoardItemProps = { <EOL> board : BoardType ; <EOL> } ; <EOL> export const BrowseBoardItem = ( { <EOL> board <EOL> } ) = > { <EOL> const [ removed , setRemoved ] = useState ( false ) ; <EOL> const [ confirmRemove , setConfirmRemove ] = useState ( false ) ; <EOL> const theme = useTheme ( ) ; <EOL> function remove ( ) { <EOL> api . boards . removeBoard ( board . id ) . then ( ( ) = > { <EOL> setRemoved ( true ) ; <EOL> } ) ; <EOL> } <EOL> if ( removed ) return null ; <EOL> return ( < > { confirmRemove & & ( < DialogConfirm onConfirm = { remove } onCancel = { ( ) = > setConfirmRemove ( false ) } aria - label = "<STR_LIT>" > Are you sure you want to remove this Board   ? < / DialogConfirm > ) } < div className = "<STR_LIT>" > < div className = "<STR_LIT>" style = { { fontSize : '<STR_LIT>' } } > < BsKanban className = "<STR_LIT>" color = { theme . colors . purple } / > < / div > < div className = "<STR_LIT>" > < Heading > < Link to = {   ` / boards / $ { board . id } ` } > { board . name | | < em > Board Name < / em > } < / Link > < / Heading > < div className = "<STR_LIT>" > < span > Tasks : < strong > <NUM_LIT> < / strong > < / span > < span > Total Time : < strong > <NUM_LIT> h < / strong > < / span > < span > Time Remaining : < strong > <NUM_LIT> h < / strong > < / span > < / div > < / div > < div > < button className = "<STR_LIT>" onClick = { ( ) = > setConfirmRemove ( true ) } > Remove < / button > < / div > < / div > < / > ) ; } ; </s>
<s> import '<STR_LIT>' ; <EOL> import React , { <EOL> useCallback , <EOL> useEffect , <EOL> useState , <EOL> useMemo <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiButtonIcon , <EOL> EuiTitle , <EOL> EuiSpacer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> sortBy <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage , <EOL> I18nProvider <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DiscoverField <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DiscoverIndexPattern <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DiscoverFieldSearch <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternAttributes <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SavedObject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FIELDS_LIMIT_SETTING <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> groupFields <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternField , <EOL> IndexPattern , <EOL> UI_SETTINGS <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getDetails <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getDefaultFieldFilter , <EOL> setFieldFilterProp <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getIndexPatternFieldList <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getServices <EOL> } from '<STR_LIT>' ; <EOL> export interface DiscoverSidebarProps { <EOL> / ** <EOL> * the selected columns displayed in the doc table in discover <EOL> * / <EOL> columns : string [ ] ; <EOL> / ** <EOL> * a statistics of the distribution of fields in the given hits <EOL> * / <EOL> fieldCounts : Record < string , <EOL> number > ; <EOL> / ** <EOL> * hits fetched from OpenSearch , displayed in the doc table <EOL> * / <EOL> hits : Array < Record < string , <EOL> unknown > > ; <EOL> / ** <EOL> * List of available index patterns <EOL> * / <EOL> indexPatternList : Array < SavedObject < IndexPatternAttributes > > ; <EOL> / ** <EOL> * Callback function when selecting a field <EOL> * / <EOL> onAddField : ( fieldName : string ) = > void ; <EOL> / ** <EOL> * Callback function when adding a filter from sidebar <EOL> * / <EOL> onAddFilter : ( field : IndexPatternField | string , value : string , type : '<STR_LIT>' | '<STR_LIT>' ) = > void ; param fieldName onRemoveField : ( fieldName : string ) = > void ; <EOL> / ** <EOL> * Currently selected index pattern <EOL> * / <EOL> selectedIndexPattern   ? : IndexPattern ; <EOL> / ** <EOL> * Callback function to select another index pattern <EOL> * / <EOL> setIndexPattern : ( id : string ) = > void ; <EOL> } <EOL> export function DiscoverSidebar ( { <EOL> columns , <EOL> fieldCounts , <EOL> hits , <EOL> indexPatternList , <EOL> onAddField , <EOL> onAddFilter , <EOL> onRemoveField , <EOL> selectedIndexPattern , <EOL> setIndexPattern , <EOL> } ) { <EOL> const [ showFields , setShowFields ] = useState ( false ) ; <EOL> const [ fields , setFields ] = useState < IndexPatternField [ ] | null > ( null ) ; <EOL> const [ fieldFilterState , setFieldFilterState ] = useState ( getDefaultFieldFilter ( ) ) ; <EOL> const services = useMemo ( ( ) = > getServices ( ) , [ ] ) ; <EOL> useEffect ( ( ) = > { <EOL> const newFields = getIndexPatternFieldList ( selectedIndexPattern , fieldCounts ) ; <EOL> setFields ( newFields ) ; <EOL> } , [ selectedIndexPattern , fieldCounts , hits , services ] ) ; <EOL> const onChangeFieldSearch = useCallback ( ( field , value ) = > { <EOL> const newState = setFieldFilterProp ( fieldFilterState , field , value ) ; <EOL> setFieldFilterState ( newState ) ; <EOL> } , [ fieldFilterState ] ) ; <EOL> const getDetailsByField = useCallback ( ( ipField ) = > getDetails ( ipField , hits , columns , selectedIndexPattern ) , [ hits , columns , selectedIndexPattern ] ) ; <EOL> const popularLimit = services . uiSettings . get ( FIELDS_LIMIT_SETTING ) ; <EOL> const useShortDots = services . uiSettings . get ( UI_SETTINGS . SHORT_DOTS_ENABLE ) ; <EOL> const { <EOL> selected : selectedFields , <EOL> popular : popularFields , <EOL> unpopular : unpopularFields , <EOL> } = useMemo ( ( ) = > groupFields ( fields , columns , popularLimit , fieldCounts , fieldFilterState ) , [ fields , columns , popularLimit , fieldCounts , fieldFilterState , ] ) ; <EOL> const fieldTypes = useMemo ( ( ) = > { <EOL> const result = [ '<STR_LIT>' ] ; <EOL> if ( Array . isArray ( fields ) ) { <EOL> for ( const field of fields ) { <EOL> if ( result . indexOf ( field . type ) == = - <NUM_LIT> ) { <EOL> result . push ( field . type ) ; <EOL> } <EOL> } <EOL> } <EOL> return result ; <EOL> } , [ fields ] ) ; <EOL> if ( ! selectedIndexPattern | |   ! fields ) { <EOL> return null ; <EOL> } <EOL> return ( < I18nProvider > < section className = "<STR_LIT>" aria - label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } > < DiscoverIndexPattern selectedIndexPattern = { selectedIndexPattern } setIndexPattern = { setIndexPattern } indexPatternList = { sortBy ( indexPatternList , ( o ) = > o . attributes . title ) } / > < div className = "<STR_LIT>" > < form > < DiscoverFieldSearch onChange = { onChangeFieldSearch } value = { fieldFilterState . name } types = { fieldTypes } / > < / form > < / div > < div className = "<STR_LIT>" > { fields . length > <NUM_LIT> & & ( < > < EuiTitle size = "<STR_LIT>" id = "<STR_LIT>" > < h3 > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / h3 > < / EuiTitle > < EuiSpacer size = "<STR_LIT>" / > < ul className = "<STR_LIT>" aria - labelledby = "<STR_LIT>" data - test - subj = {   ` fieldList - selected ` } > { selectedFields . map ( ( field ) = > { return ( < li key = {   ` field $ { field . name } ` } data - attr - field = { field . name } className = "<STR_LIT>" > < DiscoverField field = { field } indexPattern = { selectedIndexPattern } onAddField = { onAddField } onRemoveField = { onRemoveField } onAddFilter = { onAddFilter } getDetails = { getDetailsByField } selected = { true } useShortDots = { useShortDots } / > < / li > ) ; } ) } < / ul > < div className = "<STR_LIT>" > < EuiTitle size = "<STR_LIT>" id = "<STR_LIT>" className = "<STR_LIT>" > < h3 > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / h3 > < / EuiTitle > < div className = "<STR_LIT>" > < EuiButtonIcon className = { '<STR_LIT>' } iconType = { showFields   ? '<STR_LIT>' : '<STR_LIT>' } onClick = { ( ) = > setShowFields (   ! showFields ) } aria - label = { showFields   ? i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } / > < / div > < / div > < / > ) } { popularFields . length > <NUM_LIT> & & ( < div > < EuiTitle size = "<STR_LIT>" className = {   ` dscFieldListHeader   $ {   ! showFields   ? '<STR_LIT>' : '<STR_LIT>' } ` } > < h4 style = { { fontWeight : '<STR_LIT>' } } id = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / h4 > < / EuiTitle > < ul className = {   ` dscFieldList dscFieldList - - popular   $ {   ! showFields   ? '<STR_LIT>' : '<STR_LIT>' } ` } aria - labelledby = "<STR_LIT>" data - test - subj = {   ` fieldList - popular ` } > { popularFields . map ( ( field ) = > { return ( < li key = {   ` field $ { field . name } ` } data - attr - field = { field . name } className = "<STR_LIT>" > < DiscoverField field = { field } indexPattern = { selectedIndexPattern } onAddField = { onAddField } onRemoveField = { onRemoveField } onAddFilter = { onAddFilter } getDetails = { getDetailsByField } useShortDots = { useShortDots } / > < / li > ) ; } ) } < / ul > < / div > ) } < ul className = {   ` dscFieldList dscFieldList - - unpopular   $ {   ! showFields   ? '<STR_LIT>' : '<STR_LIT>' } ` } aria - labelledby = "<STR_LIT>" data - test - subj = {   ` fieldList - unpopular ` } > { unpopularFields . map ( ( field ) = > { return ( < li key = {   ` field $ { field . name } ` } data - attr - field = { field . name } className = "<STR_LIT>" > < DiscoverField field = { field } indexPattern = { selectedIndexPattern } onAddField = { onAddField } onRemoveField = { onRemoveField } onAddFilter = { onAddFilter } getDetails = { getDetailsByField } useShortDots = { useShortDots } / > < / li > ) ; } ) } < / ul > < / div > < / section > < / I18nProvider > ) ; } </s>
<s> import { <EOL> PluginServiceProviders , <EOL> PluginServiceProvider , <EOL> PluginServiceRegistry , <EOL> KibanaPluginServiceParams , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomIntegrationsServices <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CustomIntegrationsStartDependencies <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> findServiceFactory <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> platformServiceFactory <EOL> } from '<STR_LIT>' ; <EOL> export { <EOL> findServiceFactory <EOL> } <EOL> from '<STR_LIT>' ; <EOL> export { <EOL> platformServiceFactory <EOL> } <EOL> from '<STR_LIT>' ; <EOL> see <EOL> export const pluginServiceProviders = { <EOL> find : new PluginServiceProvider ( findServiceFactory ) , <EOL> platform : new PluginServiceProvider ( platformServiceFactory ) , <EOL> } ; <EOL> see <EOL> export const pluginServiceRegistry = new PluginServiceRegistry < CustomIntegrationsServices , <EOL> KibanaPluginServiceParams < CustomIntegrationsStartDependencies > > ( pluginServiceProviders ) ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IHttpResponse <EOL> } from '<STR_LIT>' ; <EOL> export type AngularHttpError = IHttpResponse < { <EOL> message : string ; <EOL> } > ; <EOL> export function isAngularHttpError ( error ) { <EOL> return ( error & & typeof error . status == = '<STR_LIT>' & & typeof error . statusText == = '<STR_LIT>' & & error . data & & typeof error . data . message == = '<STR_LIT>' ) ; <EOL> } <EOL> export function formatAngularHttpError ( error ) { <EOL> if ( error . status == = - <NUM_LIT> ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' + '<STR_LIT>' + '<STR_LIT>' , <EOL> } ) ; <EOL> } <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> errStatus : error . status , <EOL> errStatusText : error . statusText , <EOL> errMessage : error . data . message , <EOL> } , <EOL> } ) ; <EOL> } </s>
<s> import { <EOL> h <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Layout <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> CodeBlock <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Block <EOL> } from "<STR_LIT>" ; <EOL> export function Code ( { <EOL> code , <EOL> language <EOL> } ) { <EOL> return ( < Layout > < Block > < CodeBlock code = { code } language = { language } / > < / Block > < / Layout > ) ; } </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AngularFireAuth <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Router <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Actions , <EOL> Effect , <EOL> ofType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AuthDataProxy <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> filterWith <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RouterState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> User as FirebaseUser <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> from <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map , <EOL> switchMap , <EOL> tap <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> authIn , <EOL> authOut , <EOL> signOutAuthModal , <EOL> signOutSidenav , <EOL> signOutSuccess <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> State <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getAuthenticated <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class Effects { <EOL> @ Effect ( ) auth $ = this . afa . authState . pipe ( map ( ( firebaseUser ) = > { <EOL> if ( ! ! firebaseUser ) { <EOL> const authData = AuthDataProxy . Create ( firebaseUser . toJSON ( ) ) ; <EOL> return authIn ( { <EOL> authData <EOL> } ) ; <EOL> } <EOL> return authOut ( ) ; <EOL> } ) ) ; <EOL> @ Effect ( ) signOut $ = this . actions $ . pipe ( ofType ( signOutAuthModal , signOutSidenav ) , filterWith ( this . store . select ( getAuthenticated ) , ( authenticated ) = > authenticated ) , switchMap ( ( ) = > from ( this . afa . auth . signOut ( ) ) ) , map ( ( ) = > signOutSuccess ( ) ) ) ; <EOL> @ Effect ( { <EOL> dispatch : false <EOL> } ) redirectOnSingOutIfGuarded $ = this . actions $ . pipe ( ofType ( signOutSuccess ) , filterWith ( this . store . select ( RouterState . getGuarded ) , ( guarded ) = > guarded ) , tap ( ( ) = > this . router . navigate ( [ '<STR_LIT>' ] ) ) ) ; <EOL> constructor ( private actions $ , private afa , private router , private store ) { } <EOL> } </s>
<s> import { <EOL> ChromeStart , <EOL> DocLinksStart , <EOL> HttpStart , <EOL> NotificationsSetup , <EOL> OverlayStart , <EOL> SavedObjectsClientContract , <EOL> IUiSettingsClient , <EOL> ApplicationStart , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UiStatsMetricType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TelemetryPluginStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UrlForwardingStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TutorialService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FeatureCatalogueRegistry <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EnvironmentService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConfigSchema <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HomePluginBranding <EOL> } from '<STR_LIT>' ; <EOL> export interface HomeOpenSearchDashboardsServices { <EOL> indexPatternService : any ; opensearchDashboardsVersion : string ; chrome : ChromeStart ; application : ApplicationStart ; uiSettings : IUiSettingsClient ; urlForwarding : UrlForwardingStart ; homeConfig : ConfigSchema ; featureCatalogue : FeatureCatalogueRegistry ; http : HttpStart ; savedObjectsClient : SavedObjectsClientContract ; toastNotifications : NotificationsSetup [ '<STR_LIT>' ] ; banners : OverlayStart [ '<STR_LIT>' ] ; trackUiMetric : ( type : UiStatsMetricType , eventNames : string | string [ ] , count   ? : number ) = > void ; getBasePath : ( ) = > string ; docLinks : DocLinksStart ; addBasePath : ( url : string ) = > string ; environmentService : EnvironmentService ; telemetry   ? : TelemetryPluginStart ; tutorialService : TutorialService ; injectedMetadata : { <EOL> getInjectedVar : ( name : string , defaultValue   ? : any ) = > unknown ; getBranding : ( ) = > HomePluginBranding ; <EOL> } ; <EOL> } <EOL> let services = null ; <EOL> export function setServices ( newServices ) { <EOL> services = newServices ; <EOL> } <EOL> export function getServices ( ) { <EOL> if ( ! services ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> return services ; <EOL> } </s>
<s> import debug from "<STR_LIT>" ; <EOL> import RootStore from "<STR_LIT>" ; <EOL> const log = debug ( "<STR_LIT>" ) ; <EOL> export const toggleReaction = ( { <EOL> ui <EOL> } ) = > ( ) = > { <EOL> log ( ` toggleReaction ( ) ->   $ {   ! ui . isReactionOpen } ` ) ; <EOL> ui . isReactionOpen =   ! ui . isReactionOpen ; <EOL> } ; <EOL> export const sendReaction = ( { <EOL> room , <EOL> client <EOL> } ) = > ( reaction ) = > { <EOL> log ( "<STR_LIT>" , reaction ) ; <EOL> room . addReaction ( client . displayName , reaction ) ; <EOL> } ; </s>
<s> import { <EOL> assert <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> describe , <EOL> it <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> metaesEval , <EOL> uncps <EOL> } from "<STR_LIT>" ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> it ( "<STR_LIT>" , ( ) = > { <EOL> let acceptedArgs ; <EOL> function foo ( ... args ) { <EOL> acceptedArgs = args ; <EOL> } <EOL> metaesEval ( { <EOL> type : "<STR_LIT>" , <EOL> fn : foo , <EOL> args : [ <NUM_LIT> , <NUM_LIT> ] <EOL> } , undefined , console . error ) ; <EOL> assert . deepEqual ( acceptedArgs , [ <NUM_LIT> , <NUM_LIT> ] ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , ( ) = > { <EOL> let acceptedArgs ; <EOL> let object = { <EOL> method ( ... args ) { <EOL> acceptedArgs = args ; <EOL> } <EOL> } ; <EOL> metaesEval ( { <EOL> type : "<STR_LIT>" , <EOL> fn : object . method , <EOL> thisValue : object , <EOL> args : [ <NUM_LIT> , <NUM_LIT> ] <EOL> } , undefined , console . error ) ; <EOL> assert . deepEqual ( acceptedArgs , [ <NUM_LIT> , <NUM_LIT> ] ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> [ { } , undefined , <NUM_LIT> , false , Symbol ( ) , [ "<STR_LIT>" ] ] . forEach ( ( value ) = > metaesEval ( value , ( result ) = > assert . equal ( result , value ) , ( e ) = > { <EOL> throw e ; <EOL> } ) ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> metaesEval ( { <EOL> type : "<STR_LIT>" , <EOL> name : "<STR_LIT>" <EOL> } , ( result ) = > assert . equal ( result , <NUM_LIT> ) , ( e ) = > { <EOL> throw e ; <EOL> } , { <EOL> a : <NUM_LIT> <EOL> } ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> assert . throws ( function ( ) { <EOL> metaesEval ( { <EOL> type : "<STR_LIT>" <EOL> } , ( result ) = > assert . equal ( result , <NUM_LIT> ) , ( e ) = > { <EOL> assert . equal ( e . message ,   ` "<STR_LIT>" node type interpreter is not defined yet . ` ) ; <EOL> throw e ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> assert . throws ( function ( ) { <EOL> metaesEval ( { <EOL> scriptId : <NUM_LIT> , <EOL> source : { } , <EOL> ast : { <EOL> type : "<STR_LIT>" <EOL> } <EOL> } , console . log , ( e ) = > { <EOL> assert . equal ( e . message ,   ` "<STR_LIT>" node type interpreter is not defined yet . ` ) ; <EOL> throw e ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , function ( ) { <EOL> assert . throws ( function ( ) { <EOL> metaesEval ( { <EOL> scriptId : <NUM_LIT> , <EOL> source : { } , <EOL> ast : null <EOL> } , console . log , ( e ) = > { <EOL> throw e ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( "<STR_LIT>" , function ( ) { <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> assert . deepEqual ( uncps ( metaesEval ) ( "<STR_LIT>" ) , [ , ] ) ; <EOL> assert . deepEqual ( uncps ( metaesEval ) ( "<STR_LIT>" ) , [ <NUM_LIT> , , ... [ <NUM_LIT> , , <NUM_LIT> ] , , <NUM_LIT> ] ) ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> ChangeDetectionStrategy , <EOL> Component , <EOL> Input , <EOL> OnDestroy , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import Debug = require ( '<STR_LIT>' ) ; <EOL> import { <EOL> Attachment <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ModalService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AppState <EOL> } from '<STR_LIT>' ; <EOL> const debug = Debug ( '<STR_LIT>' ) ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class AttachmentLightboxComponent implements OnInit , OnDestroy { <EOL> @ Input ( ) attachment ! : Attachment ; <EOL> constructor ( private modal , private store $ ) { } <EOL> ngOnInit ( ) { <EOL> debug ( ` init with ` , this . attachment ) ; <EOL> } <EOL> closeModal ( ev   ? ) { <EOL> if ( ev ) { <EOL> ev . preventDefault ( ) ; <EOL> ev . stopPropagation ( ) ; <EOL> } <EOL> this . modal . close ( ) ; <EOL> } <EOL> ngOnDestroy ( ) { <EOL> debug ( '<STR_LIT>' ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Component , <EOL> OnInit , <EOL> OnDestroy , <EOL> Input <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ICourse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ILecture <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DuplicationService , <EOL> ExportService , <EOL> LectureService , <EOL> NotificationService , <EOL> UnitService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ShowProgressService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DialogService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UserService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SnackBarService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IUnit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DragulaService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SaveFileService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ActivatedRoute , <EOL> Router <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataSharingService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Subject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UnitFactoryService <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] <EOL> } ) export class LectureEditComponent implements OnInit , OnDestroy { <EOL> @ Input ( ) lecture : ILecture ; <EOL> @ Input ( ) course : ICourse ; <EOL> onCloseAllForms : Subject < void > ; <EOL> onReloadCourse : Subject < Function > ; <EOL> constructor ( private route , private lectureService , private unitService , private showProgress , private snackBar , private dialogService , private dragulaService , private duplicationService , private exportService , private saveFileService , public userService , private dataSharingService , private router , private notificationService , private unitFactoryService ) { } <EOL> ngOnInit ( ) { <EOL> this . onCloseAllForms = this . dataSharingService . getDataForKey ( '<STR_LIT>' ) ; <EOL> this . onCloseAllForms . asObservable ( ) . subscribe ( ( ) = > this . closeAllForms ( ) ) ; <EOL> this . onReloadCourse = this . dataSharingService . getDataForKey ( '<STR_LIT>' ) ; <EOL> } <EOL> ngOnDestroy ( ) { } <EOL> isDraggingUnit ( ) { <EOL> return this . dragulaService . find ( '<STR_LIT>' ) . drake . dragging ; <EOL> } <EOL> async duplicateLecture ( lecture ) { <EOL> try { <EOL> const duplicateLecture = await this . duplicationService . duplicateLecture ( lecture , this . course . _id ) ; <EOL> this . snackBar . open ( '<STR_LIT>' ) ; <EOL> await this . reloadCourse ( ) ; <EOL> this . navigateToLecture ( duplicateLecture . _id ) ; <EOL> } catch ( err ) { <EOL> this . snackBar . open ( err . error . message ) ; <EOL> } <EOL> } <EOL> async duplicateUnit ( unit ) { <EOL> try { <EOL> const duplicateUnit = await this . duplicationService . duplicateUnit ( unit , this . lecture . _id ) ; <EOL> this . snackBar . open ( '<STR_LIT>' ) ; <EOL> await this . reloadCourse ( ) ; <EOL> this . navigateToUnitEdit ( duplicateUnit . _id ) ; <EOL> } catch ( err ) { <EOL> this . snackBar . open ( err . error . message ) ; <EOL> } <EOL> } <EOL> async exportLecture ( lecture ) { <EOL> try { <EOL> const lectureJSON = await this . exportService . exportLecture ( lecture ) ; <EOL> this . saveFileService . save ( lecture . name , JSON . stringify ( lectureJSON , null , <NUM_LIT> ) ) ; <EOL> } catch ( err ) { <EOL> this . snackBar . open ( '<STR_LIT>' + err . error . message ) ; <EOL> } <EOL> } <EOL> updateLecture ( lecture ) { <EOL> this . showProgress . toggleLoadingGlobal ( true ) ; <EOL> this . lectureService . updateItem ( lecture ) . then ( ( ) = > { <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , false ) ; <EOL> this . notificationService . createItem ( { <EOL> targetId : lecture . _id , <EOL> targetType : '<STR_LIT>' , <EOL> text : '<STR_LIT>' + this . course . name + '<STR_LIT>' <EOL> } ) . catch ( console . error ) ; <EOL> } ) . catch ( console . error ) . then ( ( ) = > this . showProgress . toggleLoadingGlobal ( false ) ) ; <EOL> } <EOL> deleteUnit ( unit ) { <EOL> this . dialogService . confirmDelete ( '<STR_LIT>' , unit . __t ) . subscribe ( async ( res ) = > { <EOL> if ( ! res ) { <EOL> return ; <EOL> } <EOL> this . showProgress . toggleLoadingGlobal ( true ) ; <EOL> try { <EOL> await this . unitService . deleteItem ( unit ) ; <EOL> this . closeEditUnit ( ) ; <EOL> await this . reloadCourse ( ) ; <EOL> this . snackBar . open ( '<STR_LIT>' ) ; <EOL> } catch ( err ) { <EOL> this . snackBar . open ( err . message ) ; <EOL> } <EOL> this . showProgress . toggleLoadingGlobal ( false ) ; <EOL> } ) ; <EOL> } <EOL> getDataForKey ( key ) { <EOL> return this . dataSharingService . getDataForKey ( key ) ; <EOL> } <EOL> deleteLecture ( lecture ) { <EOL> this . dialogService . confirmDelete ( '<STR_LIT>' , lecture . name ) . subscribe ( async ( res ) = > { <EOL> if ( ! res ) { <EOL> return ; <EOL> } <EOL> this . showProgress . toggleLoadingGlobal ( true ) ; <EOL> try { <EOL> await this . lectureService . deleteItem ( lecture ) ; <EOL> this . unsetUnitEdit ( ) ; <EOL> this . closeEditLecture ( ) ; <EOL> await this . reloadCourse ( ) ; <EOL> this . snackBar . open ( '<STR_LIT>' ) ; <EOL> } catch ( err ) { <EOL> this . snackBar . open ( err . message ) ; <EOL> } <EOL> this . showProgress . toggleLoadingGlobal ( false ) ; <EOL> } ) ; <EOL> } <EOL> reloadCourse ( ) { <EOL> return new Promise ( resolve = > { <EOL> this . onReloadCourse . next ( resolve ) ; <EOL> } ) ; <EOL> } <EOL> onEditLecture ( ) { <EOL> this . closeAllForms ( ) ; <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , true ) ; <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , this . lecture . _id ) ; <EOL> this . navigateToThisLecture ( ) ; <EOL> } <EOL> closeEditLecture = ( ) = > { <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , false ) ; <EOL> } ; <EOL> onAddUnitDone = async ( ) = > { <EOL> await this . reloadCourse ( ) ; <EOL> this . closeAddUnit ( ) ; <EOL> } ; <EOL> closeAddUnit = ( ) = > { <EOL> this . unsetAddUnit ( ) ; <EOL> this . navigateToThisLecture ( ) ; <EOL> } ; <EOL> unsetAddUnit ( ) { <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , false ) ; <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , null ) ; <EOL> } <EOL> onEditUnit = ( unit ) = > { <EOL> const isOpen = this . isUnitCurrentlyOpen ( unit ) ; <EOL> this . closeAllForms ( ) ; <EOL> if ( isOpen ) { <EOL> return this . navigateToThisLecture ( ) ; <EOL> } <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , true ) ; <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , unit ) ; <EOL> this . navigateToUnitEdit ( unit . _id ) ; <EOL> } ; <EOL> isUnitCurrentlyOpen ( unit ) { <EOL> const isInEditMode = this . dataSharingService . getDataForKey ( '<STR_LIT>' ) ; <EOL> const isSameUnit = this . dataSharingService . getDataForKey ( '<STR_LIT>' ) == = unit ; <EOL> return isInEditMode & & isSameUnit ; <EOL> } <EOL> onExportUnit = async ( unit ) = > { <EOL> try { <EOL> const unitJSON = await this . exportService . exportUnit ( unit ) ; <EOL> this . saveFileService . save ( unit . name , JSON . stringify ( unitJSON , null , <NUM_LIT> ) ) ; <EOL> } catch ( err ) { <EOL> this . snackBar . open ( '<STR_LIT>' + err . error . message ) ; <EOL> } <EOL> } ; <EOL> onEditUnitDone = async ( ) = > { <EOL> await this . reloadCourse ( ) ; <EOL> this . closeEditUnit ( ) ; <EOL> } ; <EOL> closeEditUnit = ( ) = > { <EOL> this . unsetUnitEdit ( ) ; <EOL> this . navigateToThisLecture ( ) ; <EOL> } ; <EOL> unsetUnitEdit ( ) { <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , false ) ; <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , null ) ; <EOL> } <EOL> private closeAllForms ( ) { <EOL> this . closeEditLecture ( ) ; <EOL> this . unsetAddUnit ( ) ; <EOL> this . unsetUnitEdit ( ) ; <EOL> } <EOL> isOpened ( ) { <EOL> return this . dataSharingService . getDataForKey ( '<STR_LIT>' ) == = this . lecture . _id ; <EOL> } <EOL> navigateToThisLecture ( ) { <EOL> this . navigateToLecture ( this . lecture . _id ) ; <EOL> } <EOL> navigateToLecture ( lectureId ) { <EOL> this . route . url . subscribe ( segments = > { <EOL> let path = segments . map ( ( ) = > '<STR_LIT>' ) . join ( '<STR_LIT>' ) | | '<STR_LIT>' ; <EOL> path +=   ` lecture / $ { lectureId } ` ; <EOL> this . router . navigate ( [ path ] , { <EOL> relativeTo : this . route <EOL> } ) ; <EOL> } ) ; <EOL> } <EOL> navigateToUnitEdit ( unitId ) { <EOL> this . route . url . subscribe ( segments = > { <EOL> let path = segments . map ( ( ) = > '<STR_LIT>' ) . join ( '<STR_LIT>' ) | | '<STR_LIT>' ; <EOL> path +=   ` lecture / $ { this . lecture . _id } / unit / $ { unitId } ` ; <EOL> this . router . navigate ( [ path ] , { <EOL> relativeTo : this . route <EOL> } ) ; <EOL> } ) ; <EOL> } <EOL> navigateToRoot ( ) { <EOL> this . route . url . subscribe ( segments = > { <EOL> const path = segments . map ( ( ) = > '<STR_LIT>' ) . join ( '<STR_LIT>' ) | | '<STR_LIT>' ; <EOL> this . router . navigate ( [ path ] , { <EOL> relativeTo : this . route <EOL> } ) ; <EOL> } ) ; <EOL> } <EOL> toggleLecture ( ) { <EOL> this . onCloseAllForms . next ( ) ; <EOL> const openLectureId = this . dataSharingService . getDataForKey ( '<STR_LIT>' ) ; <EOL> if ( openLectureId & & openLectureId == = this . lecture . _id ) { <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , null ) ; <EOL> this . navigateToRoot ( ) ; <EOL> } else { <EOL> this . dataSharingService . setDataForKey ( '<STR_LIT>' , this . lecture . _id ) ; <EOL> this . navigateToThisLecture ( ) ; <EOL> } <EOL> } <EOL> getUnitModel ( ) { <EOL> return this . unitFactoryService . createNewUnit ( this . dataSharingService . getDataForKey ( '<STR_LIT>' ) , this . course ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiButton , <EOL> EuiFlexGroup , <EOL> EuiFlexItem <EOL> } from '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> import { <EOL> CoreStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> toMountPoint <EOL> } from '<STR_LIT>' ; <EOL> export const onUnsupportedTimePattern = ( toasts , navigateToApp ) = > ( { <EOL> id , <EOL> title , <EOL> index <EOL> } ) = > { <EOL> const warningTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const warningText = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> title , <EOL> index <EOL> } , <EOL> } ) ; <EOL> toasts . addWarning ( { <EOL> title : warningTitle , <EOL> text : toMountPoint ( < div > < p > { warningText } < / p > < EuiFlexGroup justifyContent = "<STR_LIT>" gutterSize = "<STR_LIT>" > < EuiFlexItem grow = { false } > < EuiButton size = "<STR_LIT>" onClick = { ( ) = > navigateToApp ( '<STR_LIT>' , { path :   ` / opensearch - dashboards / index_patterns / index_pattern / $ { id   ! | | '<STR_LIT>' } ` , } ) } > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiButton > < / EuiFlexItem > < / EuiFlexGroup > < / div > ) , } ) ; } ; </s>
<s> import { <EOL> ApplicationCacheConfigImpl , <EOL> ApplicationImpl , <EOL> DatetimeProjectItemImpl , <EOL> DescriptionGetter , <EOL> Group , <EOL> GroupName , <EOL> Platform , <EOL> ShellExecutor , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isEmpty , <EOL> isNil , <EOL> unique , <EOL> Url <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> join , <EOL> parse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> execSync <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> existsOrNot , <EOL> systemUser <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> lstatSync , <EOL> readdirSync <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Context <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> generatePinyinIndex <EOL> } from '<STR_LIT>' ; <EOL> import plistParser from '<STR_LIT>' ; <EOL> const OFFICE_MAC = '<STR_LIT>' ; <EOL> const OFFICE_WIN = '<STR_LIT>' ; <EOL> export class OfficeProjectItemImpl extends DatetimeProjectItemImpl { } <EOL> export class OfficeMacApplicationImpl extends ApplicationCacheConfigImpl < OfficeProjectItemImpl > { <EOL> private readonly defaultConfig ; constructor ( id , name , icon , configFilename , defaultConfig = '<STR_LIT>' ) { <EOL> super ( ` office - mac - $ { id } ` , name , icon , OFFICE_MAC , [ Platform . darwin ] , Group [ GroupName . office ] , ( ) = >   ` 配置文件通常放在   $ { defaultConfig } ` , false , configFilename ) ; <EOL> this . defaultConfig = defaultConfig ; <EOL> } <EOL> override defaultConfigPath ( ) { <EOL> return this . defaultConfig ; <EOL> } <EOL> async generateCacheProjectItems ( context ) { <EOL> let items = [ ] ; <EOL> let data = await plistParser . parseFile ( this . config ) ; <EOL> if ( ! isNil ( data ) & &   ! isEmpty ( data ) ) { <EOL> data = data [ <NUM_LIT> ] ; <EOL> Object . keys ( data ) . forEach ( key = > { <EOL> let date ; <EOL> try { <EOL> date = new Date ( data [ key ] [ '<STR_LIT>' ] ) . getTime ( ) ; <EOL> } catch ( error ) { <EOL> console . log ( error ) ; <EOL> date = <NUM_LIT> ; <EOL> } <EOL> key = decodeURI ( key ) ; <EOL> let url = Url . parse ( key ) ; <EOL> let parser = parse ( url . pathname ) ; <EOL> let { <EOL> exists , <EOL> description , <EOL> icon <EOL> } = existsOrNot ( url . pathname , { <EOL> description : url . pathname , <EOL> icon : context . enableGetFileIcon   ? utools . getFileIcon ( url . pathname ) : this . icon , <EOL> } ) ; <EOL> items . push ( { <EOL> id : '<STR_LIT>' , <EOL> title : parser . name , <EOL> description : description , <EOL> icon : icon , <EOL> searchKey : unique ( [ ... generatePinyinIndex ( context , parser . name ) , parser . name , url . pathname ] ) , <EOL> exists : exists , <EOL> command : new ShellExecutor ( ` open   $ { url } ` ) , <EOL> datetime : date , <EOL> } ) ; <EOL> } ) ; <EOL> } <EOL> return items ; <EOL> } <EOL> } <EOL> export class OfficeWinApplicationImpl extends ApplicationImpl < OfficeProjectItemImpl > { <EOL> private readonly recentPath : string ; constructor ( ) { <EOL> super ( OFFICE_WIN , '<STR_LIT>' , '<STR_LIT>' , OFFICE_WIN , [ Platform . win32 ] , Group [ GroupName . office ] , ( ) = >   ` Office <NUM_LIT> 通过解析 C : \ \ Users \ \ $ { systemUser ( ) } \ \ AppData \ \ Roaming \ \ Microsoft \ \ Office \ \ Recent 下的文件记录来得到历史打开文件列表 , 这种方式依赖于默认的 Office 行为 , 目前仅支持有限的 Office 文档格式 ` , false ) ; <EOL> this . recentPath =   ` C : \ \ Users \ \ $ { systemUser ( ) } \ \ AppData \ \ Roaming \ \ Microsoft \ \ Office \ \ Recent ` ; <EOL> } <EOL> async generateProjectItems ( context ) { <EOL> let items = [ ] ; <EOL> let command = readdirSync ( this . recentPath ) . map ( p = > join ( this . recentPath , p ) ) . filter ( p = > p . endsWith ( '<STR_LIT>' ) ) . filter ( p = > this . permitExtension ( p . replace ( / \ . LNK $ / , '<STR_LIT>' ) ) ) . map ( p = > { <EOL> let stat = lstatSync ( p ) ; <EOL> return { <EOL> path : p , <EOL> datetime : stat . mtimeMs , <EOL> } ; <EOL> } ) . sort ( ( p1 , p2 ) = > p2 . datetime - p1 . datetime ) . map ( p = > this . generateCommand ( p . path ) ) . join ( '<STR_LIT>' ) ; <EOL> let result = execSync ( ` powershell . exe - command "<STR_LIT>" ` , { <EOL> encoding : '<STR_LIT>' <EOL> } ) . trim ( ) ; <EOL> let paths = result . split ( / \ r ? \ n / ) . slice ( <NUM_LIT> ) ; <EOL> paths . forEach ( path = > { <EOL> let parser = parse ( path ) ; <EOL> let { <EOL> exists , <EOL> description , <EOL> icon <EOL> } = existsOrNot ( path , { <EOL> description : path , <EOL> icon : utools . getFileIcon ( path ) , <EOL> } ) ; <EOL> items . push ( { <EOL> id : '<STR_LIT>' , <EOL> title : parser . name , <EOL> description : description , <EOL> icon : icon , <EOL> searchKey : unique ( [ ... generatePinyinIndex ( context , parser . name ) , parser . name , path ] ) , <EOL> exists : exists , <EOL> command : new ShellExecutor ( ` powershell . exe - command "<STR_LIT>" ` ) , <EOL> datetime : <NUM_LIT> , <EOL> } ) ; <EOL> } ) ; <EOL> return items ; <EOL> } <EOL> private permitExtension : ( string ) = > boolean = p = > { <EOL> let ext = parse ( p ) . ext ; <EOL> if ( isEmpty ( ext ) ) return false ; <EOL> return '<STR_LIT>' . indexOf ( ext ) > - <NUM_LIT> ; <EOL> } ; private generateCommand : ( string ) = > string = link = >   ` ( New - Object - COM WScript . Shell ) . CreateShortcut ( '<STR_LIT>' ) . TargetPath ; ` ; <EOL> } <EOL> export const applications = [ new OfficeMacApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ,   ` / Users / $ { systemUser ( ) } / Library / Containers / Microsoft Word / Data / Library / Preferences / com . microsoft . Word . securebookmarks . plist ` ) , new OfficeMacApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ,   ` / Users / $ { systemUser ( ) } / Library / Containers / Microsoft Excel / Data / Library / Preferences / com . microsoft . Excel . securebookmarks . plist ` ) , new OfficeMacApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ,   ` / Users / $ { systemUser ( ) } / Library / Containers / Microsoft Powerpoint / Data / Library / Preferences / com . microsoft . Powerpoint . securebookmarks . plist ` ) , new OfficeWinApplicationImpl ( ) , ] ; </s>
<s> import { <EOL> h <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> State , <EOL> Actions , <EOL> ActionEvent , <EOL> FunctionEvent <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> isValueDisplayExpanded , <EOL> getCallText , <EOL> getArgsFromCallText <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ObjectView <EOL> } from "<STR_LIT>" ; <EOL> import "<STR_LIT>" ; <EOL> import { <EOL> getErrorMessage <EOL> } from "<STR_LIT>" ; <EOL> interface CallProps extends CallOverviewDetailsPaneProps { <EOL> args   ? : any [ ] ; <EOL> error   ? : string ; <EOL> } <EOL> function getCallProps ( props ) { <EOL> const { <EOL> state , <EOL> actions , <EOL> event <EOL> } = props ; <EOL> try { <EOL> const args = getArgsFromCallText ( event , state . callOverviewText ) ; <EOL> return { <EOL> state , <EOL> actions , <EOL> event , <EOL> args <EOL> } ; <EOL> } catch ( e ) { <EOL> const error = getErrorMessage ( e ) ; <EOL> return { <EOL> state , <EOL> actions , <EOL> event , <EOL> error <EOL> } ; <EOL> } <EOL> } <EOL> function CallTextArea ( props ) { <EOL> const { <EOL> state , <EOL> actions , <EOL> event <EOL> } = props ; <EOL> return ( < textarea class = "<STR_LIT>" value = { state . callOverviewText } oninput = { ( e ) = > { actions . setCallOverviewText ( e . target [ "<STR_LIT>" ] ) ; } } / > ) ; <EOL> } <EOL> function CallTextAction ( props ) { <EOL> const { <EOL> state , <EOL> actions , <EOL> event , <EOL> args , <EOL> error <EOL> } = props ; <EOL> return ( < div class = "<STR_LIT>" > { error   ? < div class = "<STR_LIT>" > { error } < / div > : < div / > } < button onclick = { ( ) = > { actions . execute ( { type : event . type , name : event . name , runId : state . selectedEvent . runId , args } ) ; } } disabled = {   !   ! error } > Execute < / button > < / div > ) ; } function ResultPane ( props ) { const { state , actions , event } = props ; function expanded ( path , expanded   ? ) { const result = isValueDisplayExpanded ( state , path ) ; if ( typeof expanded == = "<STR_LIT>" ) { actions . setDetailsPaneExpanded ( { expanded :   ! result , path } ) ; } return result ; } return ( < div class = "<STR_LIT>" > { ObjectView ( { value : event . result , expanded } ) } < / div > ) ; } export interface CallOverviewDetailsPaneProps { state : State ; actions : Actions ; event : ActionEvent | FunctionEvent ; } export function CallOverviewDetailsPane ( props ) { const { state , actions , event } = props ; const callProps = getCallProps ( props ) ; return ( < div class = "<STR_LIT>" > < div class = "<STR_LIT>" > < section class = "<STR_LIT>" > < h3 > Call < / h3 > { CallTextArea ( callProps ) } { CallTextAction ( callProps ) } < / section > < section class = "<STR_LIT>" > < h3 > Response < / h3 > { ResultPane ( callProps ) } < / section > < / div > < / div > ) ; } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> EuiProgress <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> percent : number ; count : number ; value : string ; <EOL> } <EOL> export function StringFieldProgressBar ( { <EOL> value , <EOL> percent , <EOL> count <EOL> } ) { <EOL> const ariaLabel =   ` $ { value } :   $ { count } ( $ { percent } % ) ` ; <EOL> return ( < EuiProgress value = { percent } max = { <NUM_LIT> } color = "<STR_LIT>" aria - label = { ariaLabel } size = "<STR_LIT>" / > ) ; <EOL> } </s>
<s> param data { <EOL> Object <EOL> } <EOL> param key { <EOL> string <EOL> } <EOL> internal <EOL> export const getParsedValue = ( data , key ) = > { <EOL> try { <EOL> return data [ key ]   ? JSON . parse ( data [ key ] ) : undefined ; <EOL> } catch ( e ) { <EOL> throw new Error ( ` Unable to parse   $ { key } argument string ` ) ; <EOL> } <EOL> } ; </s>
<s> import '<STR_LIT>' ; <EOL> import { <EOL> EnvironmentVariables , <EOL> LUA_REGISTRYINDEX , <EOL> LuaReturn , <EOL> LuaState , <EOL> LuaType <EOL> } from '<STR_LIT>' ; <EOL> import initWasmModule from '<STR_LIT>' ; <EOL> interface LuaEmscriptenModule extends EmscriptenModule { <EOL> cwrap : typeof cwrap ; addFunction : typeof addFunction ; removeFunction : typeof removeFunction ; setValue : typeof setValue ; getValue : typeof getValue ; FS : typeof FS ; ENV : EnvironmentVariables ; _realloc : ( pointer : number , size : number ) = > number ; <EOL> } <EOL> interface ReferenceMetadata { <EOL> index : number ; refCount : number ; <EOL> } <EOL> export default class LuaWasm { <EOL> public static async initialize ( customName   ? , env   ? ) { <EOL> const module = await initWasmModule ( { <EOL> print : console . log , <EOL> printErr : console . error , <EOL> locateFile : ( path , scriptDirectory ) = > { <EOL> return customName | | scriptDirectory + path ; <EOL> } , <EOL> preRun : ( initializedModule ) = > { <EOL> if ( typeof env == = '<STR_LIT>' ) { <EOL> Object . entries ( env ) . forEach ( ( [ k , v ] ) = > ( initializedModule . ENV [ k ] = v ) ) ; <EOL> } <EOL> } , <EOL> } ) ; <EOL> return new LuaWasm ( module ) ; <EOL> } <EOL> public module : LuaEmscriptenModule ; <EOL> public luaL_checkversion_ : ( L : LuaState , ver : number , sz : number ) = > void ; <EOL> public luaL_getmetafield : ( L : LuaState , obj : number , e : string | null ) = > LuaType ; <EOL> public luaL_callmeta : ( L : LuaState , obj : number , e : string | null ) = > number ; <EOL> public luaL_tolstring : ( L : LuaState , idx : number , len : number | null ) = > string ; <EOL> public luaL_argerror : ( L : LuaState , arg : number , extramsg : string | null ) = > number ; <EOL> public luaL_typeerror : ( L : LuaState , arg : number , tname : string | null ) = > number ; <EOL> public luaL_checklstring : ( L : LuaState , arg : number , l : number | null ) = > string ; <EOL> public luaL_optlstring : ( L : LuaState , arg : number , def : string | null , l : number | null ) = > string ; <EOL> public luaL_checknumber : ( L : LuaState , arg : number ) = > number ; <EOL> public luaL_optnumber : ( L : LuaState , arg : number , def : number ) = > number ; <EOL> public luaL_checkinteger : ( L : LuaState , arg : number ) = > number ; <EOL> public luaL_optinteger : ( L : LuaState , arg : number , def : number ) = > number ; <EOL> public luaL_checkstack : ( L : LuaState , sz : number , msg : string | null ) = > void ; <EOL> public luaL_checktype : ( L : LuaState , arg : number , t : number ) = > void ; <EOL> public luaL_checkany : ( L : LuaState , arg : number ) = > void ; <EOL> public luaL_newmetatable : ( L : LuaState , tname : string | null ) = > number ; <EOL> public luaL_setmetatable : ( L : LuaState , tname : string | null ) = > void ; <EOL> public luaL_testudata : ( L : LuaState , ud : number , tname : string | null ) = > number ; <EOL> public luaL_checkudata : ( L : LuaState , ud : number , tname : string | null ) = > number ; <EOL> public luaL_where : ( L : LuaState , lvl : number ) = > void ; <EOL> public luaL_fileresult : ( L : LuaState , stat : number , fname : string | null ) = > number ; <EOL> public luaL_execresult : ( L : LuaState , stat : number ) = > number ; <EOL> public luaL_ref : ( L : LuaState , t : number ) = > number ; <EOL> public luaL_unref : ( L : LuaState , t : number , ref : number ) = > void ; <EOL> public luaL_loadfilex : ( L : LuaState , filename : string | null , mode : string | null ) = > LuaReturn ; <EOL> public luaL_loadbufferx : ( L : LuaState , buff : string | null , sz : number , name : string | null , mode : string | null ) = > LuaReturn ; <EOL> public luaL_loadstring : ( L : LuaState , s : string | null ) = > LuaReturn ; <EOL> public luaL_newstate : ( ) = > LuaState ; <EOL> public luaL_len : ( L : LuaState , idx : number ) = > number ; <EOL> public luaL_addgsub : ( b : number | null , s : string | null , p : string | null , r : string | null ) = > void ; <EOL> public luaL_gsub : ( L : LuaState , s : string | null , p : string | null , r : string | null ) = > string ; <EOL> public luaL_setfuncs : ( L : LuaState , l : number | null , nup : number ) = > void ; <EOL> public luaL_getsubtable : ( L : LuaState , idx : number , fname : string | null ) = > number ; <EOL> public luaL_traceback : ( L : LuaState , L1 : LuaState , msg : string | null , level : number ) = > void ; <EOL> public luaL_requiref : ( L : LuaState , modname : string | null , openf : number , glb : number ) = > void ; <EOL> public luaL_buffinit : ( L : LuaState , B : number | null ) = > void ; <EOL> public luaL_prepbuffsize : ( B : number | null , sz : number ) = > string ; <EOL> public luaL_addlstring : ( B : number | null , s : string | null , l : number ) = > void ; <EOL> public luaL_addstring : ( B : number | null , s : string | null ) = > void ; <EOL> public luaL_addvalue : ( B : number | null ) = > void ; <EOL> public luaL_pushresult : ( B : number | null ) = > void ; <EOL> public luaL_pushresultsize : ( B : number | null , sz : number ) = > void ; <EOL> public luaL_buffinitsize : ( L : LuaState , B : number | null , sz : number ) = > string ; <EOL> public lua_newstate : ( f : number | null , ud : number | null ) = > LuaState ; <EOL> public lua_close : ( L : LuaState ) = > void ; <EOL> public lua_newthread : ( L : LuaState ) = > LuaState ; <EOL> public lua_resetthread : ( L : LuaState ) = > LuaReturn ; <EOL> public lua_atpanic : ( L : LuaState , panicf : number ) = > number ; <EOL> public lua_version : ( L : LuaState ) = > number ; <EOL> public lua_absindex : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_gettop : ( L : LuaState ) = > number ; <EOL> public lua_settop : ( L : LuaState , idx : number ) = > void ; <EOL> public lua_pushvalue : ( L : LuaState , idx : number ) = > void ; <EOL> public lua_rotate : ( L : LuaState , idx : number , n : number ) = > void ; <EOL> public lua_copy : ( L : LuaState , fromidx : number , toidx : number ) = > void ; <EOL> public lua_checkstack : ( L : LuaState , n : number ) = > number ; <EOL> public lua_xmove : ( from : LuaState , to : LuaState , n : number ) = > void ; <EOL> public lua_isnumber : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_isstring : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_iscfunction : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_isinteger : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_isuserdata : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_type : ( L : LuaState , idx : number ) = > LuaType ; <EOL> public lua_typename : ( L : LuaState , tp : number ) = > string ; <EOL> public lua_tonumberx : ( L : LuaState , idx : number , isnum : number | null ) = > number ; <EOL> public lua_tointegerx : ( L : LuaState , idx : number , isnum : number | null ) = > number ; <EOL> public lua_toboolean : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_tolstring : ( L : LuaState , idx : number , len : number | null ) = > string ; <EOL> public lua_rawlen : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_tocfunction : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_touserdata : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_tothread : ( L : LuaState , idx : number ) = > LuaState ; <EOL> public lua_topointer : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_arith : ( L : LuaState , op : number ) = > void ; <EOL> public lua_rawequal : ( L : LuaState , idx1 : number , idx2 : number ) = > number ; <EOL> public lua_compare : ( L : LuaState , idx1 : number , idx2 : number , op : number ) = > number ; <EOL> public lua_pushnil : ( L : LuaState ) = > void ; <EOL> public lua_pushnumber : ( L : LuaState , n : number ) = > void ; <EOL> public lua_pushinteger : ( L : LuaState , n : number ) = > void ; <EOL> public lua_pushlstring : ( L : LuaState , s : string | null , len : number ) = > string ; <EOL> public lua_pushstring : ( L : LuaState , s : string | null ) = > string ; <EOL> public lua_pushcclosure : ( L : LuaState , fn : number , n : number ) = > void ; <EOL> public lua_pushboolean : ( L : LuaState , b : number ) = > void ; <EOL> public lua_pushlightuserdata : ( L : LuaState , p : number | null ) = > void ; <EOL> public lua_pushthread : ( L : LuaState ) = > number ; <EOL> public lua_getglobal : ( L : LuaState , name : string | null ) = > LuaType ; <EOL> public lua_gettable : ( L : LuaState , idx : number ) = > LuaType ; <EOL> public lua_getfield : ( L : LuaState , idx : number , k : string | null ) = > LuaType ; <EOL> public lua_geti : ( L : LuaState , idx : number , n : number ) = > LuaType ; <EOL> public lua_rawget : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_rawgeti : ( L : LuaState , idx : number , n : number ) = > LuaType ; <EOL> public lua_rawgetp : ( L : LuaState , idx : number , p : number | null ) = > LuaType ; <EOL> public lua_createtable : ( L : LuaState , narr : number , nrec : number ) = > void ; <EOL> public lua_newuserdatauv : ( L : LuaState , sz : number , nuvalue : number ) = > number ; <EOL> public lua_getmetatable : ( L : LuaState , objindex : number ) = > number ; <EOL> public lua_getiuservalue : ( L : LuaState , idx : number , n : number ) = > LuaType ; <EOL> public lua_setglobal : ( L : LuaState , name : string | null ) = > void ; <EOL> public lua_settable : ( L : LuaState , idx : number ) = > void ; <EOL> public lua_setfield : ( L : LuaState , idx : number , k : string | null ) = > void ; <EOL> public lua_seti : ( L : LuaState , idx : number , n : number ) = > void ; <EOL> public lua_rawset : ( L : LuaState , idx : number ) = > void ; <EOL> public lua_rawseti : ( L : LuaState , idx : number , n : number ) = > void ; <EOL> public lua_rawsetp : ( L : LuaState , idx : number , p : number | null ) = > void ; <EOL> public lua_setmetatable : ( L : LuaState , objindex : number ) = > number ; <EOL> public lua_setiuservalue : ( L : LuaState , idx : number , n : number ) = > number ; <EOL> public lua_callk : ( L : LuaState , nargs : number , nresults : number , ctx : number , k : number | null ) = > void ; <EOL> public lua_pcallk : ( L : LuaState , nargs : number , nresults : number , errfunc : number , ctx : number , k : number | null ) = > number ; <EOL> public lua_load : ( L : LuaState , reader : number | null , dt : number | null , chunkname : string | null , mode : string | null ) = > LuaReturn ; <EOL> public lua_dump : ( L : LuaState , writer : number | null , data : number | null , strip : number ) = > number ; <EOL> public lua_yieldk : ( L : LuaState , nresults : number , ctx : number , k : number | null ) = > number ; <EOL> public lua_resume : ( L : LuaState , from : LuaState | null , narg : number , nres : number | null ) = > LuaReturn ; <EOL> public lua_status : ( L : LuaState ) = > LuaReturn ; <EOL> public lua_isyieldable : ( L : LuaState ) = > number ; <EOL> public lua_setwarnf : ( L : LuaState , f : number | null , ud : number | null ) = > void ; <EOL> public lua_warning : ( L : LuaState , msg : string | null , tocont : number ) = > void ; <EOL> public lua_error : ( L : LuaState ) = > number ; <EOL> public lua_next : ( L : LuaState , idx : number ) = > number ; <EOL> public lua_concat : ( L : LuaState , n : number ) = > void ; <EOL> public lua_len : ( L : LuaState , idx : number ) = > void ; <EOL> public lua_stringtonumber : ( L : LuaState , s : string | null ) = > number ; <EOL> public lua_getallocf : ( L : LuaState , ud : number | null ) = > number ; <EOL> public lua_setallocf : ( L : LuaState , f : number | null , ud : number | null ) = > void ; <EOL> public lua_toclose : ( L : LuaState , idx : number ) = > void ; <EOL> public lua_closeslot : ( L : LuaState , idx : number ) = > void ; <EOL> public lua_getstack : ( L : LuaState , level : number , ar : number | null ) = > number ; <EOL> public lua_getinfo : ( L : LuaState , what : string | null , ar : number | null ) = > number ; <EOL> public lua_getlocal : ( L : LuaState , ar : number | null , n : number ) = > string ; <EOL> public lua_setlocal : ( L : LuaState , ar : number | null , n : number ) = > string ; <EOL> public lua_getupvalue : ( L : LuaState , funcindex : number , n : number ) = > string ; <EOL> public lua_setupvalue : ( L : LuaState , funcindex : number , n : number ) = > string ; <EOL> public lua_upvalueid : ( L : LuaState , fidx : number , n : number ) = > number ; <EOL> public lua_upvaluejoin : ( L : LuaState , fidx1 : number , n1 : number , fidx2 : number , n2 : number ) = > void ; <EOL> public lua_sethook : ( L : LuaState , func : number | null , mask : number , count : number ) = > void ; <EOL> public lua_gethook : ( L : LuaState ) = > number ; <EOL> public lua_gethookmask : ( L : LuaState ) = > number ; <EOL> public lua_gethookcount : ( L : LuaState ) = > number ; <EOL> public lua_setcstacklimit : ( L : LuaState , limit : number ) = > number ; <EOL> public luaopen_base : ( L : LuaState ) = > number ; <EOL> public luaopen_coroutine : ( L : LuaState ) = > number ; <EOL> public luaopen_table : ( L : LuaState ) = > number ; <EOL> public luaopen_io : ( L : LuaState ) = > number ; <EOL> public luaopen_os : ( L : LuaState ) = > number ; <EOL> public luaopen_string : ( L : LuaState ) = > number ; <EOL> public luaopen_utf8 : ( L : LuaState ) = > number ; <EOL> public luaopen_math : ( L : LuaState ) = > number ; <EOL> public luaopen_debug : ( L : LuaState ) = > number ; <EOL> public luaopen_package : ( L : LuaState ) = > number ; <EOL> public luaL_openlibs : ( L : LuaState ) = > void ; <EOL> private referenceTracker = new WeakMap < any , ReferenceMetadata > ( ) ; <EOL> private referenceMap = new Map < number , any > ( ) ; <EOL> private availableReferences : number [ ] = [ ] ; <EOL> public constructor ( module ) { <EOL> this . module = module ; <EOL> this . luaL_checkversion_ = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_getmetafield = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_callmeta = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_tolstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_argerror = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_typeerror = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_checklstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_optlstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_checknumber = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_optnumber = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_checkinteger = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_optinteger = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_checkstack = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_checktype = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_checkany = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_newmetatable = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_setmetatable = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_testudata = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_checkudata = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_where = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_fileresult = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_execresult = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_ref = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_unref = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_loadfilex = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_loadbufferx = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_loadstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_newstate = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ ] ) ; <EOL> this . luaL_len = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_addgsub = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_gsub = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_setfuncs = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_getsubtable = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_traceback = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_requiref = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_buffinit = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_prepbuffsize = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_addlstring = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_addstring = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_addvalue = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' ] ) ; <EOL> this . luaL_pushresult = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' ] ) ; <EOL> this . luaL_pushresultsize = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaL_buffinitsize = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_newstate = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_close = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' ] ) ; <EOL> this . lua_newthread = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_resetthread = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_atpanic = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_version = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_absindex = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_gettop = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_settop = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushvalue = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rotate = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_copy = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_checkstack = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_xmove = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_isnumber = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_isstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_iscfunction = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_isinteger = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_isuserdata = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_type = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_typename = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_tonumberx = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_tointegerx = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_toboolean = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_tolstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawlen = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_tocfunction = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_touserdata = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_tothread = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_topointer = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_arith = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawequal = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_compare = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushnil = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' ] ) ; <EOL> this . lua_pushnumber = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushinteger = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushlstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushstring = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushcclosure = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushboolean = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushlightuserdata = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pushthread = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_getglobal = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_gettable = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getfield = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_geti = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawget = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawgeti = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawgetp = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_createtable = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_newuserdatauv = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getmetatable = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getiuservalue = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_setglobal = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_settable = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_setfield = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_seti = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawset = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawseti = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_rawsetp = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_setmetatable = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_setiuservalue = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_callk = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_pcallk = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_load = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_dump = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_yieldk = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_resume = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_status = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_isyieldable = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_setwarnf = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_warning = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_error = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_next = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_concat = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_len = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_stringtonumber = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getallocf = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_setallocf = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_toclose = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_closeslot = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getstack = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getinfo = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getlocal = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_setlocal = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_getupvalue = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_setupvalue = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_upvalueid = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_upvaluejoin = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_sethook = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . lua_gethook = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_gethookmask = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_gethookcount = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . lua_setcstacklimit = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> this . luaopen_base = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_coroutine = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_table = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_io = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_os = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_string = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_utf8 = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_math = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_debug = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaopen_package = this . module . cwrap ( '<STR_LIT>' , '<STR_LIT>' , [ '<STR_LIT>' ] ) ; <EOL> this . luaL_openlibs = this . module . cwrap ( '<STR_LIT>' , null , [ '<STR_LIT>' ] ) ; <EOL> } <EOL> public lua_remove ( luaState , index ) { <EOL> this . lua_rotate ( luaState , index , - <NUM_LIT> ) ; <EOL> this . lua_pop ( luaState , <NUM_LIT> ) ; <EOL> } <EOL> public lua_pop ( luaState , count ) { <EOL> this . lua_settop ( luaState , - count - <NUM_LIT> ) ; <EOL> } <EOL> public luaL_getmetatable ( luaState , name ) { <EOL> return this . lua_getfield ( luaState , LUA_REGISTRYINDEX , name ) ; <EOL> } <EOL> public lua_yield ( luaState , count ) { <EOL> return this . lua_yieldk ( luaState , count , <NUM_LIT> , null ) ; <EOL> } <EOL> public lua_upvalueindex ( index ) { <EOL> return LUA_REGISTRYINDEX - index ; <EOL> } <EOL> public ref ( data ) { <EOL> const existing = this . referenceTracker . get ( data ) ; <EOL> if ( existing ) { <EOL> existing . refCount + + ; <EOL> return existing . index ; <EOL> } <EOL> const availableIndex = this . availableReferences . pop ( ) ; <EOL> const index = availableIndex == = undefined   ? this . referenceMap . size + <NUM_LIT> : availableIndex ; <EOL> this . referenceMap . set ( index , data ) ; <EOL> this . referenceTracker . set ( data , { <EOL> refCount : <NUM_LIT> , <EOL> index , <EOL> } ) ; <EOL> return index ; <EOL> } <EOL> public unref ( index ) { <EOL> const ref = this . referenceMap . get ( index ) ; <EOL> if ( ref == = undefined ) { <EOL> return ; <EOL> } <EOL> const metadata = this . referenceTracker . get ( ref ) ; <EOL> if ( metadata == = undefined ) { <EOL> this . referenceTracker . delete ( ref ) ; <EOL> this . availableReferences . push ( index ) ; <EOL> return ; <EOL> } <EOL> metadata . refCount - - ; <EOL> if ( metadata . refCount <= <NUM_LIT> ) { <EOL> this . referenceTracker . delete ( ref ) ; <EOL> this . referenceMap . delete ( index ) ; <EOL> this . availableReferences . push ( index ) ; <EOL> } <EOL> } <EOL> public getRef ( index ) { <EOL> return this . referenceMap . get ( index ) ; <EOL> } <EOL> } </s>
<s> import EventEmitter from "<STR_LIT>" ; <EOL> import SturdyWebSocket from "<STR_LIT>" ; <EOL> import { <EOL> Backfiller , <EOL> dedupeLogs , <EOL> dedupeNewHeads , <EOL> LogsEvent , <EOL> LogsSubscriptionFilter , <EOL> makeBackfiller , <EOL> NewHeadsEvent , <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> isSubscriptionEvent , <EOL> JsonRpcRequest , <EOL> JsonRpcResponse , <EOL> SingleOrBatchRequest , <EOL> SingleOrBatchResponse , <EOL> SubscriptionEvent , <EOL> WebSocketMessage , <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> fromHex <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> JsonRpcSenders , <EOL> makeResponse <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> callWhenDone , <EOL> makeCancelToken , <EOL> throwIfCancelled , <EOL> withBackoffRetries , <EOL> withTimeout , <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> SendPayloadFunction <EOL> } from "<STR_LIT>" ; <EOL> const HEARTBEAT_INTERVAL = <NUM_LIT> ; <EOL> const HEARTBEAT_WAIT_TIME = <NUM_LIT> ; <EOL> const BACKFILL_TIMEOUT = <NUM_LIT> ; <EOL> const BACKFILL_RETRIES = <NUM_LIT> ; <EOL> / ** <EOL> * Subscriptions have a memory of recent events they have sent so that in the <EOL> * event that they disconnect and need to backfill , they can detect re - orgs . <EOL> * Keep a buffer that goes back at least these many blocks , the maximum amount <EOL> * at which we might conceivably see a re - org . <EOL> * <EOL> * Note that while our buffer goes back this many blocks , it may contain more <EOL> * than this many elements , since in the case of logs subscriptions more than <EOL> * one event may be emitted for a block . <EOL> * / <EOL> const RETAINED_EVENT_BLOCK_COUNT = <NUM_LIT> ; <EOL> / ** <EOL> * This is the undocumented interface required by Web3 for providers which <EOL> * handle subscriptions . <EOL> * <EOL> * In addition to the stated methods here , it communicates subscription events <EOL> * by using   ` EventEmitter <EOL> * / <EOL> export interface Web3SubscriptionProvider extends EventEmitter { <EOL> send ( payload , callback ) : void ; <EOL> disconnect ( code   ? , reason   ? ) : void ; <EOL> supportsSubscriptions ( ) : true ; <EOL> connect ( ) : void ; <EOL> reset ( ) : void ; <EOL> reconnect ( ) : void ; <EOL> } <EOL> interface VirtualSubscription { <EOL> virtualId : string ; physicalId : string ; method : string ; params : any [ ] ; isBackfilling : boolean ; startingBlockNumber : number ; sentEvents : any [ ] ; backfillBuffer : any [ ] ; <EOL> } <EOL> interface NewHeadsSubscription extends VirtualSubscription { <EOL> method : "<STR_LIT>" ; params : [ "<STR_LIT>" ] ; isBackfilling : boolean ; sentEvents : NewHeadsEvent [ ] ; backfillBuffer : NewHeadsEvent [ ] ; <EOL> } <EOL> interface LogsSubscription extends VirtualSubscription { <EOL> method : "<STR_LIT>" ; params : [ "<STR_LIT>" , LogsSubscriptionFilter   ? ] ; isBackfilling : boolean ; sentEvents : LogsEvent [ ] ; backfillBuffer : LogsEvent [ ] ; <EOL> } <EOL> export class AlchemyWebSocketProvider extends EventEmitter implements Web3SubscriptionProvider { <EOL> private readonly virtualSubscriptionsById : Map < string , VirtualSubscription > = new Map ( ) ; <EOL> private readonly virtualIdsByPhysicalId : Map < string , string > = new Map ( ) ; <EOL> private readonly backfiller : Backfiller ; <EOL> private heartbeatIntervalId   ? : NodeJS . Timeout ; <EOL> private cancelBackfill = noop ; <EOL> constructor ( private readonly ws , private readonly sendPayload , private readonly senders ) { <EOL> super ( ) ; <EOL> this . backfiller = makeBackfiller ( senders ) ; <EOL> this . addSocketListeners ( ) ; <EOL> this . startHeartbeat ( ) ; <EOL> } <EOL> public send ( request , callback ) { <EOL> if ( isSubscribeRequest ( request ) ) { <EOL> const { <EOL> id <EOL> } = request ; <EOL> if ( id == = undefined ) { <EOL> return ; <EOL> } <EOL> callWhenDone ( this . subscribe ( request ) , callback ) ; <EOL> return ; <EOL> } <EOL> if ( isUnsubscribeRequest ( request ) ) { <EOL> callWhenDone ( this . unsubscribe ( request ) , callback ) ; <EOL> return ; <EOL> } <EOL> callWhenDone ( this . sendPayload ( request ) , callback ) ; <EOL> } <EOL> public supportsSubscriptions ( ) { <EOL> return true ; <EOL> } <EOL> public disconnect ( code   ? , reason   ? ) { <EOL> this . removeSocketListeners ( ) ; <EOL> this . removeAllListeners ( ) ; <EOL> this . stopHeartbeatAndBackfill ( ) ; <EOL> this . ws . close ( code , reason ) ; <EOL> } <EOL> public connect ( ) { } <EOL> public reset ( ) { } <EOL> public reconnect ( ) { } <EOL> private async subscribe ( request ) { <EOL> const { <EOL> method , <EOL> params = [ ] <EOL> } = request ; <EOL> const startingBlockNumber = await this . getBlockNumber ( ) ; <EOL> const response = await this . sendPayload ( request ) ; <EOL> const id = response . result ; <EOL> this . virtualSubscriptionsById . set ( id , { <EOL> method , <EOL> params , <EOL> startingBlockNumber , <EOL> virtualId : id , <EOL> physicalId : id , <EOL> sentEvents : [ ] , <EOL> isBackfilling : false , <EOL> backfillBuffer : [ ] , <EOL> } ) ; <EOL> this . virtualIdsByPhysicalId . set ( id , id ) ; <EOL> return makeResponse ( request . id ! , id ) ; <EOL> } <EOL> private async unsubscribe ( request ) { <EOL> const subscriptionId = request . params ? . [ <NUM_LIT> ] ; <EOL> const virtualSubscription = this . virtualSubscriptionsById . get ( subscriptionId ) ; <EOL> if ( ! virtualSubscription ) { <EOL> return makeResponse ( request . id ! , false ) ; <EOL> } <EOL> const { <EOL> physicalId <EOL> } = virtualSubscription ; <EOL> const physicalRequest = { <EOL> ... request , <EOL> params : [ physicalId ] <EOL> } ; <EOL> await this . sendPayload ( physicalRequest ) ; <EOL> this . virtualSubscriptionsById . delete ( subscriptionId ) ; <EOL> this . virtualIdsByPhysicalId . delete ( physicalId ) ; <EOL> return makeResponse ( request . id ! , true ) ; <EOL> } <EOL> private addSocketListeners ( ) { <EOL> this . ws . addEventListener ( "<STR_LIT>" , this . handleMessage ) ; <EOL> this . ws . addEventListener ( "<STR_LIT>" , this . handleReopen ) ; <EOL> this . ws . addEventListener ( "<STR_LIT>" , this . stopHeartbeatAndBackfill ) ; <EOL> } <EOL> private removeSocketListeners ( ) { <EOL> this . ws . removeEventListener ( "<STR_LIT>" , this . handleMessage ) ; <EOL> this . ws . removeEventListener ( "<STR_LIT>" , this . handleReopen ) ; <EOL> this . ws . removeEventListener ( "<STR_LIT>" , this . stopHeartbeatAndBackfill ) ; <EOL> } <EOL> private startHeartbeat = ( ) : void = > { <EOL> if ( this . heartbeatIntervalId != null ) { <EOL> return ; <EOL> } <EOL> this . heartbeatIntervalId = setInterval ( async ( ) = > { <EOL> try { <EOL> await withTimeout ( this . senders . send ( "<STR_LIT>" ) , HEARTBEAT_WAIT_TIME ) ; <EOL> } catch { <EOL> this . ws . reconnect ( ) ; <EOL> } <EOL> } , HEARTBEAT_INTERVAL ) ; <EOL> } ; <EOL> private stopHeartbeatAndBackfill = ( ) : void = > { <EOL> if ( this . heartbeatIntervalId != null ) { <EOL> clearInterval ( this . heartbeatIntervalId ) ; <EOL> this . heartbeatIntervalId = undefined ; <EOL> } <EOL> this . cancelBackfill ( ) ; <EOL> } ; <EOL> private handleMessage = ( event ) : void = > { <EOL> const message = JSON . parse ( event . data ) ; <EOL> if ( ! isSubscriptionEvent ( message ) ) { <EOL> return ; <EOL> } <EOL> const physicalId = message . params . subscription ; <EOL> const virtualId = this . virtualIdsByPhysicalId . get ( physicalId ) ; <EOL> if ( ! virtualId ) { <EOL> return ; <EOL> } <EOL> const subscription = this . virtualSubscriptionsById . get ( virtualId )   ! ; <EOL> if ( subscription . method != = "<STR_LIT>" ) { <EOL> this . emitGenericEvent ( virtualId , message . params . result ) ; <EOL> return ; <EOL> } <EOL> switch ( subscription . params [ <NUM_LIT> ] ) { <EOL> case "<STR_LIT>" : { <EOL> const newHeadsSubscription = subscription as NewHeadsSubscription ; <EOL> const newHeadsMessage = message as SubscriptionEvent < NewHeadsEvent > ; <EOL> const { <EOL> isBackfilling , <EOL> backfillBuffer <EOL> } = newHeadsSubscription ; <EOL> const { <EOL> result <EOL> } = newHeadsMessage . params ; <EOL> if ( isBackfilling ) { <EOL> addToNewHeadsEventsBuffer ( backfillBuffer , result ) ; <EOL> } else { <EOL> this . emitNewHeadsEvent ( virtualId , result ) ; <EOL> } <EOL> break ; <EOL> } <EOL> case "<STR_LIT>" : { <EOL> const logsSubscription = subscription as LogsSubscription ; <EOL> const logsMessage = message as SubscriptionEvent < LogsEvent > ; <EOL> const { <EOL> isBackfilling , <EOL> backfillBuffer <EOL> } = logsSubscription ; <EOL> const { <EOL> result <EOL> } = logsMessage . params ; <EOL> if ( isBackfilling ) { <EOL> addToLogsEventsBuffer ( backfillBuffer , result ) ; <EOL> } else { <EOL> this . emitLogsEvent ( virtualId , result ) ; <EOL> } <EOL> break ; <EOL> } <EOL> default : <EOL> this . emitGenericEvent ( virtualId , message . params . result ) ; <EOL> } <EOL> } ; <EOL> private handleReopen = ( ) : void = > { <EOL> this . virtualIdsByPhysicalId . clear ( ) ; <EOL> const { <EOL> cancel , <EOL> isCancelled <EOL> } = makeCancelToken ( ) ; <EOL> this . cancelBackfill = cancel ; <EOL> for ( const subscription of this . virtualSubscriptionsById . values ( ) ) { <EOL> ( async ( ) = > { <EOL> try { <EOL> await this . resubscribeAndBackfill ( isCancelled , subscription ) ; <EOL> } catch ( error ) { <EOL> if ( ! isCancelled ( ) ) { <EOL> console . error ( ` Error while backfilling "<STR_LIT>" subscription . Some events may be missing . ` , error ) ; <EOL> } <EOL> } <EOL> } ) ( ) ; <EOL> } <EOL> this . startHeartbeat ( ) ; <EOL> } ; <EOL> private async resubscribeAndBackfill ( isCancelled , subscription ) { <EOL> const { <EOL> virtualId , <EOL> method , <EOL> params , <EOL> sentEvents , <EOL> backfillBuffer , <EOL> startingBlockNumber , <EOL> } = subscription ; <EOL> subscription . isBackfilling = true ; <EOL> backfillBuffer . length = <NUM_LIT> ; <EOL> try { <EOL> const physicalId = await this . senders . send ( method , params ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> subscription . physicalId = physicalId ; <EOL> this . virtualIdsByPhysicalId . set ( physicalId , virtualId ) ; <EOL> switch ( params [ <NUM_LIT> ] ) { <EOL> case "<STR_LIT>" : { <EOL> const backfillEvents = await withBackoffRetries ( ( ) = > withTimeout ( this . backfiller . getNewHeadsBackfill ( isCancelled , sentEvents , startingBlockNumber ) , BACKFILL_TIMEOUT ) , BACKFILL_RETRIES , ( ) = >   ! isCancelled ( ) ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> const events = dedupeNewHeads ( [ ... backfillEvents , ... backfillBuffer ] ) ; <EOL> events . forEach ( ( event ) = > this . emitNewHeadsEvent ( virtualId , event ) ) ; <EOL> break ; <EOL> } <EOL> case "<STR_LIT>" : { <EOL> const filter = params [ <NUM_LIT> ] | | { } ; <EOL> const backfillEvents = await withBackoffRetries ( ( ) = > withTimeout ( this . backfiller . getLogsBackfill ( isCancelled , filter , sentEvents , startingBlockNumber ) , BACKFILL_TIMEOUT ) , BACKFILL_RETRIES , ( ) = >   ! isCancelled ( ) ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> const events = dedupeLogs ( [ ... backfillEvents , ... backfillBuffer ] ) ; <EOL> events . forEach ( ( event ) = > this . emitLogsEvent ( virtualId , event ) ) ; <EOL> break ; <EOL> } <EOL> default : <EOL> break ; <EOL> } <EOL> } finally { <EOL> subscription . isBackfilling = false ; <EOL> backfillBuffer . length = <NUM_LIT> ; <EOL> } <EOL> } <EOL> private async getBlockNumber ( ) { <EOL> const blockNumberHex = await this . senders . send ( "<STR_LIT>" ) ; <EOL> return fromHex ( blockNumberHex ) ; <EOL> } <EOL> private emitNewHeadsEvent ( virtualId , result ) { <EOL> this . emitAndRememberEvent ( virtualId , result , getNewHeadsBlockNumber ) ; <EOL> } <EOL> private emitLogsEvent ( virtualId , result ) { <EOL> this . emitAndRememberEvent ( virtualId , result , getLogsBlockNumber ) ; <EOL> } <EOL> / ** <EOL> * Emits an event to consumers , but also remembers it in its subscriptions ' s <EOL> *   ` sentEvents ` buffer so that we can detect re - orgs if the connection drops <EOL> * and needs to be reconnected . <EOL> * / <EOL> private emitAndRememberEvent < T > ( virtualId , result , getBlockNumber ) { <EOL> const subscription = this . virtualSubscriptionsById . get ( virtualId ) ; <EOL> if ( ! subscription ) { <EOL> return ; <EOL> } <EOL> addToPastEventsBuffer ( subscription . sentEvents , { <EOL> ... result <EOL> } , getBlockNumber ) ; <EOL> this . emitGenericEvent ( virtualId , result ) ; <EOL> } <EOL> private emitGenericEvent ( virtualId , result ) { <EOL> const event = { <EOL> jsonrpc : "<STR_LIT>" , <EOL> method : "<STR_LIT>" , <EOL> params : { <EOL> subscription : virtualId , <EOL> result , <EOL> } , <EOL> } ; <EOL> this . emit ( "<STR_LIT>" , event ) ; <EOL> } <EOL> } <EOL> function addToNewHeadsEventsBuffer ( pastEvents , event ) { <EOL> addToPastEventsBuffer ( pastEvents , event , getNewHeadsBlockNumber ) ; <EOL> } <EOL> function addToLogsEventsBuffer ( pastEvents , event ) { <EOL> addToPastEventsBuffer ( pastEvents , event , getLogsBlockNumber ) ; <EOL> } <EOL> / ** <EOL> * Adds a new event to an array of events , evicting any events which <EOL> * are so old that they will no longer feasibly be part of a reorg . <EOL> * / <EOL> function addToPastEventsBuffer < T > ( pastEvents , event , getBlockNumber ) { <EOL> const currentBlockNumber = getBlockNumber ( event ) ; <EOL> const firstGoodIndex = pastEvents . findIndex ( ( e ) = > getBlockNumber ( e ) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT ) ; <EOL> if ( firstGoodIndex == = - <NUM_LIT> ) { <EOL> pastEvents . length = <NUM_LIT> ; <EOL> } else { <EOL> pastEvents . splice ( <NUM_LIT> , firstGoodIndex ) ; <EOL> } <EOL> pastEvents . push ( event ) ; <EOL> } <EOL> function isSubscribeRequest ( request ) { <EOL> return   ! Array . isArray ( request ) & & request . method == = "<STR_LIT>" ; <EOL> } <EOL> function isUnsubscribeRequest ( request ) { <EOL> return   ! Array . isArray ( request ) & & request . method == = "<STR_LIT>" ; <EOL> } <EOL> function getNewHeadsBlockNumber ( event ) { <EOL> return fromHex ( event . number ) ; <EOL> } <EOL> function getLogsBlockNumber ( event ) { <EOL> return fromHex ( event . blockNumber ) ; <EOL> } <EOL> function noop ( ) { } </s>
<s> import { <EOL> oppa <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> BaseError , <EOL> formatError <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> convert <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Config <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> findPackageJsonFile , <EOL> readJson , <EOL> stripUndefined <EOL> } from "<STR_LIT>" ; <EOL> const pkgJson = readJson ( findPackageJsonFile ( __dirname )   ? ? '<STR_LIT>' ) ; <EOL> const parsed = oppa ( { <EOL> name : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> version : pkgJson . version , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> alias : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> alias : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" + "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" + "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> default : true , <EOL> realDefault : undefined , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> default : true , <EOL> realDefault : undefined , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> default : true , <EOL> realDefault : undefined , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> default : true , <EOL> realDefault : undefined , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" + "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> alias : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> default : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> default : false , <EOL> description : "<STR_LIT>" , <EOL> } ) . add ( { <EOL> name : "<STR_LIT>" , <EOL> type : "<STR_LIT>" , <EOL> default : "<STR_LIT>" , <EOL> description : "<STR_LIT>" , <EOL> } ) . parse ( ) ; <EOL> const split = ( value ) = > value . split ( "<STR_LIT>" ) . map ( value = > value . trim ( ) ) ; <EOL> const { <EOL> args <EOL> } = parsed ; <EOL> const { <EOL> file , <EOL> config : configFile , <EOL> tsconfig : tsConfigPath , <EOL> "<STR_LIT>" : sortProperties , <EOL> "<STR_LIT>" : asComment , <EOL> "<STR_LIT>" : typeCheck , <EOL> "<STR_LIT>" : detectGraphQL , <EOL> "<STR_LIT>" : graphQLExpandedTypesCommas , <EOL> "<STR_LIT>" : graphQLRemovePropsCommas , <EOL> "<STR_LIT>" : expandTypesCommas , <EOL> "<STR_LIT>" : removePropsCommas , <EOL> types : typesCommas , <EOL> "<STR_LIT>" : jsonFormat , <EOL> "<STR_LIT>" : modelVersion , <EOL> } = args ; <EOL> const skipTypeCheck = typeCheck == null   ? undefined :   ! typeCheck ; <EOL> const graphQLExpandedTypes = graphQLExpandedTypesCommas == null   ? undefined : split ( graphQLExpandedTypesCommas ) ; <EOL> const graphQLRemoveProps = graphQLRemovePropsCommas == null   ? undefined : split ( graphQLRemovePropsCommas ) ; <EOL> const expandTypes = expandTypesCommas == null   ? undefined : split ( expandTypesCommas ) ; <EOL> const removeProps = removePropsCommas == null   ? undefined : split ( removePropsCommas ) ; <EOL> const types = typesCommas == null   ? undefined : split ( typesCommas ) ; <EOL> const config = stripUndefined ( { <EOL> path : file , <EOL> configFile , <EOL> tsConfigPath , <EOL> sortProperties , <EOL> asComment , <EOL> skipTypeCheck , <EOL> detectGraphQL , <EOL> graphQLExpandedTypes , <EOL> graphQLRemoveProps , <EOL> expandTypes , <EOL> removeProps , <EOL> types , <EOL> jsonFormat , <EOL> modelVersion , <EOL> } ) ; <EOL> try { <EOL> console . log ( convert ( config ) ) ; <EOL> } catch ( error ) { <EOL> if ( error instanceof BaseError ) { <EOL> process . stderr . write ( formatError ( error ) ) ; <EOL> process . exit ( <NUM_LIT> ) ; <EOL> } else { <EOL> throw error ; <EOL> } <EOL> } </s>
<s> import { <EOL> ChecksumException <EOL> } from '<STR_LIT>' ; <EOL> import Random from '<STR_LIT>' ; <EOL> import { <EOL> PDF417DecoderErrorCorrection <EOL> } from '<STR_LIT>' ; <EOL> import * as assert from '<STR_LIT>' ; <EOL> import AbstractErrorCorrectionSpec from '<STR_LIT>' ; <EOL> author Sean Owen <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const received = Int32Array . from ( PDF417_TEST_WITH_EC ) ; <EOL> checkDecode ( received ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const random = AbstractErrorCorrectionSpec . getRandom ( ) ; <EOL> for ( let i = <NUM_LIT> ; i < PDF417_TEST_WITH_EC . length ; i + + ) { <EOL> const received = Int32Array . from ( PDF417_TEST_WITH_EC ) ; <EOL> received [ i ] = random . nextInt ( <NUM_LIT> ) ; <EOL> checkDecode ( received ) ; <EOL> } <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const random = AbstractErrorCorrectionSpec . getRandom ( ) ; <EOL> for ( let testIterations = <NUM_LIT> ; testIterations < <NUM_LIT> ; testIterations + + ) { <EOL> const received = Int32Array . from ( PDF417_TEST_WITH_EC ) ; <EOL> AbstractErrorCorrectionSpec . corrupt ( received , MAX_ERRORS , random ) ; <EOL> checkDecode ( received ) ; <EOL> } <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const received = Int32Array . from ( PDF417_TEST_WITH_EC ) ; <EOL> const random = AbstractErrorCorrectionSpec . getRandom ( ) ; <EOL> AbstractErrorCorrectionSpec . corrupt ( received , MAX_ERRORS + <NUM_LIT> , random ) ; <EOL> try { <EOL> checkDecode ( received ) ; <EOL> assert . fail ( '<STR_LIT>' ) ; <EOL> } catch ( ce ) { <EOL> if ( ce instanceof ChecksumException ) { <EOL> return ; <EOL> } <EOL> throw ce ; <EOL> } <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> return ; <EOL> const random = AbstractErrorCorrectionSpec . getRandom ( ) ; <EOL> for ( const test of PDF417_TEST ) { <EOL> const received = Int32Array . from ( PDF417_TEST_WITH_EC ) ; <EOL> const erasures = AbstractErrorCorrectionSpec . erase ( received , MAX_ERASURES , random ) ; <EOL> checkDecode ( received , erasures ) ; <EOL> } <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const random = AbstractErrorCorrectionSpec . getRandom ( ) ; <EOL> const received = Int32Array . from ( PDF417_TEST_WITH_EC ) ; <EOL> const erasures = AbstractErrorCorrectionSpec . erase ( received , MAX_ERASURES + <NUM_LIT> , random ) ; <EOL> try { <EOL> checkDecode ( received , erasures ) ; <EOL> assert . fail ( '<STR_LIT>' ) ; <EOL> } catch ( ce ) { <EOL> if ( ce instanceof ChecksumException ) { <EOL> return ; <EOL> } <EOL> throw ce ; <EOL> } <EOL> } ) ; <EOL> } ) ; <EOL> const PDF417_TEST = Int32Array . from ( [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] ) ; <EOL> const PDF417_TEST_WITH_EC = Int32Array . from ( [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] ) ; <EOL> const ECC_BYTES = PDF417_TEST_WITH_EC . length - PDF417_TEST . length ; <EOL> const ERROR_LIMIT = ECC_BYTES ; <EOL> const MAX_ERRORS = ERROR_LIMIT / <NUM_LIT> ; <EOL> const MAX_ERASURES = ERROR_LIMIT ; <EOL> const ec = new PDF417DecoderErrorCorrection ( ) ; <EOL> throws <EOL> function checkDecode ( received , erasures   ? ) { <EOL> ec . decode ( received , ECC_BYTES , erasures | | Int32Array . from ( [ <NUM_LIT> ] ) ) ; <EOL> for ( let i = <NUM_LIT> ; i < PDF417_TEST . length ; i + + ) { <EOL> assert . strictEqual ( received [ i ] , PDF417_TEST [ i ] ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Filter , <EOL> isPhrasesFilter <EOL> } from '<STR_LIT>' ; <EOL> export const mapPhrases = ( filter ) = > { <EOL> if ( ! isPhrasesFilter ( filter ) ) { <EOL> throw filter ; <EOL> } <EOL> const { <EOL> type , <EOL> key , <EOL> value , <EOL> params <EOL> } = filter . meta ; <EOL> return { <EOL> type , <EOL> key , <EOL> value , <EOL> params <EOL> } ; <EOL> } ; </s>
<s> import { <EOL> isFunction <EOL> } from '<STR_LIT>' ; <EOL> type FilterFunc < P extends keyof T , T > = ( item : T [ P ] ) = > boolean ; <EOL> returns <EOL> export function propFilter < P extends string > ( prop ) { <EOL> param { <EOL> array <EOL> } <EOL> list param { <EOL> function | array | string <EOL> } <EOL> filters <EOL> return { <EOL> array <EOL> } <EOL> return function filterByName < T extends { <EOL> [ key in P ] : T [ P ] ; <EOL> } > ( list , filters = [ ] ) : T [ ] { <EOL> if ( isFunction ( filters ) ) { <EOL> return list . filter ( ( item ) = > ( filters as FilterFunc < P , T > ) ( item [ prop ] ) ) ; <EOL> } <EOL> if ( ! Array . isArray ( filters ) ) { <EOL> filters = filters . split ( '<STR_LIT>' ) ; <EOL> } <EOL> if ( filters . length == = <NUM_LIT> ) { <EOL> return list ; <EOL> } <EOL> if ( filters . includes ( '<STR_LIT>' ) ) { <EOL> return list ; <EOL> } <EOL> const options = filters . reduce ( ( acc , filter ) = > { <EOL> let type = '<STR_LIT>' ; <EOL> let value = filter ; <EOL> if ( filter . charAt ( <NUM_LIT> ) == = '<STR_LIT>' ) { <EOL> type = '<STR_LIT>' ; <EOL> value = filter . substr ( <NUM_LIT> ) ; <EOL> } <EOL> if ( ! acc [ type ] ) { <EOL> acc [ type ] = [ ] ; <EOL> } <EOL> acc [ type ] . push ( value ) ; <EOL> return acc ; <EOL> } , { } <EOL> as { <EOL> [ type ] : string [ ] ; <EOL> } ) ; <EOL> return list . filter ( ( item ) = > { <EOL> const value = item [ prop ] ; <EOL> const excluded = options . exclude & & options . exclude . includes ( value ) ; <EOL> if ( excluded ) { <EOL> return false ; <EOL> } <EOL> const included =   ! options . include | | options . include . includes ( value ) ; <EOL> if ( included ) { <EOL> return true ; <EOL> } <EOL> return false ; <EOL> } ) ; <EOL> } ; <EOL> } </s>
<s> import { <EOL> ImageStyle , <EOL> RegisteredStyle , <EOL> StyleSheet , <EOL> TextStyle , <EOL> ViewStyle <EOL> } from '<STR_LIT>' ; <EOL> export { <EOL> RegisteredStyle , <EOL> ViewStyle , <EOL> TextStyle , <EOL> ImageStyle <EOL> } ; <EOL> export const style = StyleSheet . create ( { <EOL> modalContainer : { <EOL> flex : <NUM_LIT> <EOL> } , <EOL> searchBarContainer : { <EOL> padding : <NUM_LIT> , <EOL> borderBottomWidth : <NUM_LIT> , <EOL> borderBottomColor : '<STR_LIT>' <EOL> } , <EOL> resultsContainer : { } , <EOL> resultItem : { <EOL> padding : <NUM_LIT> , <EOL> borderBottomWidth : <NUM_LIT> , <EOL> borderBottomColor : '<STR_LIT>' <EOL> } , <EOL> recentSearchContainer : { <EOL> padding : <NUM_LIT> , <EOL> paddingBottom : <NUM_LIT> , <EOL> borderBottomWidth : <NUM_LIT> , <EOL> borderBottomColor : '<STR_LIT>' , <EOL> flexDirection : '<STR_LIT>' , <EOL> justifyContent : '<STR_LIT>' , <EOL> alignItems : '<STR_LIT>' <EOL> } , <EOL> recentSearchClearText : { } , <EOL> recentSearch : { <EOL> fontSize : <NUM_LIT> , <EOL> color : '<STR_LIT>' <EOL> } , <EOL> suggestionTitle : { } , <EOL> suggestionHighlight : { <EOL> fontWeight : '<STR_LIT>' <EOL> } <EOL> } ) ; </s>
<s> import React from "<STR_LIT>" ; <EOL> import { <EOL> StyledCheckbox , <EOL> StyledCheckboxBox , <EOL> StyledCheckboxLabel <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> CheckboxProps <EOL> } from "<STR_LIT>" ; <EOL> export const Radio = React . forwardRef < HTMLInputElement , <EOL> CheckboxProps > ( ( { <EOL> id , <EOL> label , <EOL> name , <EOL> disabled , <EOL> asPrimary , <EOL> ... props <EOL> } , ref ) = > { <EOL> return ( < StyledCheckbox htmlFor = { id } disabled = { disabled } tabIndex = { <NUM_LIT> } asPrimary = { asPrimary } > < input type = "<STR_LIT>" name = { name } id = { id } ref = { ref } disabled = { disabled } { ... props } / > < StyledCheckboxBox / > < StyledCheckboxLabel > { label } < / StyledCheckboxLabel > < / StyledCheckbox > ) ; } ) ; Radio . defaultProps = { asPrimary : true , } ; export default React . memo ( Radio ) ; </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import { <EOL> useQueryParams , <EOL> StringParam , <EOL> NumberParam , <EOL> JsonParam , <EOL> } from '<STR_LIT>' ; <EOL> const UseQueryParamsExample = ( ) = > { <EOL> const [ count , setCount ] = React . useState ( <NUM_LIT> ) ; <EOL> const [ query , setQuery ] = useQueryParams ( { <EOL> zzz : NumberParam , <EOL> test : StringParam , <EOL> anyp : StringParam , <EOL> json : JsonParam , <EOL> } ) ; <EOL> const { <EOL> zzz , <EOL> test , <EOL> anyp , <EOL> json <EOL> } = query ; <EOL> return ( < div className = "<STR_LIT>" > < h2 > useQueryParams Example < / h2 > < div > < button onClick = { ( ) = > setCount ( count + <NUM_LIT> ) } > Click to change component state and cause a re - render : { count } < / button > < / div > < div > < table > < tbody > < tr > < td > zzz < / td > < td > { zzz } < / td > < td > { typeof zzz } < / td > < td > < button onClick = { ( ) = > setQuery ( { zzz : Math . floor ( Math . random ( ) * <NUM_LIT> ) } ) } > Change < / button > < / td > < / tr > < tr > < td > test < / td > < td > { test } < / td > < td > { typeof test } < / td > < td > < button onClick = { ( ) = > setQuery ( { test : '<STR_LIT>' + Math . floor ( Math . random ( ) * <NUM_LIT> ) } ) } > Change < / button > < button onClick = { ( ) = > setQuery ( { zzz : Math . floor ( Math . random ( ) * <NUM_LIT> ) , test : '<STR_LIT>' + Math . floor ( Math . random ( ) * <NUM_LIT> ) , } ) } > Change test + zzz < / button > < / td > < / tr > < tr > < td > anyp < / td > < td > { anyp } < / td > < td > { typeof anyp } < / td > < td > < button onClick = { ( ) = > setQuery ( { anyp : '<STR_LIT>' + Math . floor ( Math . random ( ) * <NUM_LIT> ) } ) } > Change < / button > < button onClick = { ( ) = > setQuery ( { anyp : '<STR_LIT>' + Math . floor ( Math . random ( ) * <NUM_LIT> ) } , '<STR_LIT>' ) } > Change Push < / button > < / td > < / tr > < tr > < td > json < / td > < td > { JSON . stringify ( json ) } < / td > < td > { typeof json } < / td > < td > < button onClick = { ( ) = > setQuery ( { json : { foo : [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , bar : { abc : '<STR_LIT>' } , rand : '<STR_LIT>' + Math . floor ( Math . random ( ) * <NUM_LIT> ) , } , } ) } > Change < / button > < button onClick = { ( ) = > setQuery ( { json : { foo : [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , bar : { abc : '<STR_LIT>' } , rand : '<STR_LIT>' + Math . floor ( Math . random ( ) * <NUM_LIT> ) , } , } , '<STR_LIT>' ) } > Change Push < / button > < / td > < / tr > < / tbody > < / table > < / div > < / div > ) ; } ; export default UseQueryParamsExample ; </s>
<s> import { <EOL> Connection , <EOL> Repository <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Product <EOL> } from '<STR_LIT>' ; <EOL> export const ProductProvider = [ { <EOL> provide : '<STR_LIT>' , <EOL> useFactory : ( connection ) = > connection . getRepository ( Product ) , <EOL> inject : [ '<STR_LIT>' ] , <EOL> } ] ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . SUM > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , AggArgs , Output > ; <EOL> export const aggSum = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> field : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . SUM , <EOL> params : { <EOL> ... rest , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> Severity <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> generateHTMLPage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getHintPath , <EOL> HintTest , <EOL> testHint <EOL> } from '<STR_LIT>' ; <EOL> const hintPath = getHintPath ( __filename ) ; <EOL> const htmlPageWithScript = generateHTMLPage ( undefined , '<STR_LIT>' ) ; <EOL> const htmlPageWithManifest = generateHTMLPage ( '<STR_LIT>' ) ; <EOL> const generateErrorMessage = ( values ) : string = > { <EOL> return   ` Response should not include disallowed headers :   $ { values . join ( '<STR_LIT>' ) } ` ; <EOL> } ; <EOL> const testsForDefaults = [ { <EOL> name :   ` HTML page is served without any of the disallowed headers ` , <EOL> serverConfig : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } , { <EOL> name :   ` Manifest is served without any of the disallowed headers ` , <EOL> serverConfig : { <EOL> '<STR_LIT>' : htmlPageWithManifest , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } , { <EOL> name :   ` Resource is served without any of the disallowed headers ` , <EOL> serverConfig : { <EOL> '<STR_LIT>' : htmlPageWithScript , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } , { <EOL> name :   ` Resource is specified as a data URI ` , <EOL> serverConfig : { <EOL> '<STR_LIT>' : generateHTMLPage ( undefined , '<STR_LIT>' ) <EOL> } <EOL> } , { <EOL> name :   ` HTML page is served with one disallowed header ` , <EOL> reports : [ { <EOL> message : generateErrorMessage ( [ '<STR_LIT>' ] ) , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } , { <EOL> name :   ` HTML page is served with multiple disallowed headers ` , <EOL> reports : [ { <EOL> message : generateErrorMessage ( [ '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Server : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } ] ; <EOL> const testsForDifferentServerHeaderValues = ( ( ) = > { <EOL> const allowedServerHeaderValues = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> const disallowedServerHeaderValues = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> const tests = [ ] ; <EOL> allowedServerHeaderValues . forEach ( ( value ) = > { <EOL> tests . push ( { <EOL> name :   ` HTML page is served with allowed '<STR_LIT>' ` , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Server : value <EOL> } <EOL> } <EOL> } <EOL> } ) ; <EOL> } ) ; <EOL> disallowedServerHeaderValues . forEach ( ( value ) = > { <EOL> tests . push ( { <EOL> name :   ` HTML page is served with disallowed '<STR_LIT>' ` , <EOL> reports : [ { <EOL> message :   ` The '<STR_LIT>' header should only contain the server name . ` , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Server : value <EOL> } <EOL> } <EOL> } <EOL> } ) ; <EOL> } ) ; <EOL> return tests ; <EOL> } ) ( ) ; <EOL> const testsForIgnoreConfigs = [ { <EOL> name :   ` HTML page is served with disallowed headers that are ignored because of configs ` , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Server : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } ] ; <EOL> const testsForIncludeConfigs = [ { <EOL> name :   ` HTML page is served with disallowed headers that are enforced because of configs ` , <EOL> reports : [ { <EOL> message : generateErrorMessage ( [ '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : htmlPageWithScript , <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Server : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } ] ; <EOL> const testsForConfigs = [ { <EOL> name :   ` HTML page is served with disallowed headers that are both ignored and enforced because of configs ` , <EOL> reports : [ { <EOL> message : generateErrorMessage ( [ '<STR_LIT>' , '<STR_LIT>' ] ) , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Server : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } ] ; <EOL> const testForSpecialHeaders = [ { <EOL> name :   ` HTML page is served with disallowed Expires header ` , <EOL> reports : [ { <EOL> message : '<STR_LIT>' , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Expires : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } , { <EOL> name :   ` HTML page is served with disallowed Host header ` , <EOL> reports : [ { <EOL> message : '<STR_LIT>' , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Host : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } , { <EOL> name :   ` HTML page is served with disallowed P3P header ` , <EOL> reports : [ { <EOL> message : '<STR_LIT>' , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> P3P : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } , { <EOL> name :   ` HTML page is served with disallowed Pragma header ` , <EOL> reports : [ { <EOL> message : '<STR_LIT>' , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Pragma : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } , { <EOL> name :   ` HTML page is served with disallowed Via header ` , <EOL> reports : [ { <EOL> message : '<STR_LIT>' , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Via : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } , { <EOL> name :   ` HTML page is served with disallowed X - Frame - Options header ` , <EOL> reports : [ { <EOL> message : '<STR_LIT>' , <EOL> severity : Severity . warning <EOL> } ] , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } ] ; <EOL> const testForIgnoredSpecialHeaders = [ { <EOL> name :   ` HTML page served with disallowed , but ignored , special headers does not lead to warnings ` , <EOL> serverConfig : { <EOL> '<STR_LIT>' : { <EOL> headers : { <EOL> Expires : '<STR_LIT>' , <EOL> Host : '<STR_LIT>' , <EOL> P3P : '<STR_LIT>' , <EOL> Pragma : '<STR_LIT>' , <EOL> Via : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' <EOL> } <EOL> } <EOL> } <EOL> } ] ; <EOL> testHint ( hintPath , testsForDefaults ) ; <EOL> testHint ( hintPath , testsForDifferentServerHeaderValues ) ; <EOL> testHint ( hintPath , testsForIgnoreConfigs , { <EOL> hintOptions : { <EOL> ignore : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> } <EOL> } ) ; <EOL> testHint ( hintPath , testsForIncludeConfigs , { <EOL> hintOptions : { <EOL> include : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> } <EOL> } ) ; <EOL> testHint ( hintPath , testsForConfigs , { <EOL> hintOptions : { <EOL> ignore : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> include : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> } <EOL> } ) ; <EOL> testHint ( hintPath , testForSpecialHeaders ) ; <EOL> testHint ( hintPath , testForIgnoredSpecialHeaders , { <EOL> hintOptions : { <EOL> ignore : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> } <EOL> } ) ; </s>
<s> import { <EOL> highlightTags <EOL> } from '<STR_LIT>' ; <EOL> const FRAGMENT_SIZE = Math . pow ( <NUM_LIT> , <NUM_LIT> ) - <NUM_LIT> ; <EOL> export function getHighlightRequest ( query , shouldHighlight ) { <EOL> if ( ! shouldHighlight ) return ; <EOL> return { <EOL> pre_tags : [ highlightTags . pre ] , <EOL> post_tags : [ highlightTags . post ] , <EOL> fields : { <EOL> '<STR_LIT>' : { } , <EOL> } , <EOL> fragment_size : FRAGMENT_SIZE , <EOL> } ; <EOL> } </s>
<s> import React , { <EOL> useEffect , <EOL> useCallback <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiFieldText , <EOL> EuiFormRow <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggParamEditorProps <EOL> } from '<STR_LIT>' ; <EOL> function StringParamEditor ( { <EOL> agg , <EOL> aggParam , <EOL> showValidation , <EOL> value , <EOL> setValidity , <EOL> setValue , <EOL> setTouched , <EOL> } ) { <EOL> const isValid = aggParam . required   ?   ! ! value : true ; <EOL> useEffect ( ( ) = > { <EOL> setValidity ( isValid ) ; <EOL> } , [ isValid , setValidity ] ) ; <EOL> const onChange = useCallback ( ( ev ) = > setValue ( ev . target . value ) , [ setValue ] ) ; <EOL> return ( < EuiFormRow className = "<STR_LIT>" label = { aggParam . displayName | | aggParam . name } fullWidth = { true } compressed isInvalid = { showValidation   ?   ! isValid : false } > < EuiFieldText value = { value | | '<STR_LIT>' } data - test - subj = {   ` visEditorStringInput $ { agg . id } $ { aggParam . name } ` } onChange = { onChange } fullWidth = { true } compressed onBlur = { setTouched } isInvalid = { showValidation   ?   ! isValid : false } / > < / EuiFormRow > ) ; } export { StringParamEditor } ; </s>
<s> import { <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> function useMedia ( query ) { <EOL> const [ matches , setMatches ] = useState ( true ) ; <EOL> return matches ; <EOL> } <EOL> export default useMedia ; </s>
<s> import dateMath from '<STR_LIT>' ; <EOL> import { <EOL> FILTER_OPERATORS , <EOL> Operator <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CidrMask , <EOL> isFilterable , <EOL> IIndexPattern , <EOL> IFieldType , <EOL> Ipv4Address , <EOL> Filter , <EOL> FieldFilter , <EOL> } from '<STR_LIT>' ; <EOL> export function getFieldFromFilter ( filter , indexPattern ) { <EOL> return indexPattern . fields . find ( ( field ) = > field . name == = filter . meta . key ) ; <EOL> } <EOL> export function getOperatorFromFilter ( filter ) { <EOL> return FILTER_OPERATORS . find ( ( operator ) = > { <EOL> return filter . meta . type == = operator . type & & filter . meta . negate == = operator . negate ; <EOL> } ) ; <EOL> } <EOL> export function getFilterableFields ( indexPattern ) { <EOL> return indexPattern . fields . filter ( isFilterable ) ; <EOL> } <EOL> export function getOperatorOptions ( field ) { <EOL> return FILTER_OPERATORS . filter ( ( operator ) = > { <EOL> return   ! operator . fieldTypes | | operator . fieldTypes . includes ( field . type ) ; <EOL> } ) ; <EOL> } <EOL> export function validateParams ( params , type ) { <EOL> switch ( type ) { <EOL> case '<STR_LIT>' : <EOL> const moment = typeof params == = '<STR_LIT>'   ? dateMath . parse ( params ) : null ; <EOL> return Boolean ( typeof params == = '<STR_LIT>' & & moment & & moment . isValid ( ) ) ; <EOL> case '<STR_LIT>' : <EOL> try { <EOL> return params . includes ( '<STR_LIT>' )   ? Boolean ( new CidrMask ( params ) ) : Boolean ( new Ipv4Address ( params ) ) ; <EOL> } catch ( e ) { <EOL> return false ; <EOL> } <EOL> default : <EOL> return true ; <EOL> } <EOL> } <EOL> export function isFilterValid ( indexPattern   ? , field   ? , operator   ? , params   ? ) { <EOL> if ( ! indexPattern | |   ! field | |   ! operator ) { <EOL> return false ; <EOL> } <EOL> switch ( operator . type ) { <EOL> case '<STR_LIT>' : <EOL> return validateParams ( params , field . type ) ; <EOL> case '<STR_LIT>' : <EOL> if ( ! Array . isArray ( params ) | |   ! params . length ) { <EOL> return false ; <EOL> } <EOL> return params . every ( ( phrase ) = > validateParams ( phrase , field . type ) ) ; <EOL> case '<STR_LIT>' : <EOL> if ( typeof params != = '<STR_LIT>' ) { <EOL> return false ; <EOL> } <EOL> return ( ( ! params . from | | validateParams ( params . from , field . type ) ) & & ( ! params . to | | validateParams ( params . to , field . type ) ) ) ; <EOL> case '<STR_LIT>' : <EOL> return true ; <EOL> default : <EOL> throw new Error ( ` Unknown operator type :   $ { operator . type } ` ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parentPipelineAggHelper <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> makeNestedLabel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggConfigSerialized , <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsDerivative extends BaseAggParams { <EOL> buckets_path : string ; customMetric   ? : AggConfigSerialized ; metricAgg   ? : string ; <EOL> } <EOL> const derivativeLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const derivativeTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export const getDerivativeMetricAgg = ( ) = > { <EOL> const { <EOL> subtype , <EOL> params , <EOL> getSerializedFormat <EOL> } = parentPipelineAggHelper ; <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . DERIVATIVE , <EOL> title : derivativeTitle , <EOL> makeLabel ( agg ) { <EOL> return makeNestedLabel ( agg , derivativeLabel ) ; <EOL> } , <EOL> subtype , <EOL> params : [ ... params ( ) ] , <EOL> getSerializedFormat , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> extend , <EOL> defaults <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getTimeZoneFromSettings <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DslQuery , <EOL> isOpenSearchQueryString <EOL> } from '<STR_LIT>' ; <EOL> param query param queryStringOptions param dateFormatTZ returns { <EOL> object <EOL> } <EOL> export function decorateQuery ( query , queryStringOptions , dateFormatTZ   ? ) { <EOL> if ( isOpenSearchQueryString ( query ) ) { <EOL> extend ( query . query_string , queryStringOptions ) ; <EOL> if ( dateFormatTZ ) { <EOL> defaults ( query . query_string , { <EOL> time_zone : getTimeZoneFromSettings ( dateFormatTZ ) , <EOL> } ) ; <EOL> } <EOL> } <EOL> return query ; <EOL> } </s>
<s> import { <EOL> EuiFormRow <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> InjectedIntl , <EOL> injectI18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> uniq <EOL> } from '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> import { <EOL> GenericComboBox , <EOL> GenericComboBoxProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PhraseSuggestorUI , <EOL> PhraseSuggestorProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> withOpenSearchDashboards <EOL> } from '<STR_LIT>' ; <EOL> interface Props extends PhraseSuggestorProps { <EOL> values   ? : string [ ] ; <EOL> onChange : ( values : string [ ] ) = > void ; <EOL> intl : InjectedIntl ; <EOL> } <EOL> class PhrasesValuesInputUI extends PhraseSuggestorUI < Props > { <EOL> public render ( ) { <EOL> const { <EOL> suggestions <EOL> } = this . state ; <EOL> const { <EOL> values , <EOL> intl , <EOL> onChange <EOL> } = this . props ; <EOL> const options = values   ? uniq ( [ ... values , ... suggestions ] ) : suggestions ; <EOL> return ( < EuiFormRow fullWidth = { true } label = { intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } > < StringComboBox placeholder = { intl . formatMessage ( { id : '<STR_LIT>' , defaultMessage : '<STR_LIT>' , } ) } fullWidth = { true } options = { options } getLabel = { ( option ) = > option } selectedOptions = { values | | [ ] } onSearchChange = { this . onSearchChange } onCreateOption = { ( option ) = > onChange ( [ ... ( values | | [ ] ) , option ] ) } onChange = { onChange } isClearable = { false } data - test - subj = "<STR_LIT>" / > < / EuiFormRow > ) ; } } function StringComboBox ( props ) { return GenericComboBox ( props ) ; } export const PhrasesValuesInput = injectI18n ( withOpenSearchDashboards ( PhrasesValuesInputUI ) ) ; </s>
<s> import { <EOL> last <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> htmlIdGenerator <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parseRange , <EOL> NumberListRange <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> NumberRowModel <EOL> } from '<STR_LIT>' ; <EOL> const EMPTY_STRING = '<STR_LIT>' ; <EOL> const defaultRange = parseRange ( '<STR_LIT>' ) ; <EOL> const generateId = htmlIdGenerator ( ) ; <EOL> const defaultModel = { <EOL> value : <NUM_LIT> , <EOL> id : generateId ( ) , <EOL> isInvalid : false <EOL> } ; <EOL> function parse ( value ) { <EOL> const parsedValue = parseFloat ( value ) ; <EOL> return isNaN ( parsedValue )   ? EMPTY_STRING : parsedValue ; <EOL> } <EOL> function getRange ( range   ? ) { <EOL> try { <EOL> return range   ? parseRange ( range ) : defaultRange ; <EOL> } catch ( e ) { <EOL> throw new TypeError ( '<STR_LIT>' + e . message ) ; <EOL> } <EOL> } <EOL> function validateValue ( value , numberRange ) { <EOL> const result = { <EOL> isInvalid : false , <EOL> } ; <EOL> if ( value == = EMPTY_STRING ) { <EOL> result . isInvalid = true ; <EOL> result . error = EMPTY_STRING ; <EOL> } else if ( ! numberRange . within ( value ) ) { <EOL> result . isInvalid = true ; <EOL> result . error = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> min : numberRange . min , <EOL> max : numberRange . max <EOL> } , <EOL> } ) ; <EOL> } <EOL> return result ; <EOL> } <EOL> function validateValueAscending ( inputValue , index , list ) { <EOL> const result = { <EOL> isInvalidOrder : false , <EOL> } ; <EOL> const previousModel = list [ index - <NUM_LIT> ] ; <EOL> if ( previousModel != = undefined & & inputValue != = undefined & & inputValue <= previousModel ) { <EOL> result . isInvalidOrder = true ; <EOL> result . error = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> } <EOL> return result ; <EOL> } <EOL> function validateValueUnique ( inputValue , index , list ) { <EOL> const result = { <EOL> isDuplicate : false , <EOL> } ; <EOL> if ( inputValue != = EMPTY_STRING & & list . indexOf ( inputValue ) != = index ) { <EOL> result . isDuplicate = true ; <EOL> result . error = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> } <EOL> return result ; <EOL> } <EOL> function getNextModel ( list , range ) { <EOL> const lastValue = ( last ( list ) as NumberRowModel ) . value ; <EOL> let next = Number ( lastValue )   ? Number ( lastValue ) + <NUM_LIT> : <NUM_LIT> ; <EOL> if ( next >= range . max ) { <EOL> next = range . max - <NUM_LIT> ; <EOL> } <EOL> return { <EOL> id : generateId ( ) , <EOL> value : next , <EOL> isInvalid : false , <EOL> } ; <EOL> } <EOL> function getInitModelList ( list ) { <EOL> return list . length   ? list . map ( ( num ) = > ( { <EOL> value : ( num == = undefined   ? EMPTY_STRING : num ) as NumberRowModel [ '<STR_LIT>' ] , <EOL> id : generateId ( ) , <EOL> isInvalid : false , <EOL> } ) ) : [ defaultModel ] ; <EOL> } <EOL> function getValidatedModels ( numberList , modelList , numberRange , validateAscendingOrder = false , disallowDuplicates = false ) { <EOL> if ( ! numberList . length ) { <EOL> return [ defaultModel ] ; <EOL> } <EOL> return numberList . map ( ( number , index ) = > { <EOL> const model = modelList [ index ] | | { <EOL> id : generateId ( ) <EOL> } ; <EOL> const newValue = number == = undefined   ? EMPTY_STRING : number ; <EOL> const valueResult = numberRange   ? validateValue ( newValue , numberRange ) : { <EOL> isInvalid : false <EOL> } ; <EOL> const ascendingResult = validateAscendingOrder   ? validateValueAscending ( newValue , index , numberList ) : { <EOL> isInvalidOrder : false <EOL> } ; <EOL> const duplicationResult = disallowDuplicates   ? validateValueUnique ( newValue , index , numberList ) : { <EOL> isDuplicate : false <EOL> } ; <EOL> const allErrors = [ valueResult . error , ascendingResult . error , duplicationResult . error ] . filter ( Boolean ) . join ( '<STR_LIT>' ) ; <EOL> return { <EOL> ... model , <EOL> value : newValue , <EOL> isInvalid : valueResult . isInvalid | | ascendingResult . isInvalidOrder | | duplicationResult . isDuplicate , <EOL> error : allErrors == = EMPTY_STRING   ? undefined : allErrors , <EOL> } ; <EOL> } ) ; <EOL> } <EOL> function hasInvalidValues ( modelList ) { <EOL> return   ! ! modelList . find ( ( { <EOL> isInvalid <EOL> } ) = > isInvalid ) ; <EOL> } <EOL> export { <EOL> EMPTY_STRING , <EOL> parse , <EOL> getRange , <EOL> validateValue , <EOL> getNextModel , <EOL> getInitModelList , <EOL> getValidatedModels , <EOL> hasInvalidValues , <EOL> } ; </s>
<s> import React , { <EOL> useState , <EOL> useEffect , <EOL> Fragment , <EOL> useCallback <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isEmpty , <EOL> isEqual , <EOL> mapValues , <EOL> omitBy , <EOL> pick <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiButtonIcon , <EOL> EuiFlexGroup , <EOL> EuiFlexItem , <EOL> EuiSpacer , <EOL> htmlIdGenerator , <EOL> EuiButtonEmpty , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> export interface InputListConfig { <EOL> defaultValue : InputItemModel ; validateClass : new ( value ) = > { <EOL> toString ( ) : string ; <EOL> } ; getModelValue ( item   ? ) : InputItemModel ; getRemoveBtnAriaLabel ( model ) : string ; onChangeFn ( model ) : InputObject ; hasInvalidValuesFn ( model ) : boolean ; renderInputRow ( model , index , onChangeFn ) : React . ReactNode ; modelNames : string | string [ ] ; <EOL> } <EOL> interface InputModelBase { <EOL> id : string ; <EOL> } <EOL> export type InputObject = object ; <EOL> export interface InputItem { <EOL> model : string ; value : string ; isInvalid : boolean ; <EOL> } <EOL> interface InputItemModel { <EOL> [ model ] : InputItem ; <EOL> } <EOL> export type InputModel = InputModelBase & InputItemModel ; <EOL> interface InputListProps { <EOL> config : InputListConfig ; list : InputObject [ ] ; onChange ( list ) : void ; setValidity ( isValid ) : void ; <EOL> } <EOL> const generateId = htmlIdGenerator ( ) ; <EOL> const validateValue = ( inputValue , InputObject ) = > { <EOL> const result = { <EOL> model : inputValue | | '<STR_LIT>' , <EOL> isInvalid : false , <EOL> } ; <EOL> if ( ! inputValue ) { <EOL> result . isInvalid = false ; <EOL> return result ; <EOL> } <EOL> try { <EOL> result . model = new InputObject ( inputValue ) . toString ( ) ; <EOL> result . isInvalid = false ; <EOL> return result ; <EOL> } catch ( e ) { <EOL> result . isInvalid = true ; <EOL> return result ; <EOL> } <EOL> } ; <EOL> function InputList ( { <EOL> config , <EOL> list , <EOL> onChange , <EOL> setValidity <EOL> } ) { <EOL> const { <EOL> defaultValue , <EOL> getModelValue , <EOL> modelNames , <EOL> onChangeFn , <EOL> validateClass <EOL> } = config ; <EOL> const [ models , setModels ] = useState ( ( ) = > list . map ( ( item ) = > ( { <EOL> id : generateId ( ) , <EOL> ... getModelValue ( item ) , <EOL> } <EOL> as InputModel ) ) ) ; <EOL> const hasInvalidValues = models . some ( config . hasInvalidValuesFn ) ; <EOL> const updateValues = useCallback ( ( modelList ) = > { <EOL> setModels ( modelList ) ; <EOL> onChange ( modelList . map ( onChangeFn ) ) ; <EOL> } , [ onChangeFn , onChange ] ) ; <EOL> const onChangeValue = useCallback ( ( index , value , modelName ) = > { <EOL> const { <EOL> model , <EOL> isInvalid <EOL> } = validateValue ( value , validateClass ) ; <EOL> updateValues ( models . map ( ( range , arrayIndex ) = > arrayIndex == = index   ? { <EOL> ... range , <EOL> [ modelName ] : { <EOL> value , <EOL> model , <EOL> isInvalid , <EOL> } , <EOL> } : range ) ) ; <EOL> } , [ models , updateValues , validateClass ] ) ; <EOL> const onDelete = useCallback ( ( id ) = > updateValues ( models . filter ( ( model ) = > model . id != = id ) ) , [ models , updateValues ] ) ; <EOL> const onAdd = useCallback ( ( ) = > updateValues ( [ ... models , { <EOL> id : generateId ( ) , <EOL> ... getModelValue ( ) , <EOL> } <EOL> as InputModel , <EOL> ] ) , [ getModelValue , models , updateValues ] ) ; <EOL> useEffect ( ( ) = > { <EOL> if ( ! list . length ) { <EOL> updateValues ( [ { <EOL> id : generateId ( ) , <EOL> ... defaultValue , <EOL> } <EOL> as InputModel , <EOL> ] ) ; <EOL> } <EOL> } , [ defaultValue , list . length , updateValues ] ) ; <EOL> useEffect ( ( ) = > { <EOL> setValidity ( ! hasInvalidValues ) ; <EOL> } , [ hasInvalidValues , setValidity ] ) ; <EOL> useEffect ( ( ) = > { <EOL> if ( list . length != = models . length | | list . some ( ( item , index ) = > { <EOL> const model = mapValues ( pick ( models [ index ] , modelNames ) , '<STR_LIT>' ) ; <EOL> return   ! isEqual ( item , omitBy ( model , isEmpty ) ) ; <EOL> } ) ) { <EOL> setModels ( list . map ( ( item ) = > ( { <EOL> id : generateId ( ) , <EOL> ... getModelValue ( item ) , <EOL> } <EOL> as InputModel ) ) ) ; <EOL> } <EOL> } , [ getModelValue , list , modelNames , models ] ) ; <EOL> return ( < > { models . map ( ( item , index ) = > ( < Fragment key = { item . id } > < EuiFlexGroup gutterSize = "<STR_LIT>" alignItems = "<STR_LIT>" responsive = { false } > { config . renderInputRow ( item , index , onChangeValue ) } < EuiFlexItem grow = { false } > < EuiButtonIcon aria - label = { config . getRemoveBtnAriaLabel ( item ) } title = { config . getRemoveBtnAriaLabel ( item ) } disabled = { models . length == = <NUM_LIT> } color = "<STR_LIT>" iconType = "<STR_LIT>" onClick = { ( ) = > onDelete ( item . id ) } / > < / EuiFlexItem > < / EuiFlexGroup > < EuiSpacer size = "<STR_LIT>" / > < / Fragment > ) ) } < EuiSpacer size = "<STR_LIT>" / > < EuiFlexItem > < EuiButtonEmpty iconType = "<STR_LIT>" onClick = { onAdd } size = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiButtonEmpty > < / EuiFlexItem > < / > ) ; } export { InputList } ; </s>
<s> export const colors = { <EOL> primary : { <EOL> BLACK : "<STR_LIT>" , <EOL> CIVIL_GRAY_0 : "<STR_LIT>" , <EOL> CIVIL_GRAY_1 : "<STR_LIT>" , <EOL> CIVIL_GRAY_2 : "<STR_LIT>" , <EOL> CIVIL_BLUE_1 : "<STR_LIT>" , <EOL> } , <EOL> accent : { <EOL> CIVIL_YELLOW : "<STR_LIT>" , <EOL> CIVIL_YELLOW_VERY_FADED : "<STR_LIT>" , <EOL> CIVIL_BLUE : "<STR_LIT>" , <EOL> CIVIL_BLUE_FADED : "<STR_LIT>" , <EOL> CIVIL_BLUE_VERY_FADED : "<STR_LIT>" , <EOL> CIVIL_BLUE_VERY_FADED_2 : "<STR_LIT>" , <EOL> CIVIL_BLUE_FADED_2 : "<STR_LIT>" , <EOL> CIVIL_TEAL : "<STR_LIT>" , <EOL> CIVIL_TEAL_FADED : "<STR_LIT>" , <EOL> CIVIL_TEAL_FADED_2 : "<STR_LIT>" , <EOL> CIVIL_TEAL_DARK : "<STR_LIT>" , <EOL> CIVIL_RED : "<STR_LIT>" , <EOL> CIVIL_RED_2 : "<STR_LIT>" , <EOL> CIVIL_RED_FADED : "<STR_LIT>" , <EOL> CIVIL_RED_VERY_FADED : "<STR_LIT>" , <EOL> CIVIL_RED_ULTRA_FADED : "<STR_LIT>" , <EOL> CIVIL_GRAY_0 : "<STR_LIT>" , <EOL> CIVIL_GRAY_1 : "<STR_LIT>" , <EOL> CIVIL_GRAY_2 : "<STR_LIT>" , <EOL> CIVIL_GRAY_3 : "<STR_LIT>" , <EOL> CIVIL_GRAY_4 : "<STR_LIT>" , <EOL> CIVIL_GRAY_5 : "<STR_LIT>" , <EOL> CIVIL_GRAY_6 : "<STR_LIT>" , <EOL> CIVIL_GRAY_7 : "<STR_LIT>" , <EOL> CIVIL_ORANGE : "<STR_LIT>" , <EOL> CIVIL_GREEN : "<STR_LIT>" , <EOL> CIVIL_GREEN_1 : "<STR_LIT>" , <EOL> CIVIL_GREEN_2 : "<STR_LIT>" , <EOL> CIVIL_PURPLE_1 : "<STR_LIT>" , <EOL> } , <EOL> basic : { <EOL> WHITE : "<STR_LIT>" , <EOL> } , <EOL> } ; </s>
<s> interface DocvalueField { <EOL> field : string ; <EOL> [ key ] : unknown ; <EOL> } <EOL> export function filterDocvalueFields ( docvalueFields , fields ) { <EOL> return docvalueFields . filter ( ( docValue ) = > { <EOL> const docvalueFieldName = typeof docValue == = '<STR_LIT>'   ? docValue : docValue . field ; <EOL> return fields . includes ( docvalueFieldName ) ; <EOL> } ) ; <EOL> } </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Effect <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataPersistence <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fromSettingsActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SettingsPartialState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SettingsDataService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class SettingsEffects { <EOL> @ Effect ( ) getSettingModelCollection $ = this . dp . fetch ( fromSettingsActions . Types . GetSettingModelCollection , { <EOL> id : ( ) = > { } , <EOL> run : ( action ) = > { <EOL> return this . settingsDataService . getSettingModelCollection ( ) . pipe ( map ( data = > new fromSettingsActions . GetSettingModelCollectionSuccess ( data ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromSettingsActions . GetSettingModelCollectionFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> @ Effect ( ) updateSettingModel $ = this . dp . pessimisticUpdate ( fromSettingsActions . Types . UpdateSettingModel , { <EOL> run : ( action ) = > { <EOL> return this . settingsDataService . updateSettingModel ( action . payload ) . pipe ( map ( data = > new fromSettingsActions . UpdateSettingModelSuccess ( action . payload ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromSettingsActions . UpdateSettingModelFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> constructor ( private dp , private settingsDataService ) { } <EOL> } </s>
<s> import * as ast from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> KueryNode <EOL> } from '<STR_LIT>' ; <EOL> export function buildNodeParams ( children ) { <EOL> return { <EOL> arguments : children , <EOL> } ; <EOL> } <EOL> export function toOpenSearchQuery ( node , indexPattern   ? , config = { } , context = { } ) { <EOL> const children = node . arguments | | [ ] ; <EOL> return { <EOL> bool : { <EOL> filter : children . map ( ( child ) = > { <EOL> return ast . toOpenSearchQuery ( child , indexPattern , config , context ) ; <EOL> } ) , <EOL> } , <EOL> } ; <EOL> } </s>
<s> import { <EOL> MonoTypeOperatorFunction , <EOL> queueScheduler , <EOL> scheduled , <EOL> from <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> concatAll , <EOL> distinctUntilChanged , <EOL> skip <EOL> } from '<STR_LIT>' ; <EOL> export function distinctUntilChangedWithInitialValue < T > ( initialValue , compare   ? ) { <EOL> return ( input $ ) = > scheduled ( [ isPromise ( initialValue )   ? from ( initialValue ) : [ initialValue ] , input $ ] , queueScheduler ) . pipe ( concatAll ( ) , distinctUntilChanged ( compare ) , skip ( <NUM_LIT> ) ) ; <EOL> } <EOL> function isPromise < T > ( value ) { <EOL> return ( ! ! value & & typeof value == = '<STR_LIT>' & & '<STR_LIT>' in value & & typeof value . then == = '<STR_LIT>' & &   ! ( '<STR_LIT>' in value ) ) ; <EOL> } </s>
<s> import React , { <EOL> Fragment , <EOL> useState , <EOL> useEffect , <EOL> useMemo , <EOL> useCallback <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiSpacer , <EOL> EuiButtonEmpty , <EOL> EuiFlexItem , <EOL> EuiFormErrorText <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> NumberRow , <EOL> NumberRowModel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parse , <EOL> EMPTY_STRING , <EOL> getRange , <EOL> getNextModel , <EOL> getInitModelList , <EOL> getValidatedModels , <EOL> hasInvalidValues , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> useValidation <EOL> } from '<STR_LIT>' ; <EOL> export interface NumberListProps { <EOL> labelledbyId : string ; numberArray : Array < number | undefined > ; range   ? : string ; showValidation : boolean ; disallowDuplicates   ? : boolean ; unitName : string ; validateAscendingOrder   ? : boolean ; onChange ( list ) : void ; setTouched ( ) : void ; setValidity ( isValid ) : void ; <EOL> } <EOL> function NumberList ( { <EOL> labelledbyId , <EOL> numberArray , <EOL> range , <EOL> showValidation , <EOL> unitName , <EOL> validateAscendingOrder = false , <EOL> disallowDuplicates = false , <EOL> onChange , <EOL> setTouched , <EOL> setValidity , <EOL> } ) { <EOL> const numberRange = useMemo ( ( ) = > getRange ( range ) , [ range ] ) ; <EOL> const [ models , setModels ] = useState ( getInitModelList ( numberArray ) ) ; <EOL> useEffect ( ( ) = > { <EOL> setModels ( ( state ) = > getValidatedModels ( numberArray , state , numberRange , validateAscendingOrder , disallowDuplicates ) ) ; <EOL> } , [ numberArray , numberRange , validateAscendingOrder , disallowDuplicates ] ) ; <EOL> useEffect ( ( ) = > { <EOL> if ( ! numberArray . length ) { <EOL> onChange ( [ models [ <NUM_LIT> ] . value as number ] ) ; <EOL> } <EOL> } , [ models , numberArray . length , onChange ] ) ; <EOL> const isValid =   ! hasInvalidValues ( models ) ; <EOL> useValidation ( setValidity , isValid ) ; <EOL> const onUpdate = useCallback ( ( modelList ) = > { <EOL> setModels ( modelList ) ; <EOL> onChange ( modelList . map ( ( { <EOL> value <EOL> } ) = > ( value == = EMPTY_STRING   ? undefined : value ) ) ) ; <EOL> } , [ onChange ] ) ; <EOL> const onChangeValue = useCallback ( ( { <EOL> id , <EOL> value <EOL> } ) = > { <EOL> const parsedValue = parse ( value ) ; <EOL> onUpdate ( models . map ( ( model ) = > { <EOL> if ( model . id == = id ) { <EOL> return { <EOL> id , <EOL> value : parsedValue , <EOL> isInvalid : false , <EOL> } ; <EOL> } <EOL> return model ; <EOL> } ) ) ; <EOL> } , [ models , onUpdate ] ) ; <EOL> const onAdd = useCallback ( ( ) = > { <EOL> const newArray = [ ... models , getNextModel ( models , numberRange ) ] ; <EOL> onUpdate ( newArray ) ; <EOL> } , [ models , numberRange , onUpdate ] ) ; <EOL> const onDelete = useCallback ( ( id ) = > { <EOL> const newArray = models . filter ( ( model ) = > model . id != = id ) ; <EOL> onUpdate ( newArray ) ; <EOL> } , [ models , onUpdate ] ) ; <EOL> return ( < > { models . map ( ( model , arrayIndex ) = > ( < Fragment key = { model . id } > < NumberRow isInvalid = { showValidation   ? model . isInvalid : false } disableDelete = { models . length == = <NUM_LIT> } model = { model } labelledbyId = { labelledbyId } range = { numberRange } onDelete = { onDelete } onChange = { onChangeValue } onBlur = { setTouched } autoFocus = { models . length != = <NUM_LIT> & & arrayIndex == = models . length - <NUM_LIT> } / > { showValidation & & model . isInvalid & & model . error & & ( < EuiFormErrorText > { model . error } < / EuiFormErrorText > ) } { models . length - <NUM_LIT> != = arrayIndex & & < EuiSpacer size = "<STR_LIT>" / > } < / Fragment > ) ) } < EuiSpacer size = "<STR_LIT>" / > < EuiFlexItem > < EuiButtonEmpty iconType = "<STR_LIT>" onClick = { onAdd } size = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { unitName } } / > < / EuiButtonEmpty > < / EuiFlexItem > < / > ) ; } export { NumberList } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import ReactDOM from '<STR_LIT>' ; <EOL> import { <EOL> BrowserRouter , <EOL> Switch , <EOL> Route , <EOL> Redirect , <EOL> NavLink , <EOL> Link , <EOL> useParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Logo <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PrimaryFooter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Centered <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BsKanban <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Heading <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> useBoards <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Avatar <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import { <EOL> UserProfile <EOL> } from '<STR_LIT>' ; <EOL> const App = ( ) = > { <EOL> return ( < BrowserRouter > < PrimaryLayout / > < / BrowserRouter > ) ; } ; const PrimaryLayout = ( ) = > { return ( < div className = "<STR_LIT>" > < PrimaryHeader / > < main className = "<STR_LIT>" > < Dashboard / > < / main > < PrimaryFooter / > < / div > ) ; } ; const PrimaryHeader = ( ) = > { return ( < header className = "<STR_LIT>" > < div className = "<STR_LIT>" > < div > < Logo / > < / div > < div > < nav className = "<STR_LIT>" > < NavLink to = "<STR_LIT>" exact className = "<STR_LIT>" > Dashboard < / NavLink > < NavLink to = "<STR_LIT>" className = "<STR_LIT>" > Boards < / NavLink > < / nav > < / div > < / div > < / header > ) ; } ; const Dashboard = ( ) = > { return ( < Centered size = { <NUM_LIT> } > < Heading > Welcome to your Dashboard < / Heading > < / Centered > ) ; } ; const BrowseBoards = ( ) = > { const boards = useBoards ( ) ; return ( < Centered size = { <NUM_LIT> } > < Heading > Boards < / Heading > < div className = "<STR_LIT>" > { boards & & boards . map ( ( board ) = > { return ( < div key = { board . id } className = "<STR_LIT>" > < div className = "<STR_LIT>" style = { { fontSize : '<STR_LIT>' } } > < BsKanban className = "<STR_LIT>" color = "<STR_LIT>" / > < / div > < div className = "<STR_LIT>" > < Heading > < Link to = {   ` / boards / $ { board . id } ` } > { board . name | | < em > Board Name < / em > } < / Link > < / Heading > < / div > < / div > ) ; } ) } < div className = "<STR_LIT>" > < Avatar src = "<STR_LIT>" size = { <NUM_LIT> } / > < Link to = "<STR_LIT>" className = "<STR_LIT>" > Bruce Lee < / Link > < / div > < / div > < / Centered > ) ; } ; type ParamsType = { boardId : string ; } ; const Board = ( ) = > { const { boardId } = useParams < ParamsType > ( ) ; return ( < Centered size = { <NUM_LIT> } > < Heading >   👋 Hi from board { boardId } < / Heading > < / Centered > ) ; } ; ReactDOM . render ( < App / > , document . getElementById ( '<STR_LIT>' ) ) ; </s>
<s> import { <EOL> TestBed <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RouterTestingModule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ActivatedRoute <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> of <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MATOMO_CONFIGURATION <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MatomoTracker <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MatomoRouteTracker <EOL> } from '<STR_LIT>' ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> beforeEach ( ( ) = > TestBed . configureTestingModule ( { <EOL> imports : [ RouterTestingModule . withRoutes ( [ ] ) ] , <EOL> providers : [ { <EOL> provide : ActivatedRoute , <EOL> useValue : { <EOL> params : of ( { } ) , <EOL> } , <EOL> } , { <EOL> provide : MATOMO_CONFIGURATION , <EOL> useValue : { <EOL> trackers : [ ] , <EOL> trackAppStarting : true , <EOL> requireConsent : false , <EOL> enableLinkTracking : true , <EOL> enableLinkTrackingValue : false , <EOL> routeTracking : { <EOL> enable : false , <EOL> } , <EOL> } , <EOL> } , MatomoTracker , MatomoRouteTracker , ] , <EOL> } ) ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const service = TestBed . inject ( MatomoRouteTracker ) ; <EOL> expect ( service ) . toBeTruthy ( ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> CustomIntegrationsPluginSetup <EOL> } from '<STR_LIT>' ; <EOL> function createCustomIntegrationsSetup ( ) { <EOL> const mock = { <EOL> registerCustomIntegration : jest . fn ( ) , <EOL> getAppendCustomIntegrations : jest . fn ( ) , <EOL> } ; <EOL> return mock ; <EOL> } <EOL> export const customIntegrationsMock = { <EOL> createSetup : createCustomIntegrationsSetup , <EOL> } ; </s>
<s> import { <EOL> fromLiteralExpression <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> WildcardTypeBuildNode <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> KueryNode <EOL> } from '<STR_LIT>' ; <EOL> export const wildcardSymbol = '<STR_LIT>' ; <EOL> function escapeRegExp ( str ) { <EOL> return str . replace ( / [ . * + ? ^ $ { } ( ) | [ \ ] \ \ ] / g , '<STR_LIT>' ) ; <EOL> } <EOL> function escapeQueryString ( str ) { <EOL> return str . replace ( / [ + -= & | > < ! ( ) { } [ \ ] ^ " ~ * ? : \ \ / ] / g , '<STR_LIT>' ) ; <EOL> } <EOL> export function buildNode ( value ) { <EOL> if ( ! value . includes ( wildcardSymbol ) ) { <EOL> return fromLiteralExpression ( value ) ; <EOL> } <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value , <EOL> } ; <EOL> } <EOL> export function test ( node , str ) { <EOL> const { <EOL> value <EOL> } = node ; <EOL> const regex = value . split ( wildcardSymbol ) . map ( escapeRegExp ) . join ( '<STR_LIT>' ) ; <EOL> const regexp = new RegExp ( ` ^ $ { regex } $ ` ) ; <EOL> return regexp . test ( str ) ; <EOL> } <EOL> export function toOpenSearchQuery ( node ) { <EOL> const { <EOL> value <EOL> } = node ; <EOL> return value . split ( wildcardSymbol ) . join ( '<STR_LIT>' ) ; <EOL> } <EOL> export function toQueryStringQuery ( node ) { <EOL> const { <EOL> value <EOL> } = node ; <EOL> return value . split ( wildcardSymbol ) . map ( escapeQueryString ) . join ( '<STR_LIT>' ) ; <EOL> } <EOL> export function hasLeadingWildcard ( node ) { <EOL> const { <EOL> value <EOL> } = node ; <EOL> return value . startsWith ( wildcardSymbol ) & & value . replace ( wildcardSymbol , '<STR_LIT>' ) . length > <NUM_LIT> ; <EOL> } </s>
<s> import { <EOL> Subject <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> materialize , <EOL> take , <EOL> toArray <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UiSettingsClient <EOL> } from '<STR_LIT>' ; <EOL> let done $ ; <EOL> function setup ( options = { } ) { <EOL> const { <EOL> defaults = { <EOL> dateFormat : { <EOL> value : '<STR_LIT>' <EOL> } <EOL> } , initialSettings = { } <EOL> } = options ; <EOL> const batchSet = jest . fn ( ( ) = > ( { <EOL> settings : { } , <EOL> } ) ) ; <EOL> done $ = new Subject ( ) ; <EOL> const client = new UiSettingsClient ( { <EOL> defaults , <EOL> initialSettings , <EOL> api : { <EOL> batchSet , <EOL> } <EOL> as any , <EOL> done $ , <EOL> } ) ; <EOL> return { <EOL> client , <EOL> batchSet <EOL> } ; <EOL> } <EOL> afterEach ( ( ) = > { <EOL> done $ . complete ( ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . get ( '<STR_LIT>' , '<STR_LIT>' ) ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . get ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( ( ) = > client . get ( '<STR_LIT>' ) ) . toThrowErrorMatchingSnapshot ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isDefault ( '<STR_LIT>' ) ) . toBe ( true ) ; <EOL> const defaultDateFormat = client . get ( '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' , '<STR_LIT>' ) ) . toBe ( '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toBe ( defaultDateFormat ) ; <EOL> expect ( client . get ( '<STR_LIT>' , defaultDateFormat ) ) . toBe ( defaultDateFormat ) ; <EOL> } ) ; <EOL> it ( "<STR_LIT>" , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( ( ) = > client . get ( '<STR_LIT>' ) ) . toThrowErrorMatchingSnapshot ( ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> const values = await client . get $ ( '<STR_LIT>' ) . pipe ( take ( <NUM_LIT> ) , toArray ( ) ) . toPromise ( ) ; <EOL> expect ( values ) . toEqual ( [ '<STR_LIT>' ] ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> const values = await client . get $ ( '<STR_LIT>' ) . pipe ( materialize ( ) ) . toPromise ( ) ; <EOL> expect ( values ) . toMatchInlineSnapshot ( ` <EOL> Notification { <EOL> "<STR_LIT>" : [ Error : Unexpected   \ ` IUiSettingsClient . get ( "<STR_LIT>" ) \ ` call on unrecognized configuration setting "<STR_LIT>" . <EOL> Setting an initial value via   \ ` IUiSettingsClient . set ( "<STR_LIT>" , value ) \ ` before attempting to retrieve <EOL> any custom setting value for "<STR_LIT>" may fix this issue . <EOL> You can use   \ ` IUiSettingsClient . get ( "<STR_LIT>" , defaultValue ) \ ` , which will just return <EOL> \ ` defaultValue \ ` when the key is unrecognized . ] , <EOL> "<STR_LIT>" : false , <EOL> "<STR_LIT>" : "<STR_LIT>" , <EOL> "<STR_LIT>" : undefined , <EOL> } <EOL> ` ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> setTimeout ( ( ) = > { <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> } , <NUM_LIT> ) ; <EOL> const values = await client . get $ ( '<STR_LIT>' ) . pipe ( take ( <NUM_LIT> ) , toArray ( ) ) . toPromise ( ) ; <EOL> expect ( values ) . toEqual ( [ '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> setTimeout ( ( ) = > { <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> } , <NUM_LIT> ) ; <EOL> setTimeout ( ( ) = > { <EOL> client . remove ( '<STR_LIT>' ) ; <EOL> } , <NUM_LIT> ) ; <EOL> const values = await client . get $ ( '<STR_LIT>' , '<STR_LIT>' ) . pipe ( take ( <NUM_LIT> ) , toArray ( ) ) . toPromise ( ) ; <EOL> expect ( values ) . toEqual ( [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> const original = client . get ( '<STR_LIT>' ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toBe ( '<STR_LIT>' ) ; <EOL> client . set ( '<STR_LIT>' , original ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( ( ) = > client . set ( '<STR_LIT>' , '<STR_LIT>' ) ) . not . toThrowError ( ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toBe ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> await expect ( client . set ( '<STR_LIT>' , '<STR_LIT>' ) ) . resolves . toBe ( true ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client , <EOL> batchSet <EOL> } = setup ( ) ; <EOL> batchSet . mockImplementation ( ( ) = > { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> await expect ( client . set ( '<STR_LIT>' , '<STR_LIT>' ) ) . resolves . toBe ( false ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( { <EOL> initialSettings : { <EOL> foo : { <EOL> isOverridden : true , <EOL> value : '<STR_LIT>' , <EOL> } , <EOL> } , <EOL> } ) ; <EOL> await expect ( client . set ( '<STR_LIT>' , true ) ) . rejects . toThrowErrorMatchingSnapshot ( ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> await expect ( client . remove ( '<STR_LIT>' ) ) . resolves . toBe ( true ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client , <EOL> batchSet <EOL> } = setup ( ) ; <EOL> batchSet . mockImplementation ( ( ) = > { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> await expect ( client . remove ( '<STR_LIT>' ) ) . resolves . toBe ( false ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , async ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( { <EOL> initialSettings : { <EOL> bar : { <EOL> isOverridden : true , <EOL> userValue : true , <EOL> } , <EOL> } , <EOL> } ) ; <EOL> await expect ( client . remove ( '<STR_LIT>' ) ) . rejects . toThrowErrorMatchingSnapshot ( ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isDeclared ( '<STR_LIT>' ) ) . toBe ( true ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isDeclared ( '<STR_LIT>' ) ) . toBe ( true ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isDefault ( '<STR_LIT>' ) ) . toBe ( true ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . isDefault ( '<STR_LIT>' ) ) . toBe ( false ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isCustom ( '<STR_LIT>' ) ) . toBe ( false ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isCustom ( '<STR_LIT>' ) ) . toBe ( false ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . isCustom ( '<STR_LIT>' ) ) . toBe ( true ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const handler = jest . fn ( ) ; <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . getUpdate $ ( ) . subscribe ( handler ) ; <EOL> expect ( handler ) . not . toHaveBeenCalled ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( handler ) . toHaveBeenCalledTimes ( <NUM_LIT> ) ; <EOL> expect ( handler . mock . calls ) . toMatchSnapshot ( ) ; <EOL> handler . mockClear ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( handler ) . toHaveBeenCalledTimes ( <NUM_LIT> ) ; <EOL> expect ( handler . mock . calls ) . toMatchSnapshot ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const onComplete = jest . fn ( ) ; <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . getUpdate $ ( ) . subscribe ( { <EOL> complete : onComplete , <EOL> } ) ; <EOL> expect ( onComplete ) . not . toHaveBeenCalled ( ) ; <EOL> done $ . complete ( ) ; <EOL> expect ( onComplete ) . toHaveBeenCalled ( ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> client . overrideLocalDefault ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . getAll ( ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> client . overrideLocalDefault ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . getAll ( ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const handler = jest . fn ( ) ; <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . getUpdate $ ( ) . subscribe ( handler ) ; <EOL> client . overrideLocalDefault ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( handler . mock . calls ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> client . overrideLocalDefault ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . getAll ( ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> client . overrideLocalDefault ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . getAll ( ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const handler = jest . fn ( ) ; <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> client . getUpdate $ ( ) . subscribe ( handler ) ; <EOL> client . overrideLocalDefault ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( handler ) . not . toHaveBeenCalled ( ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> client . set ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> client . overrideLocalDefault ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> expect ( client . getAll ( ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> client . remove ( '<STR_LIT>' ) ; <EOL> expect ( client . get ( '<STR_LIT>' ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> expect ( client . getAll ( ) ) . toMatchSnapshot ( '<STR_LIT>' ) ; <EOL> } ) ; <EOL> } ) ; <EOL> describe ( '<STR_LIT>' , ( ) = > { <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isOverridden ( '<STR_LIT>' ) ) . toBe ( false ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( { <EOL> initialSettings : { <EOL> foo : { <EOL> userValue : <NUM_LIT> , <EOL> } , <EOL> bar : { <EOL> isOverridden : true , <EOL> userValue : <NUM_LIT> , <EOL> } , <EOL> } , <EOL> } ) ; <EOL> expect ( client . isOverridden ( '<STR_LIT>' ) ) . toBe ( false ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( { <EOL> initialSettings : { <EOL> foo : { <EOL> userValue : <NUM_LIT> , <EOL> } , <EOL> bar : { <EOL> isOverridden : true , <EOL> userValue : <NUM_LIT> , <EOL> } , <EOL> } , <EOL> } ) ; <EOL> expect ( client . isOverridden ( '<STR_LIT>' ) ) . toBe ( true ) ; <EOL> } ) ; <EOL> it ( '<STR_LIT>' , ( ) = > { <EOL> const { <EOL> client <EOL> } = setup ( ) ; <EOL> expect ( client . isOverridden ( '<STR_LIT>' ) ) . toBe ( false ) ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> export interface DashboardConfig { <EOL> turnHideWriteControlsOn ( ) : void ; <EOL> getHideWriteControls ( ) : boolean ; <EOL> } <EOL> export function getDashboardConfig ( hideWriteControls ) { <EOL> let _hideWriteControls = hideWriteControls ; <EOL> return { <EOL> type { <EOL> boolean <EOL> } <EOL> turnHideWriteControlsOn ( ) { <EOL> _hideWriteControls = true ; <EOL> } , <EOL> getHideWriteControls ( ) { <EOL> return _hideWriteControls ; <EOL> } , <EOL> } ; <EOL> } </s>
<s> import '<STR_LIT>' ; <EOL> import angular from '<STR_LIT>' ; <EOL> import { <EOL> getServices <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * Here '<STR_LIT>' s inner angular is mounted and rendered <EOL> * / <EOL> export async function renderApp ( moduleName , element ) { <EOL> getServices ( ) . opensearchDashboardsLegacy . loadFontAwesome ( ) ; <EOL> await import ( '<STR_LIT>' ) ; <EOL> const   $ injector = mountDiscoverApp ( moduleName , element ) ; <EOL> return ( ) = >   $ injector . get ( '<STR_LIT>' ) . $ destroy ( ) ; <EOL> } <EOL> function mountDiscoverApp ( moduleName , element ) { <EOL> const mountpoint = document . createElement ( '<STR_LIT>' ) ; <EOL> const appWrapper = document . createElement ( '<STR_LIT>' ) ; <EOL> appWrapper . setAttribute ( '<STR_LIT>' , '<STR_LIT>' ) ; <EOL> mountpoint . appendChild ( appWrapper ) ; <EOL> const   $ injector = angular . bootstrap ( mountpoint , [ moduleName ] ) ; <EOL> element . appendChild ( mountpoint ) ; <EOL> return   $ injector ; <EOL> } </s>
<s> import { <EOL> emory <EOL> } from '<STR_LIT>' ; <EOL> export const Version = emory . getVersion ( '<STR_LIT>' ) ; <EOL> export interface Input { <EOL> sentence : string ; <EOL> } <EOL> export interface Prediction { <EOL> words : string [ ] ; mask : boolean [ ] ; tags : string [ ] ; logits : number [ ] [ ] ; <EOL> } </s>
<s> import _ from '<STR_LIT>' ; <EOL> import { <EOL> RefreshInterval <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> InputTimeRange <EOL> } from '<STR_LIT>' ; <EOL> const valueOf = function ( o ) { <EOL> if ( o ) return o . valueOf ( ) ; <EOL> } ; <EOL> export function areRefreshIntervalsDifferent ( rangeA , rangeB ) { <EOL> if ( _ . isObject ( rangeA ) & & _ . isObject ( rangeB ) ) { <EOL> if ( valueOf ( rangeA . value ) != = valueOf ( rangeB . value ) | | valueOf ( rangeA . pause ) != = valueOf ( rangeB . pause ) ) { <EOL> return true ; <EOL> } <EOL> } else { <EOL> return   ! _ . isEqual ( rangeA , rangeB ) ; <EOL> } <EOL> return false ; <EOL> } <EOL> export function areTimeRangesDifferent ( rangeA , rangeB ) { <EOL> if ( rangeA & & rangeB & & _ . isObject ( rangeA ) & & _ . isObject ( rangeB ) ) { <EOL> if ( valueOf ( rangeA . to ) != = valueOf ( rangeB . to ) | | valueOf ( rangeA . from ) != = valueOf ( rangeB . from ) ) { <EOL> return true ; <EOL> } <EOL> } else { <EOL> return   ! _ . isEqual ( rangeA , rangeB ) ; <EOL> } <EOL> return false ; <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> Dialog as ReachDialog <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> type Props = { <EOL> onClose ( ) : void ; <EOL> [ key ] : any ; <EOL> } ; <EOL> export const Dialog = ( { <EOL> onClose , <EOL> children , <EOL> ... props <EOL> } ) = > { <EOL> return ( < ReachDialog { ... props } onDismiss = { onClose } > < div className = "<STR_LIT>" > { children } < / div > < / ReachDialog > ) ; } ; type DialogConfirmProps = { onConfirm ( ) : void ; onCancel ( ) : void ; '<STR_LIT>' : string ; [ key ] : any ; } ; export const DialogConfirm = ( { children , onConfirm , onCancel , ... props } ) = > { return ( < Dialog { ... props } onClose = { onCancel } > < div className = "<STR_LIT>" > < div className = "<STR_LIT>" > { children } < / div > < footer className = "<STR_LIT>" > < button onClick = { onConfirm } className = "<STR_LIT>" > Yes < / button > < button onClick = { onCancel } className = "<STR_LIT>" > No < / button > < / footer > < / div > < / Dialog > ) ; } ; </s>
<s> name extends SavedObject . import { <EOL> createSavedObjectClass , <EOL> SavedObject , <EOL> SavedObjectOpenSearchDashboardsServices , <EOL> } <EOL> from '<STR_LIT>' ; <EOL> import { <EOL> updateOldState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> extractReferences , <EOL> injectReferences <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ISavedVis , <EOL> SerializedVis <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createSavedSearchesLoader <EOL> } from '<STR_LIT>' ; <EOL> export const convertToSerializedVis = ( savedVis ) : SerializedVis = > { <EOL> const { <EOL> id , <EOL> title , <EOL> description , <EOL> visState , <EOL> uiStateJSON , <EOL> searchSourceFields <EOL> } = savedVis ; <EOL> const aggs = searchSourceFields & & searchSourceFields . index   ? visState . aggs | | [ ] : visState . aggs ; <EOL> return { <EOL> id , <EOL> title , <EOL> type : visState . type , <EOL> description , <EOL> params : visState . params , <EOL> uiState : JSON . parse ( uiStateJSON | | '<STR_LIT>' ) , <EOL> data : { <EOL> aggs , <EOL> searchSource : searchSourceFields ! , <EOL> savedSearchId : savedVis . savedSearchId , <EOL> } , <EOL> } ; <EOL> } ; <EOL> export const convertFromSerializedVis = ( vis ) : ISavedVis = > { <EOL> return { <EOL> id : vis . id , <EOL> title : vis . title , <EOL> description : vis . description , <EOL> visState : { <EOL> title : vis . title , <EOL> type : vis . type , <EOL> aggs : vis . data . aggs , <EOL> params : vis . params , <EOL> } , <EOL> uiStateJSON : JSON . stringify ( vis . uiState ) , <EOL> searchSourceFields : vis . data . searchSource , <EOL> savedSearchId : vis . data . savedSearchId , <EOL> } ; <EOL> } ; <EOL> export function createSavedVisClass ( services ) { <EOL> const SavedObjectClass = createSavedObjectClass ( services ) ; <EOL> const savedSearch = createSavedSearchesLoader ( services ) ; <EOL> class SavedVis extends SavedObjectClass { <EOL> public static type : string = '<STR_LIT>' ; <EOL> public static mapping : Record < string , string > = { <EOL> title : '<STR_LIT>' , <EOL> visState : '<STR_LIT>' , <EOL> uiStateJSON : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> savedSearchId : '<STR_LIT>' , <EOL> version : '<STR_LIT>' , <EOL> } ; <EOL> public static fieldOrder = [ '<STR_LIT>' , '<STR_LIT>' ] ; <EOL> constructor ( opts = { } ) { <EOL> if ( typeof opts != = '<STR_LIT>' ) { <EOL> opts = { <EOL> id : opts <EOL> } ; <EOL> } <EOL> const visState =   ! opts . type   ? null : { <EOL> type : opts . type <EOL> } ; <EOL> super ( { <EOL> type : SavedVis . type , <EOL> mapping : SavedVis . mapping , <EOL> extractReferences , <EOL> injectReferences , <EOL> id : ( opts . id as string ) | | '<STR_LIT>' , <EOL> indexPattern : opts . indexPattern as IIndexPattern , <EOL> defaults : { <EOL> title : '<STR_LIT>' , <EOL> visState , <EOL> uiStateJSON : '<STR_LIT>' , <EOL> description : '<STR_LIT>' , <EOL> savedSearchId : opts . savedSearchId , <EOL> version : <NUM_LIT> , <EOL> } , <EOL> afterOpenSearchResp : async ( savedObject ) = > { <EOL> const savedVis = ( savedObject as any ) as ISavedVis ; <EOL> savedVis . visState = await updateOldState ( savedVis . visState ) ; <EOL> if ( savedVis . searchSourceFields ? . index ) { <EOL> await services . indexPatterns . get ( savedVis . searchSourceFields . index as any ) ; <EOL> } <EOL> if ( savedVis . savedSearchId ) { <EOL> await savedSearch . get ( savedVis . savedSearchId ) ; <EOL> } <EOL> return ( savedVis as any ) as SavedObject ; <EOL> } , <EOL> } ) ; <EOL> this . showInRecentlyAccessed = true ; <EOL> this . getFullPath = ( ) = > { <EOL> return   ` / app / visualize <EOL> } ; <EOL> } <EOL> } <EOL> return SavedVis as new ( opts ) = > SavedObject ; <EOL> } </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> useState , <EOL> useCallback , <EOL> useRef , <EOL> useEffect <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> globalColors <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> RoomChat <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> modalContentWidth <EOL> } from "<STR_LIT>" ; <EOL> import Modal from "<STR_LIT>" ; <EOL> import { <EOL> IconButton <EOL> } from "<STR_LIT>" ; <EOL> import ChatMessage from "<STR_LIT>" ; <EOL> interface Props { <EOL> chats : RoomChat [ ] ; onClickSend : ( text : string ) = > void ; onClickCloser : ( ) = > void ; <EOL> } <EOL> const ChatLayout = ( { <EOL> chats , <EOL> onClickCloser , <EOL> onClickSend , <EOL> } ) = > { <EOL> const [ buffer , setBuffer ] = useState ( "<STR_LIT>" ) ; <EOL> const onSend = useCallback ( ( ) = > { <EOL> onClickSend ( buffer ) ; <EOL> setBuffer ( "<STR_LIT>" ) ; <EOL> } , [ buffer , onClickSend ] ) ; <EOL> const scrollerRef = useRef < HTMLDivElement > ( null ) ; <EOL> useEffect ( ( ) = > { <EOL> if ( scrollerRef . current == = null ) { <EOL> return ; <EOL> } <EOL> const   $ scroller = scrollerRef . current ; <EOL>                         $ scroller . scrollTo ( { <EOL> top :   $ scroller . scrollHeight , <EOL> behavior : "<STR_LIT>" <EOL> } ) ; <EOL> } , [ chats , scrollerRef ] ) ; <EOL> return ( < Modal > < div css = { wrapperStyle } > < div css = { headStyle } > < IconButton name = "<STR_LIT>" onClick = { onClickCloser } / > < / div > < div css = { scrollerStyle } ref = { scrollerRef } > { chats . map ( ( chat ) = > ( < ChatMessage key = { chat . id } chat = { chat } / > ) ) } < / div > < div css = { editorStyle } > < input type = "<STR_LIT>" value = { buffer } onChange = { ( ev ) = > setBuffer ( ev . target . value ) } css = { inputStyle } / > < IconButton name = "<STR_LIT>" disabled = { buffer . length == = <NUM_LIT> } onClick = { onSend } / > < / div > < / div > < / Modal > ) ; } ; export default ChatLayout ; const wrapperStyle = css ( { display : "<STR_LIT>" , gridTemplateRows : "<STR_LIT>" , width : modalContentWidth , height : "<STR_LIT>" , boxSizing : "<STR_LIT>" , margin : "<STR_LIT>" , padding : <NUM_LIT> , backgroundColor : globalColors . white , } ) ; const headStyle = css ( { textAlign : "<STR_LIT>" , } ) ; const scrollerStyle = css ( { overflowY : "<STR_LIT>" , overflowScrolling : "<STR_LIT>" , } ) ; const editorStyle = css ( { display : "<STR_LIT>" , alignItems : "<STR_LIT>" , } ) ; const inputStyle = css ( { flex : "<STR_LIT>" , marginRight : <NUM_LIT> , } ) ; </s>
<s> import * as Ajv from '<STR_LIT>' ; <EOL> import * as draft4Schemas from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import * as React from '<STR_LIT>' ; <EOL> import * as ReactDOM from '<STR_LIT>' ; <EOL> import { <EOL> Provider <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TopLevelSpec <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Data <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FacetedCompositeUnitSpec , <EOL> isUnitSpec , <EOL> TopLevel <EOL> } from '<STR_LIT>' ; <EOL> import * as vlSchema from '<STR_LIT>' ; <EOL> import { <EOL> isString <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> REDO , <EOL> UNDO <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> App <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> State <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DEFAULT_VOYAGER_CONFIG , <EOL> VoyagerConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fromSerializable , <EOL> SerializableState , <EOL> toSerializable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> selectData <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> selectBookmark <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> selectMainSpec <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> configureStore <EOL> } from '<STR_LIT>' ; <EOL> export type Container = string | HTMLElement ; <EOL> / ** <EOL> * The Voyager class encapsulates the voyager application and allows for easy <EOL> * instantiation and interaction from non - react projects . <EOL> * / <EOL> export class Voyager { <EOL> private container : HTMLElement ; <EOL> private config : VoyagerConfig ; <EOL> private store : Store < State > ; <EOL> private data : Data ; <EOL> private filename : string ; <EOL> constructor ( container , config , data ) { <EOL> if ( isString ( container ) ) { <EOL> this . container = document . querySelector ( container ) as HTMLElement ; <EOL> } else { <EOL> this . container = container ; <EOL> } <EOL> this . config = { <EOL> ... DEFAULT_VOYAGER_CONFIG , <EOL> ... config <EOL> } ; <EOL> this . data = data ; <EOL> this . init ( ) ; <EOL> } <EOL> param { <EOL> VoyagerData <EOL> } <EOL> data memberof public updateData ( data ) { <EOL> this . data = data ; <EOL> this . render ( ) ; <EOL> } <EOL> memberof public undo ( ) { <EOL> this . store . dispatch ( { <EOL> type : UNDO <EOL> } ) ; <EOL> this . render ( ) ; <EOL> } <EOL> memberof public redo ( ) { <EOL> this . store . dispatch ( { <EOL> type : REDO <EOL> } ) ; <EOL> this . render ( ) ; <EOL> } <EOL> param { <EOL> VoyagerConfig <EOL> } <EOL> config memberof public updateConfig ( config ) { <EOL> this . config = config ; <EOL> this . render ( ) ; <EOL> } <EOL> public setFilename ( filename ) { <EOL> this . filename = filename ; <EOL> } <EOL> param { <EOL> VoyagerConfig <EOL> } <EOL> config memberof public setSpec ( spec ) { <EOL> const ajv = new Ajv ( { <EOL> validateSchema : true , <EOL> allErrors : true , <EOL> extendRefs : '<STR_LIT>' <EOL> } ) ; <EOL> ajv . addMetaSchema ( draft4Schemas , '<STR_LIT>' ) ; <EOL> const validateVl = ajv . compile ( vlSchema ) ; <EOL> const valid = validateVl ( spec ) ; <EOL> if ( ! valid ) { <EOL> throw new Error ( "<STR_LIT>" + validateVl . errors . toString ( ) ) ; <EOL> } <EOL> if ( ! isUnitSpec ( spec as TopLevelSpec ) ) { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> const validSpec = spec as TopLevel < FacetedCompositeUnitSpec > ; <EOL> this . data = validSpec . data ; <EOL> this . render ( validSpec ) ; <EOL> } <EOL> param state param state . config param state . dataset param state . shelf param state . result memberof public setApplicationState ( state ) { <EOL> this . data = undefined ; <EOL> this . config = undefined ; <EOL> this . renderFromState ( fromSerializable ( state ) ) ; <EOL> } <EOL> returns { <EOL> Readonly < State > <EOL> } <EOL> memberof public getApplicationState ( ) { <EOL> return toSerializable ( this . store . getState ( ) ) ; <EOL> } <EOL> returns { <EOL> Readonly < Spec > <EOL> } <EOL> memberof public getSpec ( includeData ) { <EOL> const spec = selectMainSpec ( this . store . getState ( ) ) ; <EOL> if ( includeData ) { <EOL> return { <EOL> ... spec , <EOL> data : selectData ( this . store . getState ( ) ) , <EOL> } ; <EOL> } <EOL> return spec ; <EOL> } <EOL> returns { <EOL> string [ ] <EOL> } <EOL> memberof public getBookmarkedSpecs ( ) { <EOL> return selectBookmark ( this . store . getState ( ) ) . list ; <EOL> } <EOL> param { <EOL> Function <EOL> } <EOL> onChange returns { <EOL> Function <EOL> } <EOL> memberof public onStateChange ( onChange ) { <EOL> let currentState ; <EOL> const handleChange = ( ) = > { <EOL> const nextState = this . store . getState ( ) ; <EOL> if ( nextState != = currentState ) { <EOL> currentState = nextState ; <EOL> onChange ( toSerializable ( currentState ) ) ; <EOL> } <EOL> } ; <EOL> const unsubscribe = this . store . subscribe ( handleChange ) ; <EOL> return unsubscribe ; <EOL> } <EOL> private memberof private init ( ) { <EOL> this . store = configureStore ( ) ; <EOL> this . render ( ) ; <EOL> } <EOL> private render ( spec   ? ) { <EOL> const store = this . store ; <EOL> const root = this . container ; <EOL> ReactDOM . render ( < Provider store = { store } > < App dispatch = { store . dispatch } data = { this . data } config = { this . config } spec = { spec } filename = { this . filename } / > < / Provider > , root ) ; } private renderFromState ( state ) { const store = this . store ; const root = this . container ; ReactDOM . render ( < Provider store = { store } > < App dispatch = { store . dispatch } applicationState = { state } / > < / Provider > , root ) ; } } param { Container } container param { Object } config param { Array } data export function CreateVoyager ( container , config , data ) { return new Voyager ( container , config , data ) ; } </s>
<s> import { <EOL> startCase <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IMetricAggConfig <EOL> } from '<STR_LIT>' ; <EOL> export const makeNestedLabel = ( aggConfig , label ) = > { <EOL> const uppercaseLabel = startCase ( label ) ; <EOL> const customMetric = aggConfig . getParam ( '<STR_LIT>' ) ; <EOL> const metricAgg = aggConfig . getParam ( '<STR_LIT>' ) ; <EOL> if ( customMetric ) { <EOL> let metricLabel = customMetric . makeLabel ( ) ; <EOL> if ( metricLabel . includes ( ` $ { uppercaseLabel } of   ` ) ) { <EOL> metricLabel = metricLabel . substring ( ` $ { uppercaseLabel } of   ` . length ) ; <EOL> metricLabel =   ` <NUM_LIT>   $ { label } of   $ { metricLabel } ` ; <EOL> } else if ( metricLabel . includes ( ` $ { label } of   ` ) ) { <EOL> metricLabel = parseInt ( metricLabel . substring ( <NUM_LIT> , <NUM_LIT> ) , <NUM_LIT> ) + <NUM_LIT> + metricLabel . substring ( <NUM_LIT> ) ; <EOL> } else { <EOL> metricLabel =   ` $ { uppercaseLabel } of   $ { metricLabel } ` ; <EOL> } <EOL> return metricLabel ; <EOL> } <EOL> const metric = aggConfig . aggConfigs . byId ( metricAgg ) ; <EOL> if ( ! metric ) { <EOL> return '<STR_LIT>' ; <EOL> } <EOL> return   ` $ { uppercaseLabel } of   $ { metric . makeLabel ( ) } ` ; <EOL> } ; </s>
<s> import { <EOL> TypeContext , <EOL> TypeBoardSizeOptions <EOL> } from '<STR_LIT>' ; <EOL> type Options = { <EOL> width : number ; height : number ; contextWidth : number ; contextHeight : number ; devicePixelRatio : number ; <EOL> } ; <EOL> type Transform = { <EOL> scale   ? : number ; scrollX   ? : number ; scrollY   ? : number ; <EOL> } ; <EOL> type PrivateTransform = { <EOL> scale : number ; scrollX : number ; scrollY : number ; <EOL> } ; <EOL> class Context implements TypeContext { <EOL> private _opts : Options ; <EOL> private _ctx : CanvasRenderingContext2D ; <EOL> private _transform : PrivateTransform ; <EOL> constructor ( ctx , opts ) { <EOL> this . _opts = opts ; <EOL> this . _ctx = ctx ; <EOL> this . _transform = { <EOL> scale : <NUM_LIT> , <EOL> scrollX : <NUM_LIT> , <EOL> scrollY : <NUM_LIT> , <EOL> } ; <EOL> } <EOL> getContext ( ) { <EOL> return this . _ctx ; <EOL> } <EOL> resetSize ( opts ) { <EOL> this . _opts = { <EOL> ... this . _opts , <EOL> ... opts <EOL> } ; <EOL> } <EOL> calcDeviceNum ( num ) { <EOL> return num * this . _opts . devicePixelRatio ; <EOL> } <EOL> calcScreenNum ( num ) { <EOL> return num / this . _opts . devicePixelRatio ; <EOL> } <EOL> getSize ( ) { <EOL> return { <EOL> width : this . _opts . width , <EOL> height : this . _opts . height , <EOL> contextWidth : this . _opts . contextWidth , <EOL> contextHeight : this . _opts . contextHeight , <EOL> devicePixelRatio : this . _opts . devicePixelRatio , <EOL> } ; <EOL> } <EOL> setTransform ( config ) { <EOL> this . _transform = { <EOL> ... this . _transform , <EOL> ... config <EOL> } ; <EOL> } <EOL> getTransform ( ) { <EOL> return { <EOL> scale : this . _transform . scale , <EOL> scrollX : this . _transform . scrollX , <EOL> scrollY : this . _transform . scrollY , <EOL> } ; <EOL> } <EOL> setFillStyle ( color ) { <EOL> this . _ctx . fillStyle = color ; <EOL> } <EOL> fill ( fillRule   ? ) { <EOL> return this . _ctx . fill ( fillRule | | '<STR_LIT>' ) ; <EOL> } <EOL> arc ( x , y , radius , startAngle , endAngle , anticlockwise   ? ) { <EOL> return this . _ctx . arc ( this . _doSize ( x ) , this . _doSize ( y ) , this . _doSize ( radius ) , startAngle , endAngle , anticlockwise ) ; <EOL> } <EOL> rect ( x , y , w , h ) { <EOL> return this . _ctx . rect ( this . _doSize ( x ) , this . _doSize ( y ) , this . _doSize ( w ) , this . _doSize ( h ) ) ; <EOL> } <EOL> fillRect ( x , y , w , h ) { <EOL> return this . _ctx . fillRect ( this . _doSize ( x ) , this . _doSize ( y ) , this . _doSize ( w ) , this . _doSize ( h ) ) ; <EOL> } <EOL> clearRect ( x , y , w , h ) { <EOL> return this . _ctx . clearRect ( this . _doSize ( x ) , this . _doSize ( y ) , this . _doSize ( w ) , this . _doSize ( h ) ) ; <EOL> } <EOL> beginPath ( ) { <EOL> return this . _ctx . beginPath ( ) ; <EOL> } <EOL> closePath ( ) { <EOL> return this . _ctx . closePath ( ) ; <EOL> } <EOL> lineTo ( x , y ) { <EOL> return this . _ctx . lineTo ( this . _doSize ( x ) , this . _doSize ( y ) ) ; <EOL> } <EOL> moveTo ( x , y ) { <EOL> return this . _ctx . moveTo ( this . _doSize ( x ) , this . _doSize ( y ) ) ; <EOL> } <EOL> arcTo ( x1 , y1 , x2 , y2 , radius ) { <EOL> return this . _ctx . arcTo ( this . _doSize ( x1 ) , this . _doSize ( y1 ) , this . _doSize ( x2 ) , this . _doSize ( y2 ) , this . _doSize ( radius ) ) ; <EOL> } <EOL> setLineWidth ( w ) { <EOL> return this . _ctx . lineWidth = this . _doSize ( w ) ; <EOL> } <EOL> setLineDash ( nums ) { <EOL> return this . _ctx . setLineDash ( nums . map ( n = > this . _doSize ( n ) ) ) ; <EOL> } <EOL> isPointInPath ( x , y ) { <EOL> return this . _ctx . isPointInPath ( this . _doX ( x ) , this . _doY ( y ) ) ; <EOL> } <EOL> isPointInPathWithoutScroll ( x , y ) { <EOL> return this . _ctx . isPointInPath ( this . _doSize ( x ) , this . _doSize ( y ) ) ; <EOL> } <EOL> setStrokeStyle ( color ) { <EOL> this . _ctx . strokeStyle = color ; <EOL> } <EOL> stroke ( ) { <EOL> return this . _ctx . stroke ( ) ; <EOL> } <EOL> translate ( x , y ) { <EOL> return this . _ctx . translate ( this . _doSize ( x ) , this . _doSize ( y ) ) ; <EOL> } <EOL> rotate ( angle ) { <EOL> return this . _ctx . rotate ( angle ) ; <EOL> } <EOL> drawImage ( ... args ) { <EOL> const image = args [ <NUM_LIT> ] ; <EOL> const sx = args [ <NUM_LIT> ] ; <EOL> const sy = args [ <NUM_LIT> ] ; <EOL> const sw = args [ <NUM_LIT> ] ; <EOL> const sh = args [ <NUM_LIT> ] ; <EOL> const dx = args [ args . length - <NUM_LIT> ] ; <EOL> const dy = args [ args . length - <NUM_LIT> ] ; <EOL> const dw = args [ args . length - <NUM_LIT> ] ; <EOL> const dh = args [ args . length - <NUM_LIT> ] ; <EOL> if ( args . length == = <NUM_LIT> ) { <EOL> return this . _ctx . drawImage ( image , this . _doSize ( sx ) , this . _doSize ( sy ) , this . _doSize ( sw ) , this . _doSize ( sh ) , this . _doSize ( dx ) , this . _doSize ( dy ) , this . _doSize ( dw ) , this . _doSize ( dh ) ) ; <EOL> } else { <EOL> return this . _ctx . drawImage ( image , this . _doSize ( dx ) , this . _doSize ( dy ) , this . _doSize ( dw ) , this . _doSize ( dh ) ) ; <EOL> } <EOL> } <EOL> createPattern ( image , repetition ) { <EOL> return this . _ctx . createPattern ( image , repetition ) ; <EOL> } <EOL> measureText ( text ) { <EOL> return this . _ctx . measureText ( text ) ; <EOL> } <EOL> setTextAlign ( align ) { <EOL> this . _ctx . textAlign = align ; <EOL> } <EOL> fillText ( text , x , y , maxWidth   ? ) { <EOL> if ( maxWidth != = undefined ) { <EOL> return this . _ctx . fillText ( text , this . _doSize ( x ) , this . _doSize ( y ) , this . _doSize ( maxWidth ) ) ; <EOL> } else { <EOL> return this . _ctx . fillText ( text , this . _doSize ( x ) , this . _doSize ( y ) ) ; <EOL> } <EOL> } <EOL> strokeText ( text , x , y , maxWidth   ? ) { <EOL> if ( maxWidth != = undefined ) { <EOL> return this . _ctx . strokeText ( text , this . _doSize ( x ) , this . _doSize ( y ) , this . _doSize ( maxWidth ) ) ; <EOL> } else { <EOL> return this . _ctx . strokeText ( text , this . _doSize ( x ) , this . _doSize ( y ) ) ; <EOL> } <EOL> } <EOL> setFont ( opts ) { <EOL> const strList = [ ] ; <EOL> if ( opts . fontWeight == = '<STR_LIT>' ) { <EOL> strList . push ( ` $ { opts . fontWeight } ` ) ; <EOL> } <EOL> strList . push ( ` $ { this . _doSize ( opts . fontSize | | <NUM_LIT> ) } px ` ) ; <EOL> strList . push ( ` $ { opts . fontFamily | | '<STR_LIT>' } ` ) ; <EOL> this . _ctx . font =   ` $ { strList . join ( '<STR_LIT>' ) } ` ; <EOL> } <EOL> setTextBaseline ( baseline ) { <EOL> this . _ctx . textBaseline = baseline ; <EOL> } <EOL> setGlobalAlpha ( alpha ) { <EOL> this . _ctx . globalAlpha = alpha ; <EOL> } <EOL> save ( ) { <EOL> this . _ctx . save ( ) ; <EOL> } <EOL> restore ( ) { <EOL> this . _ctx . restore ( ) ; <EOL> } <EOL> scale ( ratioX , ratioY ) { <EOL> this . _ctx . scale ( ratioX , ratioY ) ; <EOL> } <EOL> setShadowColor ( color ) { <EOL> this . _ctx . shadowColor = color ; <EOL> } <EOL> setShadowOffsetX ( offsetX ) { <EOL> this . _ctx . shadowOffsetX = this . _doSize ( offsetX ) ; <EOL> } <EOL> setShadowOffsetY ( offsetY ) { <EOL> this . _ctx . shadowOffsetY = this . _doSize ( offsetY ) ; <EOL> } <EOL> setShadowBlur ( blur ) { <EOL> this . _ctx . shadowBlur = this . _doSize ( blur ) ; <EOL> } <EOL> ellipse ( x , y , radiusX , radiusY , rotation , startAngle , endAngle , counterclockwise   ? ) { <EOL> this . _ctx . ellipse ( this . _doSize ( x ) , this . _doSize ( y ) , this . _doSize ( radiusX ) , this . _doSize ( radiusY ) , rotation , startAngle , endAngle , counterclockwise ) ; <EOL> } <EOL> private _doSize ( num ) { <EOL> return this . _opts . devicePixelRatio * num ; <EOL> } <EOL> private _doX ( x ) { <EOL> const { <EOL> scale , <EOL> scrollX <EOL> } = this . _transform ; <EOL> const _x = ( x - scrollX ) / scale ; <EOL> return this . _doSize ( _x ) ; <EOL> } <EOL> private _doY ( y ) { <EOL> const { <EOL> scale , <EOL> scrollY <EOL> } = this . _transform ; <EOL> const _y = ( y - scrollY ) / scale ; <EOL> return this . _doSize ( _y ) ; <EOL> } <EOL> } <EOL> export default Context ; </s>
<s> / ** <EOL> * Language API <EOL> * OCI Language Service solutions can help enterprise customers integrate AI into their products immediately using our proven , <EOL> pre - trained and custom models or containers , without a need to set up an house team of AI and ML experts . <EOL> This allows enterprises to focus on business drivers and development work rather than AI and ML operations , which shortens the time to market . <EOL> * OpenAPI spec version : <NUM_LIT> <EOL> * <EOL> * <EOL> * NOTE : This class is auto generated by OracleSDKGenerator . <EOL> * Do not edit the class manually . <EOL> * <EOL> * Copyright ( c ) <NUM_LIT> , <NUM_LIT> , Oracle and / or its affiliates . All rights reserved . <EOL> * This software is dual - licensed to you under the Universal Permissive License ( UPL ) <NUM_LIT> as shown at https : // oss . oracle . com / licenses / upl or Apache License <NUM_LIT> as shown at http : // www . apache . org / licenses / LICENSE - <NUM_LIT> . You may choose either license . <EOL> * / <EOL> import * as model from "<STR_LIT>" ; <EOL> import common = require ( "<STR_LIT>" ) ; <EOL> / ** <EOL> * Key phrase for the given text . <EOL> * / <EOL> export interface KeyPhrase { <EOL> / ** <EOL> * Key phrase exreacted from given text . <EOL> * / <EOL> "<STR_LIT>" : string ; <EOL> / ** <EOL> * Score or confidence of the key phrase . <EOL> * Example :   ` <NUM_LIT> ` <EOL> * Note : Numbers greater than Number . MAX_SAFE_INTEGER will result in rounding issues . <EOL> * / <EOL> "<STR_LIT>" : number ; <EOL> } <EOL> export namespace KeyPhrase { <EOL> export function getJsonObj ( obj ) { <EOL> const jsonObj = { <EOL> ... obj , <EOL> ... { } <EOL> } ; <EOL> return jsonObj ; <EOL> } <EOL> export function getDeserializedJsonObj ( obj ) { <EOL> const jsonObj = { <EOL> ... obj , <EOL> ... { } <EOL> } ; <EOL> return jsonObj ; <EOL> } <EOL> } </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import { <EOL> Link <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Columns , <EOL> Column <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FaAngleLeft , <EOL> FaAngleRight <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MdShoppingCart <EOL> } from '<STR_LIT>' ; <EOL> import Heading from '<STR_LIT>' ; <EOL> import { <EOL> CheckoutFieldsFull <EOL> } from '<STR_LIT>' ; <EOL> interface CheckoutBillingProps { <EOL> defaultFields   ? : Partial < CheckoutFieldsFull > ; <EOL> defaultSameAsBilling   ? : boolean ; <EOL> onSubmit ( sameAsBilling , fields ) : any ; <EOL> } <EOL> function CheckoutBilling ( { <EOL> onSubmit , <EOL> defaultSameAsBilling = false , <EOL> defaultFields = { } , <EOL> } ) { <EOL> const [ state , dispatch ] = React . useReducer ( function billingReducer ( state , action ) : ReducerState { <EOL> switch ( action . type ) { <EOL> case '<STR_LIT>' : <EOL> return { <EOL> ... state , sameAsBilling :   ! state . sameAsBilling <EOL> } ; <EOL> case '<STR_LIT>' : <EOL> return { <EOL> ... state , [ action . field ] : action . value <EOL> } ; <EOL> default : <EOL> return state ; <EOL> } <EOL> } , { <EOL> sameAsBilling : defaultSameAsBilling , <EOL> billingName : defaultFields . billingName | | '<STR_LIT>' , <EOL> billingAddress : defaultFields . billingAddress | | '<STR_LIT>' , <EOL> billingCity : defaultFields . billingCity | | '<STR_LIT>' , <EOL> billingState : defaultFields . billingState | | '<STR_LIT>' , <EOL> billingPostal : defaultFields . billingPostal | | '<STR_LIT>' , <EOL> shippingName : defaultFields . shippingName | | '<STR_LIT>' , <EOL> shippingAddress : defaultFields . shippingAddress | | '<STR_LIT>' , <EOL> shippingCity : defaultFields . shippingCity | | '<STR_LIT>' , <EOL> shippingState : defaultFields . shippingState | | '<STR_LIT>' , <EOL> shippingPostal : defaultFields . shippingPostal | | '<STR_LIT>' , <EOL> } ) ; <EOL> const { <EOL> sameAsBilling , <EOL> billingName , <EOL> billingAddress , <EOL> billingCity , <EOL> billingState , <EOL> billingPostal , <EOL> shippingName , <EOL> shippingAddress , <EOL> shippingCity , <EOL> shippingState , <EOL> shippingPostal , <EOL> } = state ; <EOL> function handleSubmit ( event ) { <EOL> event . preventDefault ( ) ; <EOL> const fields = { <EOL> billingName , <EOL> billingAddress , <EOL> billingCity , <EOL> billingState , <EOL> billingPostal , <EOL> shippingName : sameAsBilling   ? billingName : shippingName , <EOL> shippingAddress : sameAsBilling   ? billingAddress : shippingAddress , <EOL> shippingCity : sameAsBilling   ? billingCity : shippingCity , <EOL> shippingState : sameAsBilling   ? billingState : shippingState , <EOL> shippingPostal : sameAsBilling   ? billingPostal : shippingPostal , <EOL> } ; <EOL> onSubmit ( sameAsBilling , fields ) ; <EOL> } <EOL> function changeField ( field , value ) { <EOL> dispatch ( { <EOL> type : '<STR_LIT>' , <EOL> field , <EOL> value <EOL> } ) ; <EOL> } <EOL> return ( < div className = "<STR_LIT>" > < Heading > < MdShoppingCart / > Billing & amp ; Shipping < / Heading > < form onSubmit = { handleSubmit } className = "<STR_LIT>" > < Heading as = "<STR_LIT>" size = { <NUM_LIT> } > Billing Info < / Heading > < hr / > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > Name < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required defaultValue = { billingName } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } / > < / div > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > Address < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required defaultValue = { billingAddress } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } / > < / div > < Columns gutters > < Column > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > City < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required defaultValue = { billingCity } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } / > < / div > < / Column > < Column > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > State < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required defaultValue = { billingState } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } / > < / div > < / Column > < Column > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > Postal Code < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required defaultValue = { billingPostal } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } / > < / div > < / Column > < / Columns > < Columns split gutters middle > < Column className = "<STR_LIT>" > < Heading as = "<STR_LIT>" size = { <NUM_LIT> } > Shipping Info < / Heading > < / Column > < Column > < label > < input type = "<STR_LIT>" defaultChecked = { sameAsBilling } onChange = { ( ) = > dispatch ( { type : '<STR_LIT>' } ) } / > { '<STR_LIT>' } Same as Billing < / label > < / Column > < / Columns > < hr / > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > Name < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required value = { sameAsBilling   ? billingName : shippingName } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } disabled = { sameAsBilling } / > < / div > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > Address < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required value = { sameAsBilling   ? billingAddress : shippingAddress } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } disabled = { sameAsBilling } / > < / div > < Columns gutters > < Column > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > City < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required value = { sameAsBilling   ? billingCity : shippingCity } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } disabled = { sameAsBilling } / > < / div > < / Column > < Column > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > State < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required value = { sameAsBilling   ? billingState : shippingState } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } disabled = { sameAsBilling } / > < / div > < / Column > < Column > < div className = "<STR_LIT>" > < label htmlFor = "<STR_LIT>" > Postal Code < / label > < input id = "<STR_LIT>" type = "<STR_LIT>" required value = { sameAsBilling   ? billingPostal : shippingPostal } onChange = { ( event ) = > changeField ( '<STR_LIT>' , event . target . value ) } disabled = { sameAsBilling } / > < / div > < / Column > < / Columns > < hr / > < Columns split > < Column > < Link className = "<STR_LIT>" to = "<STR_LIT>" > < FaAngleLeft / > < span > Cart < / span > < / Link > < / Column > < Column > < button type = "<STR_LIT>" className = "<STR_LIT>" > < span > Review < / span > < FaAngleRight / > < / button > < / Column > < / Columns > < / form > < / div > ) ; } export default CheckoutBilling ; type FieldKeys = keyof Omit < CheckoutFieldsFull , '<STR_LIT>' > ; type ReducerAction = { type : '<STR_LIT>' ; } | { type : '<STR_LIT>' ; field : FieldKeys ; value : string ; } ; type ReducerState = CheckoutFieldsFull & { sameAsBilling : boolean ; } ; </s>
<s> import rw from "<STR_LIT>" ; <EOL> export function repeat ( array , repetitions , unpack = false ) { <EOL> const arr_isArray = Array . isArray ( array ) ; <EOL> const rep_isArray = Array . isArray ( repetitions ) ; <EOL> if ( ! arr_isArray ) { <EOL> if ( ! rep_isArray ) { <EOL> array = [ array ] ; <EOL> repetitions = [ repetitions ] ; <EOL> } else { <EOL> repetitions = [ repetitions [ <NUM_LIT> ] ] ; <EOL> console . log ( "<STR_LIT>" ) ; <EOL> } <EOL> } else { <EOL> if ( ! rep_isArray ) { <EOL> let reps = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < array . length ; i + + ) { <EOL> reps . push ( repetitions ) ; <EOL> } <EOL> repetitions = reps ; <EOL> } else { <EOL> if ( array . length != repetitions . length ) { <EOL> console . warn ( "<STR_LIT>" ) ; <EOL> if ( repetitions . length < array . length ) { <EOL> let reps = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < array . length ; i + + ) { <EOL> reps . push ( repetitions ) ; <EOL> } <EOL> repetitions = reps ; <EOL> } else { <EOL> repetitions = repetitions . slice ( <NUM_LIT> , array . length ) ; <EOL> } <EOL> } <EOL> } <EOL> } <EOL> let allsamples = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < array . length ; i + + ) { <EOL> for ( let j = <NUM_LIT> ; j < repetitions [ i ] ; j + + ) { <EOL> if ( array [ i ] == null | | typeof array [ i ] != "<STR_LIT>" ) { <EOL> allsamples . push ( array [ i ] ) ; <EOL> } else { <EOL> allsamples . push ( Object . assign ( { } , array [ i ] ) ) ; <EOL> } <EOL> } <EOL> } <EOL> let out = shuffle ( allsamples ) ; <EOL> if ( unpack ) { <EOL> out = unpackArray ( out ) ; <EOL> } <EOL> return out ; <EOL> } <EOL> export function shuffle ( array ) { <EOL> if ( ! Array . isArray ( array ) ) { <EOL> console . error ( "<STR_LIT>" ) ; <EOL> } <EOL> const copy_array = array . slice ( <NUM_LIT> ) ; <EOL> let m = copy_array . length , <EOL> t , i ; <EOL> while ( m ) { <EOL> i = Math . floor ( Math . random ( ) * m - - ) ; <EOL> t = copy_array [ m ] ; <EOL> copy_array [ m ] = copy_array [ i ] ; <EOL> copy_array [ i ] = t ; <EOL> } <EOL> return copy_array ; <EOL> } <EOL> export function shuffleNoRepeats ( arr , equalityTest ) { <EOL> if ( ! Array . isArray ( arr ) ) { <EOL> console . error ( "<STR_LIT>" ) ; <EOL> } <EOL> if ( typeof equalityTest != = "<STR_LIT>" & & typeof equalityTest != = "<STR_LIT>" ) { <EOL> console . error ( "<STR_LIT>" ) ; <EOL> } <EOL> if ( typeof equalityTest == "<STR_LIT>" ) { <EOL> equalityTest = function ( a , b ) { <EOL> if ( a == = b ) { <EOL> return true ; <EOL> } else { <EOL> return false ; <EOL> } <EOL> } ; <EOL> } <EOL> const random_shuffle = shuffle ( arr ) ; <EOL> for ( let i = <NUM_LIT> ; i < random_shuffle . length - <NUM_LIT> ; i + + ) { <EOL> if ( equalityTest ( random_shuffle [ i ] , random_shuffle [ i + <NUM_LIT> ] ) ) { <EOL> let random_pick = Math . floor ( Math . random ( ) * ( random_shuffle . length - <NUM_LIT> ) ) + <NUM_LIT> ; <EOL> while ( equalityTest ( random_shuffle [ i + <NUM_LIT> ] , random_shuffle [ random_pick ] ) | | equalityTest ( random_shuffle [ i + <NUM_LIT> ] , random_shuffle [ random_pick + <NUM_LIT> ] ) | | equalityTest ( random_shuffle [ i + <NUM_LIT> ] , random_shuffle [ random_pick - <NUM_LIT> ] ) ) { <EOL> random_pick = Math . floor ( Math . random ( ) * ( random_shuffle . length - <NUM_LIT> ) ) + <NUM_LIT> ; <EOL> } <EOL> const new_neighbor = random_shuffle [ random_pick ] ; <EOL> random_shuffle [ random_pick ] = random_shuffle [ i + <NUM_LIT> ] ; <EOL> random_shuffle [ i + <NUM_LIT> ] = new_neighbor ; <EOL> } <EOL> } <EOL> return random_shuffle ; <EOL> } <EOL> export function shuffleAlternateGroups ( arr_groups , random_group_order = false ) { <EOL> const n_groups = arr_groups . length ; <EOL> if ( n_groups == <NUM_LIT> ) { <EOL> console . warn ( "<STR_LIT>" ) ; <EOL> return shuffle ( arr_groups [ <NUM_LIT> ] ) ; <EOL> } <EOL> let group_order = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < n_groups ; i + + ) { <EOL> group_order . push ( i ) ; <EOL> } <EOL> if ( random_group_order ) { <EOL> group_order = shuffle ( group_order ) ; <EOL> } <EOL> const randomized_groups = [ ] ; <EOL> let min_length = null ; <EOL> for ( let i = <NUM_LIT> ; i < n_groups ; i + + ) { <EOL> min_length = min_length == = null   ? arr_groups [ i ] . length : Math . min ( min_length , arr_groups [ i ] . length ) ; <EOL> randomized_groups . push ( shuffle ( arr_groups [ i ] ) ) ; <EOL> } <EOL> const out = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < min_length ; i + + ) { <EOL> for ( let j = <NUM_LIT> ; j < group_order . length ; j + + ) { <EOL> out . push ( randomized_groups [ group_order [ j ] ] [ i ] ) ; <EOL> } <EOL> } <EOL> return out ; <EOL> } <EOL> export function sampleWithoutReplacement ( arr , size ) { <EOL> if ( ! Array . isArray ( arr ) ) { <EOL> console . error ( "<STR_LIT>" ) ; <EOL> } <EOL> if ( size > arr . length ) { <EOL> console . error ( "<STR_LIT>" ) ; <EOL> } <EOL> return shuffle ( arr ) . slice ( <NUM_LIT> , size ) ; <EOL> } <EOL> export function sampleWithReplacement ( arr , size , weights   ? ) { <EOL> if ( ! Array . isArray ( arr ) ) { <EOL> console . error ( "<STR_LIT>" ) ; <EOL> } <EOL> const normalized_weights = [ ] ; <EOL> if ( typeof weights != = "<STR_LIT>" ) { <EOL> if ( weights . length != = arr . length ) { <EOL> console . error ( "<STR_LIT>" + "<STR_LIT>" ) ; <EOL> } <EOL> let weight_sum = <NUM_LIT> ; <EOL> for ( const weight of weights ) { <EOL> weight_sum += weight ; <EOL> } <EOL> for ( const weight of weights ) { <EOL> normalized_weights . push ( weight / weight_sum ) ; <EOL> } <EOL> } else { <EOL> for ( let i = <NUM_LIT> ; i < arr . length ; i + + ) { <EOL> normalized_weights . push ( <NUM_LIT> / arr . length ) ; <EOL> } <EOL> } <EOL> const cumulative_weights = [ normalized_weights [ <NUM_LIT> ] ] ; <EOL> for ( let i = <NUM_LIT> ; i < normalized_weights . length ; i + + ) { <EOL> cumulative_weights . push ( normalized_weights [ i ] + cumulative_weights [ i - <NUM_LIT> ] ) ; <EOL> } <EOL> const samp = [ ] ; <EOL> for ( let i = <NUM_LIT> ; i < size ; i + + ) { <EOL> const rnd = Math . random ( ) ; <EOL> let index = <NUM_LIT> ; <EOL> while ( rnd > cumulative_weights [ index ] ) { <EOL> index + + ; <EOL> } <EOL> samp . push ( arr [ index ] ) ; <EOL> } <EOL> return samp ; <EOL> } <EOL> export function factorial ( factors , repetitions = <NUM_LIT> , unpack = false ) { <EOL> let design = [ { } ] ; <EOL> for ( const [ factorName , factor ] of Object . entries ( factors ) ) { <EOL> const new_design = [ ] ; <EOL> for ( const level of factor ) { <EOL> for ( const cell of design ) { <EOL> new_design . push ( { <EOL> ... cell , <EOL> [ factorName ] : level <EOL> } ) ; <EOL> } <EOL> } <EOL> design = new_design ; <EOL> } <EOL> return repeat ( design , repetitions , unpack ) ; <EOL> } <EOL> export function randomID ( length = <NUM_LIT> ) { <EOL> let result = "<STR_LIT>" ; <EOL> const chars = "<STR_LIT>" ; <EOL> for ( let i = <NUM_LIT> ; i < length ; i + + ) { <EOL> result += chars [ Math . floor ( Math . random ( ) * chars . length ) ] ; <EOL> } <EOL> return result ; <EOL> } <EOL> param lower param upper returns <EOL> export function randomInt ( lower , upper ) { <EOL> if ( upper < lower ) { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> return lower + Math . floor ( Math . random ( ) * ( upper - lower + <NUM_LIT> ) ) ; <EOL> } <EOL> param p returns <EOL> export function sampleBernoulli ( p ) { <EOL> return Math . random ( ) <= p   ? <NUM_LIT> : <NUM_LIT> ; <EOL> } <EOL> export function sampleNormal ( mean , standard_deviation ) { <EOL> return randn_bm ( ) * standard_deviation + mean ; <EOL> } <EOL> export function sampleExponential ( rate ) { <EOL> return - Math . log ( Math . random ( ) ) / rate ; <EOL> } <EOL> export function sampleExGaussian ( mean , standard_deviation , rate , positive = false ) { <EOL> let s = sampleNormal ( mean , standard_deviation ) + sampleExponential ( rate ) ; <EOL> if ( positive ) { <EOL> while ( s <= <NUM_LIT> ) { <EOL> s = sampleNormal ( mean , standard_deviation ) + sampleExponential ( rate ) ; <EOL> } <EOL> } <EOL> return s ; <EOL> } <EOL> / ** <EOL> * Generate one or more random words . <EOL> * <EOL> * This is a wrapper function for the https . <EOL> * <EOL> * param opts returns export function randomWords ( opts ) { return rw ( opts ) ; } function randn_bm ( ) { var u = <NUM_LIT> , v = <NUM_LIT> ; while ( u == = <NUM_LIT> ) u = Math . random ( ) ; while ( v == = <NUM_LIT> ) v = Math . random ( ) ; return Math . sqrt ( - <NUM_LIT> * Math . log ( u ) ) * Math . cos ( <NUM_LIT> * Math . PI * v ) ; } function unpackArray ( array ) { const out = { } ; for ( const x of array ) { for ( const key of Object . keys ( x ) ) { if ( typeof out [ key ] == = "<STR_LIT>" ) { out [ key ] = [ ] ; } out [ key ] . push ( x [ key ] ) ; } } return out ; } </s>
<s> import visit from '<STR_LIT>' ; <EOL> import type { <EOL> Root <EOL> } from '<STR_LIT>' ; <EOL> export function FileTextMdxPlugin ( ) { <EOL> return transformer ; <EOL> function transformer ( tree , file ) { <EOL> const addImports = [ ] ; <EOL> visit ( tree , '<STR_LIT>' , ( child , index , parent ) = > { <EOL> const regexp = / < FileText \ s + src = [ "<STR_LIT>" '<STR_LIT>' ] ( . * ? ) [ " ' ] / ; <EOL> const match = ( child . value as string ) . match ( regexp ) ; <EOL> if ( match ) { <EOL> const [ , src , syntax ] = match ; <EOL> const nextIndex = addImports . length ; <EOL> const varName =   ` _fileText $ { nextIndex } ` ; <EOL> addImports . push ( ` import   $ { varName } from "<STR_LIT>" ; ` ) ; <EOL> child . value =   ` < FileText text = { $ { varName } } syntax = "<STR_LIT>" / > ` ; <EOL> } else { <EOL> const basicRegexp = / < FileText \ s + ( ? : . + ? \ s ) ? src = / ; <EOL> const basicMatch = child . value . match ( basicRegexp ) ; <EOL> if ( basicMatch ) { <EOL> throw new Error ( ` Invalid usage of < FileText / > :   $ { child . value } . <EOL> Correct Syntax : < FileText src = "<STR_LIT>" syntax = "<STR_LIT>" / > ` ) ; <EOL> } <EOL> } <EOL> } ) ; <EOL> tree . children . unshift ( ... addImports . map ( ( importStr ) = > { <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : importStr , <EOL> } <EOL> as any ; <EOL> } ) ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> VISUALIZE_FIELD_TRIGGER , <EOL> VISUALIZE_GEO_FIELD_TRIGGER , <EOL> visualizeFieldTrigger , <EOL> visualizeGeoFieldTrigger , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getUiActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternField , <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> function getTriggerConstant ( type ) { <EOL> return type == = OSD_FIELD_TYPES . GEO_POINT | | type == = OSD_FIELD_TYPES . GEO_SHAPE   ? VISUALIZE_GEO_FIELD_TRIGGER : VISUALIZE_FIELD_TRIGGER ; <EOL> } <EOL> function getTrigger ( type ) { <EOL> return type == = OSD_FIELD_TYPES . GEO_POINT | | type == = OSD_FIELD_TYPES . GEO_SHAPE   ? visualizeGeoFieldTrigger : visualizeFieldTrigger ; <EOL> } <EOL> async function getCompatibleActions ( fieldName , indexPatternId , contextualFields , trigger ) { <EOL> const compatibleActions = await getUiActions ( ) . getTriggerCompatibleActions ( trigger , { <EOL> indexPatternId , <EOL> fieldName , <EOL> contextualFields , <EOL> } ) ; <EOL> return compatibleActions ; <EOL> } <EOL> export async function getVisualizeHref ( field , indexPatternId , contextualFields ) { <EOL> if ( ! indexPatternId ) return undefined ; <EOL> const triggerOptions = { <EOL> indexPatternId , <EOL> fieldName : field . name , <EOL> contextualFields , <EOL> trigger : getTrigger ( field . type ) , <EOL> } ; <EOL> const compatibleActions = await getCompatibleActions ( field . name , indexPatternId , contextualFields , getTriggerConstant ( field . type ) ) ; <EOL> return compatibleActions . length == = <NUM_LIT>   ? compatibleActions [ <NUM_LIT> ] . getHref ? . ( triggerOptions ) : undefined ; <EOL> } <EOL> export function triggerVisualizeActions ( field , indexPatternId , contextualFields ) { <EOL> if ( ! indexPatternId ) return ; <EOL> const trigger = getTriggerConstant ( field . type ) ; <EOL> const triggerOptions = { <EOL> indexPatternId , <EOL> fieldName : field . name , <EOL> contextualFields , <EOL> } ; <EOL> getUiActions ( ) . getTrigger ( trigger ) . exec ( triggerOptions ) ; <EOL> } <EOL> export async function isFieldVisualizable ( field , indexPatternId , contextualFields ) { <EOL> if ( field . name == = '<STR_LIT>' | |   ! indexPatternId ) { <EOL> return false ; <EOL> } <EOL> const trigger = getTriggerConstant ( field . type ) ; <EOL> const compatibleActions = await getCompatibleActions ( field . name , indexPatternId , contextualFields , trigger ) ; <EOL> return compatibleActions . length > <NUM_LIT> & & field . visualizable ; <EOL> } </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> RoomStream <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> RoomStat <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> rightMenuWidth , <EOL> rightMenuTogglerHeight <EOL> } from "<STR_LIT>" ; <EOL> import RemoteStreamLayout from "<STR_LIT>" ; <EOL> type StreamEntry = [ string , RoomStream ] ; <EOL> const sortByVideo = ( [ , aStream ] , [ , bStream ] ) = > aStream . getVideoTracks ( ) . length > bStream . getVideoTracks ( ) . length   ? - <NUM_LIT> : <NUM_LIT> ; <EOL> interface Props { <EOL> streams : StreamEntry [ ] ; stats : [ string , RoomStat ] [ ] ; pinnedId : string ; onClickSetPinned : ( id : string ) = > void ; <EOL> } <EOL> const RemoteStreamsLayout = ( { <EOL> streams , <EOL> stats , <EOL> pinnedId , <EOL> onClickSetPinned , <EOL> } ) = > ( < div css = { wrapperStyle } > < div css = { headStyle } > < span css = { numberStyle } > { streams . length } < / span > participant ( s ) < / div > { streams . sort ( sortByVideo ) . map ( ( [ peerId , stream ] ) = > { const entry = stats . find ( ( [ id ] ) = > id == = peerId ) ; const stat = entry   ? entry [ <NUM_LIT> ] : null ; const isPinned = peerId == = pinnedId ; return ( < RemoteStreamLayout key = { peerId } stream = { stream } stat = { stat } isPinned = { isPinned } onClickSetPinned = { ( ) = > onClickSetPinned ( peerId ) } / > ) ; } ) } < / div > ) ; export default RemoteStreamsLayout ; const wrapperStyle = css ( { width : rightMenuWidth , } ) ; const headStyle = css ( { height : rightMenuTogglerHeight , padding : <NUM_LIT> , boxSizing : "<STR_LIT>" , fontSize : "<STR_LIT>" , textAlign : "<STR_LIT>" , } ) ; const numberStyle = css ( { fontSize : "<STR_LIT>" , fontWeight : "<STR_LIT>" , } ) ; </s>
<s> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Effect <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataPersistence <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RepositoryStatisticsDataService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fromSingleRepositoryStatisticsActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SingleRepositoryStatisticsPartialState <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class RepositoryStatisticsEffects { <EOL> @ Effect ( ) getRepositoryStatistics $ = this . dp . fetch ( fromSingleRepositoryStatisticsActions . Types . GetRepositoryStatistics , { <EOL> id : ( ) = > { } , <EOL> run : ( action ) = > { <EOL> return this . singleRepositoryStatisticsDataService . getRepositoryStatistics ( action . payload ) . pipe ( map ( data = > new fromSingleRepositoryStatisticsActions . GetRepositoryStatisticsSuccess ( data ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromSingleRepositoryStatisticsActions . GetRepositoryStatisticsFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> constructor ( private dp , private singleRepositoryStatisticsDataService ) { } <EOL> } </s>
<s> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Action <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AddRepositoryPayload , <EOL> DeleteRepositoryPayload , <EOL> EditRepositoryPayload , <EOL> Repository <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AddRepositorySuccessPayload <EOL> } from '<STR_LIT>' ; <EOL> export namespace fromRepositoryActions { <EOL> export enum Types { <EOL> GetRepositoryCollection = '<STR_LIT>' , GetRepositoryCollectionFail = '<STR_LIT>' , GetRepositoryCollectionSuccess = '<STR_LIT>' , AddRepository = '<STR_LIT>' , AddRepositoryFail = '<STR_LIT>' , AddRepositorySuccess = '<STR_LIT>' , DeleteRepository = '<STR_LIT>' , DeleteRepositoryFail = '<STR_LIT>' , DeleteRepositorySuccess = '<STR_LIT>' , EditRepository = '<STR_LIT>' , EditRepositoryFail = '<STR_LIT>' , EditRepositorySuccess = '<STR_LIT>' <EOL> } <EOL> export class GetRepositoryCollection implements Action { <EOL> readonly type = Types . GetRepositoryCollection ; <EOL> } <EOL> export class GetRepositoryCollectionFail implements Action { <EOL> readonly type = Types . GetRepositoryCollectionFail ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class GetRepositoryCollectionSuccess implements Action { <EOL> readonly type = Types . GetRepositoryCollectionSuccess ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class AddRepository implements Action { <EOL> readonly type = Types . AddRepository ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class AddRepositoryFail implements Action { <EOL> readonly type = Types . AddRepositoryFail ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class AddRepositorySuccess implements Action { <EOL> readonly type = Types . AddRepositorySuccess ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class DeleteRepository implements Action { <EOL> readonly type = Types . DeleteRepository ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class DeleteRepositoryFail implements Action { <EOL> readonly type = Types . DeleteRepositoryFail ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class DeleteRepositorySuccess implements Action { <EOL> readonly type = Types . DeleteRepositorySuccess ; <EOL> } <EOL> export class EditRepository implements Action { <EOL> readonly type = Types . EditRepository ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class EditRepositoryFail implements Action { <EOL> readonly type = Types . EditRepositoryFail ; <EOL> constructor ( public payload ) { } <EOL> } <EOL> export class EditRepositorySuccess implements Action { <EOL> readonly type = Types . EditRepositorySuccess ; <EOL> } <EOL> export type CollectiveType = GetRepositoryCollection | GetRepositoryCollectionFail | GetRepositoryCollectionSuccess | AddRepository | AddRepositoryFail | AddRepositorySuccess | DeleteRepository | DeleteRepositoryFail | DeleteRepositorySuccess | EditRepository | EditRepositoryFail | EditRepositorySuccess ; <EOL> } </s>
<s> import _ , { <EOL> get <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Subscription <EOL> } from '<STR_LIT>' ; <EOL> import * as Rx from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VISUALIZE_EMBEDDABLE_TYPE <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> TimeRange , <EOL> Query , <EOL> opensearchFilters , <EOL> Filter , <EOL> TimefilterContract , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EmbeddableInput , <EOL> EmbeddableOutput , <EOL> Embeddable , <EOL> IContainer , <EOL> Adapters , <EOL> SavedObjectEmbeddableInput , <EOL> ReferenceOrValueEmbeddable , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IExpressionLoaderParams , <EOL> ExpressionsStart , <EOL> ExpressionRenderError , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> buildPipeline <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Vis , <EOL> SerializedVis <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getExpressions , <EOL> getUiActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VIS_EVENT_TO_TRIGGER <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisualizeEmbeddableFactoryDeps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TriggerId <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SavedObjectAttributes <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AttributeService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SavedVisualizationsLoader <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisSavedObject <EOL> } from '<STR_LIT>' ; <EOL> const getKeys = < T extends { } > ( o ) : Array < keyof T > = > Object . keys ( o ) as Array < keyof T > ; export interface VisualizeEmbeddableConfiguration { vis : Vis ; indexPatterns   ? : IIndexPattern [ ] ; editPath : string ; editUrl : string ; editable : boolean ; deps : VisualizeEmbeddableFactoryDeps ; } export interface VisualizeInput extends EmbeddableInput { vis   ? : { colors   ? : { [ key ] : string ; } ; } ; savedVis   ? : SerializedVis ; table   ? : unknown ; } export interface VisualizeOutput extends EmbeddableOutput { editPath : string ; editApp : string ; editUrl : string ; indexPatterns   ? : IIndexPattern [ ] ; visTypeName : string ; } export type VisualizeSavedObjectAttributes = SavedObjectAttributes & { title : string ; vis   ? : Vis ; savedVis   ? : VisSavedObject ; } ; export type VisualizeByValueInput = { attributes : VisualizeSavedObjectAttributes ; } & VisualizeInput ; export type VisualizeByReferenceInput = SavedObjectEmbeddableInput & VisualizeInput ; type ExpressionLoader = InstanceType < ExpressionsStart [ '<STR_LIT>' ] > ; export class VisualizeEmbeddable extends Embeddable < VisualizeInput , VisualizeOutput > implements ReferenceOrValueEmbeddable < VisualizeByValueInput , VisualizeByReferenceInput > { private handler   ? : ExpressionLoader ; private timefilter : TimefilterContract ; private timeRange   ? : TimeRange ; private query   ? : Query ; private filters   ? : Filter [ ] ; private visCustomizations   ? : Pick < VisualizeInput , '<STR_LIT>' | '<STR_LIT>' > ; private subscriptions : Subscription [ ] = [ ] ; private expression : string = '<STR_LIT>' ; private vis : Vis ; private domNode : any ; public readonly type = VISUALIZE_EMBEDDABLE_TYPE ; private autoRefreshFetchSubscription : Subscription ; private abortController   ? : AbortController ; private readonly deps : VisualizeEmbeddableFactoryDeps ; private readonly inspectorAdapters   ? : Adapters ; private attributeService   ? : AttributeService < VisualizeSavedObjectAttributes , VisualizeByValueInput , VisualizeByReferenceInput > ; private savedVisualizationsLoader   ? : SavedVisualizationsLoader ; constructor ( timefilter , { vis , editPath , editUrl , indexPatterns , editable , deps } , initialInput , attributeService   ? , savedVisualizationsLoader   ? , parent   ? ) { super ( initialInput , { defaultTitle : vis . title , editPath , editApp : '<STR_LIT>' , editUrl , indexPatterns , editable , visTypeName : vis . type . name , } , parent ) ; this . deps = deps ; this . timefilter = timefilter ; this . vis = vis ; this . vis . uiState . on ( '<STR_LIT>' , this . uiStateChangeHandler ) ; this . vis . uiState . on ( '<STR_LIT>' , this . reload ) ; this . attributeService = attributeService ; this . savedVisualizationsLoader = savedVisualizationsLoader ; this . autoRefreshFetchSubscription = timefilter . getAutoRefreshFetch $ ( ) . subscribe ( this . updateHandler . bind ( this ) ) ; this . subscriptions . push ( Rx . merge ( this . getOutput $ ( ) , this . getInput $ ( ) ) . subscribe ( ( ) = > { this . handleChanges ( ) ; } ) ) ; const inspectorAdapters = this . vis . type . inspectorAdapters ; if ( inspectorAdapters ) { this . inspectorAdapters = typeof inspectorAdapters == = '<STR_LIT>'   ? inspectorAdapters ( ) : inspectorAdapters ; } } public getDescription ( ) { return this . vis . description ; } public getInspectorAdapters = ( ) = > { if (   ! this . handler | | ( this . inspectorAdapters & &   ! Object . keys ( this . inspectorAdapters ) . length ) ) { return undefined ; } return this . handler . inspect ( ) ; } ; public openInspector = ( ) = > { if (   ! this . handler ) return ; const adapters = this . handler . inspect ( ) ; if (   ! adapters ) return ; return this . deps . start ( ) . plugins . inspector . open ( adapters , { title : this . getTitle ( ) , } ) ; } ; / ** <EOL> * Transfers all changes in the containerState . customization into <EOL> * the uiState of this visualization . <EOL> * / public transferCustomizationsToUiState ( ) { const visCustomizations = { vis : this . input . vis , table : this . input . table } ; if ( visCustomizations . vis | | visCustomizations . table ) { if (   ! _ . isEqual ( visCustomizations , this . visCustomizations ) ) { this . visCustomizations = visCustomizations ; this . vis . uiState . off ( '<STR_LIT>' , this . uiStateChangeHandler ) ; this . vis . uiState . clearAllKeys ( ) ; if ( visCustomizations . vis ) { this . vis . uiState . set ( '<STR_LIT>' , visCustomizations . vis ) ; getKeys ( visCustomizations ) . forEach ( ( key ) = > { this . vis . uiState . set ( key , visCustomizations [ key ] ) ; } ) ; } if ( visCustomizations . table ) { this . vis . uiState . set ( '<STR_LIT>' , visCustomizations . table ) ; } this . vis . uiState . on ( '<STR_LIT>' , this . uiStateChangeHandler ) ; } } else if ( this . parent ) { this . vis . uiState . clearAllKeys ( ) ; } } public async handleChanges ( ) { this . transferCustomizationsToUiState ( ) ; let dirty = false ; if (   ! _ . isEqual ( this . input . timeRange , this . timeRange ) ) { this . timeRange = _ . cloneDeep ( this . input . timeRange ) ; dirty = true ; } if (   ! opensearchFilters . onlyDisabledFiltersChanged ( this . input . filters , this . filters ) ) { this . filters = this . input . filters ; dirty = true ; } if (   ! _ . isEqual ( this . input . query , this . query ) ) { this . query = this . input . query ; dirty = true ; } if ( this . vis . description & & this . domNode ) { this . domNode . setAttribute ( '<STR_LIT>' , this . vis . description ) ; } if ( this . handler & & dirty ) { this . updateHandler ( ) ; } } hasInspector = ( ) = > Boolean ( this . getInspectorAdapters ( ) ) ; onContainerLoading = ( ) = > { this . renderComplete . dispatchInProgress ( ) ; this . updateOutput ( { loading : true , error : undefined } ) ; } ; onContainerRender = ( ) = > { this . renderComplete . dispatchComplete ( ) ; this . updateOutput ( { loading : false , error : undefined } ) ; } ; onContainerError = ( error ) = > { if ( this . abortController ) { this . abortController . abort ( ) ; } this . renderComplete . dispatchError ( ) ; this . updateOutput ( { loading : false , error } ) ; } ; param { Element } domNode public async render ( domNode ) { this . timeRange = _ . cloneDeep ( this . input . timeRange ) ; this . transferCustomizationsToUiState ( ) ; const div = document . createElement ( '<STR_LIT>' ) ; div . className =   ` visualize panel - content panel - content - - fullWidth ` ; domNode . appendChild ( div ) ; this . domNode = div ; super . render ( this . domNode ) ; const expressions = getExpressions ( ) ; this . handler = new expressions . ExpressionLoader ( this . domNode , undefined , { onRenderError : ( element , error ) = > { this . onContainerError ( error ) ; } , } ) ; this . subscriptions . push ( this . handler . events $ . subscribe ( async ( event ) = > { if ( event . name == = '<STR_LIT>' ) { const agg = this . vis . data . aggs   ! . aggs . find ( ( a ) = > { return get ( a , '<STR_LIT>' ) == = '<STR_LIT>' ; } ) ; if ( ( agg & & agg . params . precision != = event . data . precision ) | | ( agg & &   ! _ . isEqual ( agg . params . boundingBox , event . data . boundingBox ) ) ) { agg . params . boundingBox = event . data . boundingBox ; agg . params . precision = event . data . precision ; this . reload ( ) ; } return ; } if (   ! this . input . disableTriggers ) { const triggerId = get ( VIS_EVENT_TO_TRIGGER , event . name , VIS_EVENT_TO_TRIGGER . filter ) ; let context ; if ( triggerId == = VIS_EVENT_TO_TRIGGER . applyFilter ) { context = { embeddable : this , timeFieldName : this . vis . data . indexPattern   ? . timeFieldName   ! , ... event . data , } ; } else { context = { embeddable : this , data : { timeFieldName : this . vis . data . indexPattern   ? . timeFieldName   ! , ... event . data } , } ; } getUiActions ( ) . getTrigger ( triggerId ) . exec ( context ) ; } } ) ) ; if ( this . vis . description ) { div . setAttribute ( '<STR_LIT>' , this . vis . description ) ; } div . setAttribute ( '<STR_LIT>' , '<STR_LIT>' ) ; div . setAttribute ( '<STR_LIT>' , '<STR_LIT>' ) ; this . subscriptions . push ( this . handler . loading $ . subscribe ( this . onContainerLoading ) ) ; this . subscriptions . push ( this . handler . render $ . subscribe ( this . onContainerRender ) ) ; this . updateHandler ( ) ; } public destroy ( ) { super . destroy ( ) ; this . subscriptions . forEach ( ( s ) = > s . unsubscribe ( ) ) ; this . vis . uiState . off ( '<STR_LIT>' , this . uiStateChangeHandler ) ; this . vis . uiState . off ( '<STR_LIT>' , this . reload ) ; if ( this . handler ) { this . handler . destroy ( ) ; this . handler . getElement ( ) . remove ( ) ; } this . autoRefreshFetchSubscription . unsubscribe ( ) ; } public reload = ( ) = > { this . handleVisUpdate ( ) ; } ; private async updateHandler ( ) { const expressionParams = { searchContext : { timeRange : this . timeRange , query : this . input . query , filters : this . input . filters , } , uiState : this . vis . uiState , inspectorAdapters : this . inspectorAdapters , } ; if ( this . abortController ) { this . abortController . abort ( ) ; } this . abortController = new AbortController ( ) ; const abortController = this . abortController ; this . expression = await buildPipeline ( this . vis , { timefilter : this . timefilter , timeRange : this . timeRange , abortSignal : this . abortController   ! . signal , } ) ; if ( this . handler & &   ! abortController . signal . aborted ) { this . handler . update ( this . expression , expressionParams ) ; } } private handleVisUpdate = async ( ) = > { this . updateHandler ( ) ; } ; private uiStateChangeHandler = ( ) = > { this . updateInput ( { ... this . vis . uiState . toJSON ( ) , } ) ; } ; public supportedTriggers ( ) { return this . vis . type . getSupportedTriggers   ? . ( )   ? ? [ ] ; } inputIsRefType = ( input ) : input is VisualizeByReferenceInput = > { if (   ! this . attributeService ) { throw new Error ( '<STR_LIT>' ) ; } return this . attributeService . inputIsRefType ( input as VisualizeByReferenceInput ) ; } ; getInputAsValueType = async ( ) : Promise < VisualizeByValueInput > = > { const input = { savedVis : this . vis . serialize ( ) , } ; if ( this . getTitle ( ) ) { input . savedVis . title = this . getTitle ( ) ; } delete input . savedVis . id ; return new Promise < VisualizeByValueInput > ( ( resolve ) = > { resolve ( { ... ( input as VisualizeByValueInput ) } ) ; } ) ; } ; getInputAsRefType = async ( ) : Promise < VisualizeByReferenceInput > = > { const savedVis = await this . savedVisualizationsLoader   ? . get ( { } ) ; if (   ! savedVis ) { throw new Error ( '<STR_LIT>' ) ; } if (   ! this . attributeService ) { throw new Error ( '<STR_LIT>' ) ; } const saveModalTitle = this . getTitle ( )   ? this . getTitle ( ) : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) ; const attributes = { savedVis , vis : this . vis , title : this . vis . title , } ; return this . attributeService . getInputAsRefType ( { id : this . id , attributes , } , { showSaveModal : true , saveModalTitle } ) ; } ; } </s>
<s> / ** <EOL> * order <NUM_LIT> <EOL> * / <EOL> import type { <EOL> Rule <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ConvertToCssObject , <EOL> generatorLayer , <EOL> getUnitAndNum <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UNIT_ENUM_STR , <EOL> NONNEGATIVE_NUMBER_REGEX_STR <EOL> } from '<STR_LIT>' ; <EOL> export const flexBasis = ( ) = > [ <EOL> [ new RegExp ( ` ^ flex - basis - ( ? < value > ( ( ? < num > $ { NONNEGATIVE_NUMBER_REGEX_STR } ) ( ? < unit > $ { UNIT_ENUM_STR } ) ? ) | initial | inherit | auto ) $ ` ) , ( { <EOL> groups <EOL> } ) = > { <EOL> const { <EOL> value , <EOL> num , <EOL> unit <EOL> } = groups as { <EOL> value : string ; num   ? : string ; unit   ? : string ; <EOL> } ; <EOL> const newValue = num   ? getUnitAndNum ( unit , num ) : value ; <EOL> return ConvertToCssObject ( [ ` flex - basis :   $ { newValue } ` ] ) ; <EOL> } , generatorLayer ( <NUM_LIT> ) , ] , <EOL> ] as Rule [ ] ; </s>
<s> import { <EOL> ActionInternal <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TriggerInternal <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SELECT_RANGE_TRIGGER , <EOL> VALUE_CLICK_TRIGGER , <EOL> APPLY_FILTER_TRIGGER , <EOL> VISUALIZE_FIELD_TRIGGER , <EOL> VISUALIZE_GEO_FIELD_TRIGGER , <EOL> DEFAULT_TRIGGER , <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> RangeSelectContext , <EOL> ValueClickContext <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> ApplyGlobalFilterActionContext <EOL> } from '<STR_LIT>' ; <EOL> export type TriggerRegistry = Map < TriggerId , TriggerInternal < any > > ; <EOL> export type ActionRegistry = Map < string , ActionInternal > ; <EOL> export type TriggerToActionsRegistry = Map < TriggerId , string [ ] > ; <EOL> export interface VisualizeFieldContext { <EOL> fieldName : string ; indexPatternId : string ; contextualFields   ? : string [ ] ; <EOL> } <EOL> export type TriggerId = keyof TriggerContextMapping ; <EOL> export type BaseContext = object ; <EOL> export type TriggerContext = BaseContext ; <EOL> export interface TriggerContextMapping { <EOL> [ DEFAULT_TRIGGER ] : TriggerContext ; <EOL> [ SELECT_RANGE_TRIGGER ] : RangeSelectContext ; <EOL> [ VALUE_CLICK_TRIGGER ] : ValueClickContext ; <EOL> [ APPLY_FILTER_TRIGGER ] : ApplyGlobalFilterActionContext ; <EOL> [ VISUALIZE_FIELD_TRIGGER ] : VisualizeFieldContext ; <EOL> [ VISUALIZE_GEO_FIELD_TRIGGER ] : VisualizeFieldContext ; <EOL> } <EOL> const DEFAULT_ACTION = '<STR_LIT>' ; <EOL> export const ACTION_VISUALIZE_FIELD = '<STR_LIT>' ; <EOL> export const ACTION_VISUALIZE_GEO_FIELD = '<STR_LIT>' ; <EOL> export const ACTION_VISUALIZE_LENS_FIELD = '<STR_LIT>' ; <EOL> export type ActionType = keyof ActionContextMapping ; <EOL> export interface ActionContextMapping { <EOL> [ DEFAULT_ACTION ] : BaseContext ; <EOL> [ ACTION_VISUALIZE_FIELD ] : VisualizeFieldContext ; <EOL> [ ACTION_VISUALIZE_GEO_FIELD ] : VisualizeFieldContext ; <EOL> [ ACTION_VISUALIZE_LENS_FIELD ] : VisualizeFieldContext ; <EOL> } </s>
<s> import { <EOL> useEffect , <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPattern , <EOL> getServices <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DocProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OpenSearchSearchHit <EOL> } from '<STR_LIT>' ; <EOL> export enum OpenSearchRequestState { <EOL> Loading , <EOL> NotFound , <EOL> Found , <EOL> Error , <EOL> NotFoundIndexPattern <EOL> } <EOL> / ** <EOL> * helper function to build a query body for OpenSearch <EOL> * https : // opensearch . org / docs / latest / opensearch / query - dsl / index / <EOL> * / <EOL> export function buildSearchBody ( id , indexPattern ) { <EOL> const computedFields = indexPattern . getComputedFields ( ) ; <EOL> return { <EOL> query : { <EOL> ids : { <EOL> values : [ id ] , <EOL> } , <EOL> } , <EOL> stored_fields : computedFields . storedFields , <EOL> _source : true , <EOL> script_fields : computedFields . scriptFields , <EOL> docvalue_fields : computedFields . docvalueFields , <EOL> } ; <EOL> } <EOL> / ** <EOL> * Custom react hook for querying a single doc in OpenSearch <EOL> * / <EOL> export function useOpenSearchDocSearch ( { <EOL> id , <EOL> index , <EOL> indexPatternId , <EOL> indexPatternService , <EOL> } ) { <EOL> const [ indexPattern , setIndexPattern ] = useState < IndexPattern | null > ( null ) ; <EOL> const [ status , setStatus ] = useState ( OpenSearchRequestState . Loading ) ; <EOL> const [ hit , setHit ] = useState < OpenSearchSearchHit | null > ( null ) ; <EOL> useEffect ( ( ) = > { <EOL> async function requestData ( ) { <EOL> try { <EOL> const indexPatternEntity = await indexPatternService . get ( indexPatternId ) ; <EOL> setIndexPattern ( indexPatternEntity ) ; <EOL> const { <EOL> rawResponse <EOL> } = await getServices ( ) . data . search . search ( { <EOL> params : { <EOL> index , <EOL> body : buildSearchBody ( id , indexPatternEntity ) , <EOL> } , <EOL> } ) . toPromise ( ) ; <EOL> const hits = rawResponse . hits ; <EOL> if ( hits ? . hits ? . [ <NUM_LIT> ] ) { <EOL> setStatus ( OpenSearchRequestState . Found ) ; <EOL> setHit ( hits . hits [ <NUM_LIT> ] ) ; <EOL> } else { <EOL> setStatus ( OpenSearchRequestState . NotFound ) ; <EOL> } <EOL> } catch ( err ) { <EOL> if ( err . savedObjectId ) { <EOL> setStatus ( OpenSearchRequestState . NotFoundIndexPattern ) ; <EOL> } else if ( err . status == = <NUM_LIT> ) { <EOL> setStatus ( OpenSearchRequestState . NotFound ) ; <EOL> } else { <EOL> setStatus ( OpenSearchRequestState . Error ) ; <EOL> } <EOL> } <EOL> } <EOL> requestData ( ) ; <EOL> } , [ id , index , indexPatternId , indexPatternService ] ) ; <EOL> return [ status , hit , indexPattern ] ; <EOL> } </s>
<s> import * as path from '<STR_LIT>' ; <EOL> export const CLIENT_PATH = path . join ( __dirname , '<STR_LIT>' ) ; </s>
<s> import { <EOL> IAggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggType , <EOL> AggTypeConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggParamType <EOL> } from '<STR_LIT>' ; <EOL> export interface IBucketAggConfig extends IAggConfig { <EOL> type : InstanceType < typeof BucketAggType > ; <EOL> } <EOL> export interface BucketAggParam < TBucketAggConfig extends IAggConfig > extends AggParamType < TBucketAggConfig > { <EOL> scriptable   ? : boolean ; filterFieldTypes   ? : OSD_FIELD_TYPES | OSD_FIELD_TYPES [ ] | '<STR_LIT>' ; <EOL> } <EOL> const bucketType = '<STR_LIT>' ; <EOL> interface BucketAggTypeConfig < TBucketAggConfig extends IAggConfig > extends AggTypeConfig < TBucketAggConfig , BucketAggParam < TBucketAggConfig > > { <EOL> getKey   ? : ( bucket : any , key : any , agg : IAggConfig ) = > any ; <EOL> } <EOL> export class BucketAggType < TBucketAggConfig extends IAggConfig = IBucketAggConfig > extends AggType < TBucketAggConfig , BucketAggParam < TBucketAggConfig > > { <EOL> getKey : ( bucket : any , key : any , agg : TBucketAggConfig ) = > any ; type = bucketType ; constructor ( config ) { <EOL> super ( config ) ; <EOL> this . getKey = config . getKey | | ( ( bucket , key ) = > { <EOL> return key | | bucket . key ; <EOL> } ) ; <EOL> } <EOL> } <EOL> export function isBucketAggType ( aggConfig ) { <EOL> return aggConfig & & aggConfig . type == = bucketType ; <EOL> } </s>
<s> import { <EOL> Reporter , <EOL> METRIC_TYPE <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Subject , <EOL> merge <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Storage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createReporter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PluginInitializerContext , <EOL> Plugin , <EOL> CoreSetup , <EOL> CoreStart , <EOL> HttpSetup , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> reportApplicationUsage <EOL> } from '<STR_LIT>' ; <EOL> interface PublicConfigType { <EOL> uiMetric : { <EOL> enabled : boolean ; debug : boolean ; <EOL> } ; <EOL> } <EOL> export interface UsageCollectionSetup { <EOL> allowTrackUserAgent : ( allow : boolean ) = > void ; reportUiStats : Reporter [ '<STR_LIT>' ] ; METRIC_TYPE : typeof METRIC_TYPE ; __LEGACY : { <EOL> deprecated appChanged : ( appId : string ) = > void ; <EOL> } ; <EOL> } <EOL> export interface UsageCollectionStart { <EOL> reportUiStats : Reporter [ '<STR_LIT>' ] ; METRIC_TYPE : typeof METRIC_TYPE ; <EOL> } <EOL> export function isUnauthenticated ( http ) { <EOL> const { <EOL> anonymousPaths <EOL> } = http ; <EOL> return anonymousPaths . isAnonymous ( window . location . pathname ) ; <EOL> } <EOL> export class UsageCollectionPlugin implements Plugin < UsageCollectionSetup , UsageCollectionStart > { <EOL> private readonly legacyAppId $ = new Subject < string > ( ) ; private trackUserAgent : boolean = true ; private reporter   ? : Reporter ; private config : PublicConfigType ; constructor ( initializerContext ) { <EOL> this . config = initializerContext . config . get < PublicConfigType > ( ) ; <EOL> } <EOL> public setup ( { <EOL> http <EOL> } ) { <EOL> const localStorage = new Storage ( window . localStorage ) ; <EOL> const debug = this . config . uiMetric . debug ; <EOL> this . reporter = createReporter ( { <EOL> localStorage , <EOL> debug , <EOL> fetch : http , <EOL> } ) ; <EOL> return { <EOL> allowTrackUserAgent : ( allow ) = > { <EOL> this . trackUserAgent = allow ; <EOL> } , <EOL> reportUiStats : this . reporter . reportUiStats , <EOL> METRIC_TYPE , <EOL> __LEGACY : { <EOL> appChanged : ( appId ) = > this . legacyAppId $ . next ( appId ) , <EOL> } , <EOL> } ; <EOL> } <EOL> public start ( { <EOL> http , <EOL> application <EOL> } ) { <EOL> if ( ! this . reporter ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> if ( this . config . uiMetric . enabled & &   ! isUnauthenticated ( http ) ) { <EOL> this . reporter . start ( ) ; <EOL> } <EOL> if ( this . trackUserAgent ) { <EOL> this . reporter . reportUserAgent ( '<STR_LIT>' ) ; <EOL> } <EOL> reportApplicationUsage ( merge ( application . currentAppId $ , this . legacyAppId $ ) , this . reporter ) ; <EOL> return { <EOL> reportUiStats : this . reporter . reportUiStats , <EOL> METRIC_TYPE , <EOL> } ; <EOL> } <EOL> public stop ( ) { } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggTypesDependencies <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BucketAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RangeKey <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createFilterRange <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BUCKET_TYPES <EOL> } from '<STR_LIT>' ; <EOL> const rangeTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export interface RangeBucketAggDependencies { <EOL> getFieldFormatsStart : AggTypesDependencies [ '<STR_LIT>' ] ; <EOL> } <EOL> export interface AggParamsRange extends BaseAggParams { <EOL> field : string ; ranges   ? : Array < { <EOL> from : number ; to : number ; <EOL> } > ; <EOL> } <EOL> export const getRangeBucketAgg = ( { <EOL> getFieldFormatsStart <EOL> } ) = > { <EOL> const keyCaches = new WeakMap ( ) ; <EOL> return new BucketAggType ( { <EOL> name : BUCKET_TYPES . RANGE , <EOL> title : rangeTitle , <EOL> createFilter : createFilterRange ( getFieldFormatsStart ) , <EOL> makeLabel ( aggConfig ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> fieldName : aggConfig . getFieldDisplayName ( ) , <EOL> } , <EOL> } ) ; <EOL> } , <EOL> getKey ( bucket , key , agg ) { <EOL> let keys = keyCaches . get ( agg ) ; <EOL> if ( ! keys ) { <EOL> keys = new Map ( ) ; <EOL> keyCaches . set ( agg , keys ) ; <EOL> } <EOL> const id = RangeKey . idBucket ( bucket ) ; <EOL> key = keys . get ( id ) ; <EOL> if ( ! key ) { <EOL> key = new RangeKey ( bucket ) ; <EOL> keys . set ( id , key ) ; <EOL> } <EOL> return key ; <EOL> } , <EOL> getSerializedFormat ( agg ) { <EOL> const format = agg . params . field   ? agg . aggConfigs . indexPattern . getFormatterForField ( agg . params . field ) . toJSON ( ) : { <EOL> id : undefined , <EOL> params : undefined <EOL> } ; <EOL> return { <EOL> id : '<STR_LIT>' , <EOL> params : { <EOL> id : format . id , <EOL> params : format . params , <EOL> } , <EOL> } ; <EOL> } , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : [ OSD_FIELD_TYPES . NUMBER ] , <EOL> } , { <EOL> name : '<STR_LIT>' , <EOL> default : [ { <EOL> from : <NUM_LIT> , <EOL> to : <NUM_LIT> <EOL> } , { <EOL> from : <NUM_LIT> , <EOL> to : <NUM_LIT> <EOL> } , ] , <EOL> write ( aggConfig , output ) { <EOL> output . params . ranges = aggConfig . params . ranges ; <EOL> output . params . keyed = true ; <EOL> } , <EOL> } , ] , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> Component , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Store <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> GameState <EOL> } from "<STR_LIT>" ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' <EOL> } ) export class AppComponent implements OnInit { <EOL> gameState ; <EOL> constructor ( private store ) { } <EOL> ngOnInit ( ) { <EOL> this . gameState = this . store . select < GameState > ( '<STR_LIT>' ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> EuiIcon , <EOL> IconType <EOL> } from '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> interface VisTypeIconProps { <EOL> icon   ? : IconType ; <EOL> image   ? : string ; <EOL> } <EOL> / ** <EOL> * This renders the icon for a specific visualization type . <EOL> * This currently checks the following : <EOL> * - If image is set , use that as the   ` src ` of an image <EOL> * - Otherwise use the icon as an EuiIcon or the '<STR_LIT>' icon if that ' s not set <EOL> * / <EOL> export const VisTypeIcon = ( { <EOL> icon , <EOL> image <EOL> } ) = > { <EOL> return ( < React . Fragment > { image & & < img src = { image } alt = "<STR_LIT>" className = "<STR_LIT>" / > } {   ! image & & < EuiIcon type = { icon | | '<STR_LIT>' } size = "<STR_LIT>" color = "<STR_LIT>" / > } < / React . Fragment > ) ; } ; </s>
<s> import { <EOL> VFC <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Outlet <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Divider <EOL> } from '<STR_LIT>' ; <EOL> import HomeButton from '<STR_LIT>' ; <EOL> const Characters = ( ) = > ( < > < header > < h1 >   『 SLAM DUNK   』 登場人物 < / h1 > < / header > < Outlet / > < Divider hidden / > < HomeButton / > < / > ) ; export default Characters ; </s>
<s> import { <EOL> metaesEval , <EOL> uncps <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> createScript <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Continuation , <EOL> Environment , <EOL> ErrorContinuation , <EOL> Evaluate , <EOL> EvaluationConfig <EOL> } from "<STR_LIT>" ; <EOL> param _receiver param _value <EOL> export function callcc < T , U > ( _receiver , _value   ? ) { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> let script ; <EOL> export function lifted < R , T > ( fn , closure   ? ) { <EOL> if ( ! script ) { <EOL> script = createScript ( ( ... args ) = > callcc ( fn , args ) ) ; <EOL> } <EOL> return uncps ( metaesEval ) ( script , { <EOL> values : { <EOL> callcc , <EOL> fn <EOL> } , <EOL> prev : closure <EOL> } ) ; <EOL> } <EOL> export function liftedAll ( fns , closure   ? ) { <EOL> const result = { } ; <EOL> for ( let k in fns ) { <EOL> result [ k ] = lifted ( fns [ k ] , closure ) ; <EOL> } <EOL> return result ; <EOL> } </s>
<s> / ** <EOL> * Copyright ( c ) <NUM_LIT> , <NUM_LIT> Oracle and / or its affiliates . All rights reserved . <EOL> * This software is dual - licensed to you under the Universal Permissive License ( UPL ) <NUM_LIT> as shown at https : // oss . oracle . com / licenses / upl or Apache License <NUM_LIT> as shown at http : // www . apache . org / licenses / LICENSE - <NUM_LIT> . You may choose either license . <EOL> * / <EOL> import { <EOL> Readable <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Buffer <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> isReadableStream <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ChunkBuffer <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> ChunkStream <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> getReadableStreamData <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> getReadableData <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> BinaryBody <EOL> } from "<STR_LIT>" ; <EOL> export default function getChunk ( data , partSize ) { <EOL> if ( data instanceof Buffer ) { <EOL> return ChunkBuffer ( data , partSize ) ; <EOL> } else if ( data instanceof Readable ) { <EOL> return ChunkStream < Readable > ( data , partSize , getReadableData ) ; <EOL> } else if ( data instanceof String | | typeof data == = "<STR_LIT>" | | data instanceof Uint8Array ) { <EOL> return ChunkBuffer ( Buffer . from ( data as string ) , partSize ) ; <EOL> } <EOL> if ( typeof ( data as any ) . stream == = "<STR_LIT>" ) { <EOL> let stream = ( data as any ) . stream ( ) ; <EOL> if ( stream . getReader ) { <EOL> return ChunkStream < ReadableStream > ( stream , partSize , getReadableStreamData ) ; <EOL> } else { <EOL> return ChunkStream < Readable > ( stream as Readable , partSize , getReadableData ) ; <EOL> } <EOL> } else if ( isReadableStream ( data ) ) { <EOL> return ChunkStream < ReadableStream > ( data as ReadableStream , partSize , getReadableStreamData ) ; <EOL> } else { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } <EOL> } </s>
<s> import   $ from '<STR_LIT>' ; <EOL> interface LazyScope extends ng . IScope { <EOL> [ key ] : any ; <EOL> } <EOL> export function createInfiniteScrollDirective ( ) { <EOL> return { <EOL> restrict : '<STR_LIT>' , <EOL> scope : { <EOL> more : '<STR_LIT>' , <EOL> } , <EOL> link : ( $ scope ,   $ element ) = > { <EOL> const   $ window =   $ ( window ) ; <EOL> let checkTimer ; <EOL> function onScroll ( ) { <EOL> if ( ! $ scope . more ) return ; <EOL> const winHeight = Number ( $ window . height ( ) ) ; <EOL> const winBottom = Number ( winHeight ) + Number ( $ window . scrollTop ( ) ) ; <EOL> const offset =   $ element . offset ( ) ; <EOL> const elTop = offset   ? offset . top : <NUM_LIT> ; <EOL> const remaining = elTop - winBottom ; <EOL> if ( remaining <= winHeight * <NUM_LIT> ) { <EOL>                                         $ scope [ $ scope . $ $ phase   ? '<STR_LIT>' : '<STR_LIT>' ] ( function ( ) { <EOL>                                                 $ scope . more ( ) ; <EOL> } ) ; <EOL> } <EOL> } <EOL> function scheduleCheck ( ) { <EOL> if ( checkTimer ) return ; <EOL> checkTimer = setTimeout ( function ( ) { <EOL> checkTimer = null ; <EOL> onScroll ( ) ; <EOL> } , <NUM_LIT> ) ; <EOL> } <EOL>                         $ window . on ( '<STR_LIT>' , scheduleCheck ) ; <EOL>                         $ scope . $ on ( '<STR_LIT>' , function ( ) { <EOL> clearTimeout ( checkTimer ) ; <EOL>                                 $ window . off ( '<STR_LIT>' , scheduleCheck ) ; <EOL> } ) ; <EOL> scheduleCheck ( ) ; <EOL> } , <EOL> } ; <EOL> } </s>
<s> export const environment = { <EOL> production : false <EOL> } ; </s>
<s> import { <EOL> ChangeDetectionStrategy , <EOL> Component , <EOL> EventEmitter , <EOL> Output , <EOL> Input <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> User <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class NavbarComponent { <EOL> @ Input ( ) user : User ; <EOL> @ Output ( ) logout = new EventEmitter < void > ( ) ; <EOL> onLogout ( ) { <EOL> this . logout . emit ( ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OpenSearchDashboardsContext , <EOL> ExpressionFunctionDefinition , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getSearchService , <EOL> getUiSettings <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OpenSearchRawResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RequestStatistics , <EOL> RequestAdapter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IOpenSearchSearchResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> buildOpenSearchQuery , <EOL> getOpenSearchQueryConfig , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataPublicPluginStart <EOL> } from '<STR_LIT>' ; <EOL> const name = '<STR_LIT>' ; <EOL> type Input = OpenSearchDashboardsContext | null ; <EOL> type Output = Promise < OpenSearchRawResponse > ; <EOL> interface Arguments { <EOL> dsl : string ; index : string ; size : number ; <EOL> } <EOL> export type OpenSearchdslExpressionFunctionDefinition = ExpressionFunctionDefinition < typeof name , Input , Arguments , Output > ; <EOL> export const opensearchdsl = ( ) : OpenSearchdslExpressionFunctionDefinition = > ( { <EOL> name , <EOL> type : '<STR_LIT>' , <EOL> inputTypes : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> args : { <EOL> dsl : { <EOL> types : [ '<STR_LIT>' ] , <EOL> aliases : [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> required : true , <EOL> } , <EOL> index : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> required : true , <EOL> } , <EOL> size : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> default : <NUM_LIT> , <EOL> } , <EOL> } , <EOL> async fn ( input , args , { <EOL> inspectorAdapters , <EOL> abortSignal <EOL> } ) { <EOL> const searchService = getSearchService ( ) ; <EOL> const dsl = JSON . parse ( args . dsl ) ; <EOL> if ( input ) { <EOL> const opensearchQueryConfigs = getOpenSearchQueryConfig ( getUiSettings ( ) ) ; <EOL> const query = buildOpenSearchQuery ( undefined , input . query | | [ ] , input . filters | | [ ] , opensearchQueryConfigs ) ; <EOL> if ( ! dsl . query ) { <EOL> dsl . query = query ; <EOL> } else { <EOL> query . bool . must . push ( dsl . query ) ; <EOL> dsl . query = query ; <EOL> } <EOL> } <EOL> if ( ! inspectorAdapters . requests ) { <EOL> inspectorAdapters . requests = new RequestAdapter ( ) ; <EOL> } <EOL> const request = inspectorAdapters . requests . start ( i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , { <EOL> description : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } ) ; <EOL> request . stats ( { <EOL> indexPattern : { <EOL> label : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> value : args . index , <EOL> description : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } ) ; <EOL> let res ; <EOL> try { <EOL> res = await searchService . search ( { <EOL> params : { <EOL> index : args . index , <EOL> size : args . size , <EOL> body : dsl , <EOL> } , <EOL> } , { <EOL> abortSignal <EOL> } ) . toPromise ( ) ; <EOL> const stats = { } ; <EOL> const resp = res . rawResponse ; <EOL> if ( resp & & resp . took ) { <EOL> stats . queryTime = { <EOL> label : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> value : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> queryTime : resp . took <EOL> } , <EOL> } ) , <EOL> description : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' + '<STR_LIT>' , <EOL> } ) , <EOL> } ; <EOL> } <EOL> if ( resp & & resp . hits ) { <EOL> stats . hitsTotal = { <EOL> label : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> value :   ` $ { resp . hits . total } ` , <EOL> description : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } ; <EOL> stats . hits = { <EOL> label : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> value :   ` $ { resp . hits . hits . length } ` , <EOL> description : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } ; <EOL> } <EOL> request . stats ( stats ) . ok ( { <EOL> json : resp <EOL> } ) ; <EOL> request . json ( dsl ) ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> body : resp , <EOL> } ; <EOL> } catch ( e ) { <EOL> request . error ( { <EOL> json : e <EOL> } ) ; <EOL> throw e ; <EOL> } <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> SavedObjectLoader , <EOL> SavedObjectOpenSearchDashboardsServices , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> findListItems <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createSavedVisClass <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TypesStart <EOL> } from '<STR_LIT>' ; <EOL> export interface SavedObjectOpenSearchDashboardsServicesWithVisualizations extends SavedObjectOpenSearchDashboardsServices { <EOL> visualizationTypes : TypesStart ; <EOL> } <EOL> export type SavedVisualizationsLoader = ReturnType < typeof createSavedVisLoader > ; <EOL> export function createSavedVisLoader ( services ) { <EOL> const { <EOL> savedObjectsClient , <EOL> visualizationTypes <EOL> } = services ; <EOL> class SavedObjectLoaderVisualize extends SavedObjectLoader { <EOL> mapHitSource = ( source , id ) = > { <EOL> const visTypes = visualizationTypes ; <EOL> source . id = id ; <EOL> source . url = this . urlFor ( id ) ; <EOL> let typeName = source . typeName ; <EOL> if ( source . visState ) { <EOL> try { <EOL> typeName = JSON . parse ( String ( source . visState ) ) . type ; <EOL> } catch ( e ) { } <EOL> } <EOL> if ( ! typeName | |   ! visTypes . get ( typeName ) ) { <EOL> source . error = '<STR_LIT>' ; <EOL> return source ; <EOL> } <EOL> source . type = visTypes . get ( typeName ) ; <EOL> source . savedObjectType = '<STR_LIT>' ; <EOL> source . icon = source . type . icon ; <EOL> source . image = source . type . image ; <EOL> source . typeTitle = source . type . title ; <EOL> source . editUrl =   ` / edit / $ { id } ` ; <EOL> return source ; <EOL> } ; <EOL> urlFor ( id ) { <EOL> return   ` <EOL> } <EOL> findListItems ( search = '<STR_LIT>' , size = <NUM_LIT> ) { <EOL> return findListItems ( { <EOL> search , <EOL> size , <EOL> mapSavedObjectApiHits : this . mapSavedObjectApiHits . bind ( this ) , <EOL> savedObjectsClient , <EOL> visTypes : visualizationTypes . getAliases ( ) , <EOL> } ) ; <EOL> } <EOL> } <EOL> const SavedVis = createSavedVisClass ( services ) ; <EOL> return new SavedObjectLoaderVisualize ( SavedVis , savedObjectsClient ) as SavedObjectLoader & { <EOL> findListItems : ( search : string , size : number ) = > any ; <EOL> } ; <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * config options opt into telemetry <EOL> * / <EOL> export const CONFIG_TELEMETRY = '<STR_LIT>' ; <EOL> / ** <EOL> * config description for opting into telemetry <EOL> * / <EOL> export const getConfigTelemetryDesc = ( ) = > { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> } ; <EOL> / ** <EOL> * The amount of time , in milliseconds , to wait between reports when enabled . <EOL> * Currently <NUM_LIT> hours . <EOL> * / <EOL> export const REPORT_INTERVAL_MS = <NUM_LIT> ; <EOL> / ** <EOL> * Key for the localStorage service <EOL> * / <EOL> export const LOCALSTORAGE_KEY = '<STR_LIT>' ; <EOL> / ** <EOL> * Link to Advanced Settings . <EOL> * / <EOL> export const PATH_TO_ADVANCED_SETTINGS = '<STR_LIT>' ; <EOL> / ** <EOL> * Link to the OpenSearch Telemetry privacy statement . <EOL> * / <EOL> export const PRIVACY_STATEMENT_URL =   ` ` ; <EOL> / ** <EOL> * The endpoint version when hitting the remote telemetry service <EOL> * / <EOL> export const ENDPOINT_VERSION = '<STR_LIT>' ; </s>
<s> interface FailedShard { <EOL> shard : number ; index : string ; node : string ; reason : { <EOL> type : string ; reason : string ; script_stack : string [ ] ; script : string ; lang : string ; position : { <EOL> offset : number ; start : number ; end : number ; <EOL> } ; caused_by : { <EOL> type : string ; reason : string ; <EOL> } ; <EOL> } ; <EOL> } <EOL> export interface OpenSearchError { <EOL> body : { <EOL> statusCode : number ; error : string ; message : string ; attributes   ? : { <EOL> error   ? : { <EOL> root_cause   ? : [ { <EOL> lang : string ; script : string ; <EOL> } ] ; type : string ; reason : string ; failed_shards : FailedShard [ ] ; caused_by : { <EOL> type : string ; reason : string ; phase : string ; grouped : boolean ; failed_shards : FailedShard [ ] ; script_stack : string [ ] ; <EOL> } ; <EOL> } ; <EOL> } ; <EOL> } ; <EOL> } <EOL> export function isOpenSearchError ( e ) { <EOL> return   ! ! e . body ? . attributes ; <EOL> } </s>
<s> import _ from '<STR_LIT>' ; <EOL> import Color from '<STR_LIT>' ; <EOL> import { <EOL> CoreSetup <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> COLOR_MAPPING_SETTING <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createColorPalette <EOL> } from '<STR_LIT>' ; <EOL> const standardizeColor = ( color ) = > new Color ( color ) . hex ( ) . toLowerCase ( ) ; <EOL> / ** <EOL> * Maintains a lookup table that associates the value ( key ) with a hex color ( value ) <EOL> * across the visualizations . <EOL> * Provides functions to interact with the lookup table <EOL> * / <EOL> export class MappedColors { <EOL> private _oldMap : any ; <EOL> private _mapping : any ; <EOL> constructor ( private uiSettings ) { <EOL> this . _oldMap = { } ; <EOL> this . _mapping = { } ; <EOL> } <EOL> private getConfigColorMapping ( ) { <EOL> return _ . mapValues ( this . uiSettings . get ( COLOR_MAPPING_SETTING ) , standardizeColor ) ; <EOL> } <EOL> public get oldMap ( ) : any { <EOL> return this . _oldMap ; <EOL> } <EOL> public get mapping ( ) : any { <EOL> return this . _mapping ; <EOL> } <EOL> get ( key ) { <EOL> return this . getConfigColorMapping ( ) [ key as any ] | | this . _mapping [ key ] ; <EOL> } <EOL> flush ( ) { <EOL> this . _oldMap = _ . clone ( this . _mapping ) ; <EOL> this . _mapping = { } ; <EOL> } <EOL> purge ( ) { <EOL> this . _oldMap = { } ; <EOL> this . _mapping = { } ; <EOL> } <EOL> mapKeys ( keys ) { <EOL> const configMapping = this . getConfigColorMapping ( ) ; <EOL> const configColors = _ . values ( configMapping ) ; <EOL> const oldColors = _ . values ( this . _oldMap ) ; <EOL> const keysToMap = [ ] ; <EOL> _ . each ( keys , ( key ) = > { <EOL> if ( configMapping [ key as any ] ) delete this . _mapping [ key ] ; <EOL> if ( _ . includes ( configColors , this . _mapping [ key ] ) ) keysToMap . push ( key ) ; <EOL> if ( this . _oldMap [ key ] ) this . _mapping [ key ] = this . _oldMap [ key ] ; <EOL> if ( this . get ( key ) == null ) keysToMap . push ( key ) ; <EOL> } ) ; <EOL> const allColors = _ ( this . _mapping ) . values ( ) . union ( configColors ) . union ( oldColors ) . value ( ) ; <EOL> const colorPalette = createColorPalette ( allColors . length + keysToMap . length ) ; <EOL> let newColors = _ . difference ( colorPalette , allColors ) ; <EOL> while ( keysToMap . length > newColors . length ) { <EOL> newColors = newColors . concat ( _ . sampleSize ( allColors , keysToMap . length - newColors . length ) ) ; <EOL> } <EOL> _ . merge ( this . _mapping , _ . zipObject ( keysToMap , newColors ) ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> GITHUB_CALLBACK_URL , <EOL> GITHUB_CLIENT_ID <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> redirect <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Match <EOL> } from "<STR_LIT>" ; <EOL> export function login ( _req , _match ) { <EOL> const url = new URL ( "<STR_LIT>" ) ; <EOL> url . searchParams . set ( "<STR_LIT>" , GITHUB_CLIENT_ID ) ; <EOL> if ( GITHUB_CALLBACK_URL ) { <EOL> url . searchParams . set ( "<STR_LIT>" , GITHUB_CALLBACK_URL ) ; <EOL> } <EOL> return redirect ( url . toString ( ) ) ; <EOL> } </s>
<s> import React , { <EOL> useEffect <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiCallOut , <EOL> EuiLink <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> useOpenSearchDashboards , <EOL> toMountPoint , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisualizeServices <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisualizeConstants <EOL> } from '<STR_LIT>' ; <EOL> let bannerId ; <EOL> export const VisualizeNoMatch = ( ) = > { <EOL> const { <EOL> services <EOL> } = useOpenSearchDashboards < VisualizeServices > ( ) ; <EOL> useEffect ( ( ) = > { <EOL> services . restorePreviousUrl ( ) ; <EOL> const { <EOL> navigated <EOL> } = services . urlForwarding . navigateToLegacyOpenSearchDashboardsUrl ( services . history . location . pathname ) ; <EOL> if ( ! navigated ) { <EOL> const bannerMessage = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> bannerId = services . overlays . banners . replace ( bannerId , toMountPoint ( < EuiCallOut color = "<STR_LIT>" iconType = "<STR_LIT>" title = { bannerMessage } > < p > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { route : ( < EuiLink href = { window . location . href } > { services . history . location . pathname } < / EuiLink > ) , } } / > < / p > < / EuiCallOut > ) ) ; setTimeout ( ( ) = > { services . overlays . banners . remove ( bannerId ) ; } , <NUM_LIT> ) ; services . history . replace ( VisualizeConstants . LANDING_PAGE_PATH ) ; } } , [ services ] ) ; return null ; } ; </s>
<s> import { <EOL> BreakpointObserver , <EOL> Breakpoints <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OverlayContainer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Router <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Actions , <EOL> Effect , <EOL> ofType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ROUTER_NAVIGATION <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> INIT , <EOL> select , <EOL> Store <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AnimationsService , <EOL> filterWith , <EOL> LocalStorageService <EOL> } from '<STR_LIT>' ; <EOL> import Browser from '<STR_LIT>' ; <EOL> import { <EOL> defer , <EOL> merge , <EOL> Observable , <EOL> of <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> filter , <EOL> map , <EOL> tap , <EOL> withLatestFrom <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> changeAnimationsElements , <EOL> changeAnimationsPage , <EOL> changeAnimationsPageDisabled , <EOL> changeTheme , <EOL> setIsMobile , <EOL> setSidenav , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> State <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getIsMobile , <EOL> getState , <EOL> getTheme <EOL> } from '<STR_LIT>' ; <EOL> export const SETTINGS_KEY = '<STR_LIT>' ; <EOL> @ Injectable ( ) export class Effects { <EOL> isMobile $ : Observable < boolean > = this . store . pipe ( select ( getIsMobile ) ) ; private browser = Browser ( ) ; @ Effect ( ) setIsMobile $ = defer ( ( ) = > this . breakpointObserver . observe ( [ Breakpoints . Small , Breakpoints . XSmall ] ) . pipe ( map ( result = > result . matches ) , map ( isMobile = > setIsMobile ( { <EOL> isMobile <EOL> } ) ) ) ) ; @ Effect ( ) closeSidenavOnNavigationIfMobile $ = this . actions $ . pipe ( ofType ( ROUTER_NAVIGATION ) , filterWith ( this . isMobile $ , ( isMobile ) = > isMobile ) , map ( ( ) = > setSidenav ( { <EOL> showSidenav : false <EOL> } ) ) ) ; @ Effect ( { <EOL> dispatch : false <EOL> } ) persistSettings = this . actions $ . pipe ( ofType ( changeAnimationsElements , changeAnimationsPage , changeAnimationsPageDisabled , changeTheme ) , withLatestFrom ( this . store . pipe ( select ( getState ) ) ) , tap ( ( [ action , settings ] ) = > this . localStorageService . setItem ( SETTINGS_KEY , settings ) ) ) ; @ Effect ( { <EOL> dispatch : false <EOL> } ) updateRouteAnimationType $ = merge ( INIT , this . actions $ . pipe ( ofType ( changeAnimationsElements , changeAnimationsPage , changeAnimationsPageDisabled ) ) ) . pipe ( withLatestFrom ( this . store . pipe ( select ( getState ) ) ) , tap ( ( [ action , settings ] ) = > this . animationsService . updateRouteAnimationType ( settings . pageAnimations , settings . elementsAnimations ) ) ) ; @ Effect ( ) setBrowserAnimations $ = of ( <NUM_LIT> ) . pipe ( filter ( ( ) = > this . isDefectiveBrowser ( ) ) , map ( ( ) = > changeAnimationsPageDisabled ( { <EOL> pageAnimationsDisabled : true <EOL> } ) ) ) ; @ Effect ( { <EOL> dispatch : false <EOL> } ) updateTheme $ = merge ( INIT , this . actions $ . pipe ( ofType ( changeTheme ) ) ) . pipe ( withLatestFrom ( this . store . pipe ( select ( getTheme ) ) ) , tap ( ( [ action , effectiveTheme ] ) = > { <EOL> const classList = this . overlayContainer . getContainerElement ( ) . classList ; <EOL> const toRemove = Array . from ( classList ) . filter ( ( item ) = > item . includes ( '<STR_LIT>' ) ) ; <EOL> if ( toRemove . length ) { <EOL> classList . remove ( ... toRemove ) ; <EOL> } <EOL> classList . add ( effectiveTheme ) ; <EOL> } ) ) ; constructor ( private actions $ , private store , private breakpointObserver , private router , private overlayContainer , private animationsService , private localStorageService ) { } <EOL> private isDefectiveBrowser ( ) { <EOL> return [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] . includes ( this . browser . name ) ; <EOL> } <EOL> } </s>
<s> import uniqBy from "<STR_LIT>" ; <EOL> import { <EOL> LIST_SCHEDULER_ENQUEUE_EVENTS_BEGIN , <EOL> LIST_SCHEDULER_ENQUEUE_EVENTS_ERROR , <EOL> LIST_SCHEDULER_ENQUEUE_EVENTS_SUCCESS , <EOL> LIST_SCHEDULER_ENTRIES_BEGIN , <EOL> LIST_SCHEDULER_ENTRIES_ERROR , <EOL> LIST_SCHEDULER_ENTRIES_SUCCESS , <EOL> SchedulerEntriesActionTypes , <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> SchedulerEnqueueEvent , <EOL> SchedulerEntry <EOL> } from "<STR_LIT>" ; <EOL> interface SchedulerEntriesState { <EOL> loading : boolean ; data : SchedulerEntry [ ] ; error : string ; enqueueEventsByEntryId : { <EOL> [ entryId ] : { <EOL> data : SchedulerEnqueueEvent [ ] ; loading : boolean ; <EOL> } ; <EOL> } ; <EOL> } <EOL> export function getEnqueueEventsEntry ( state , entryId ) { <EOL> return state . enqueueEventsByEntryId [ entryId ] | | { <EOL> data : [ ] , <EOL> loading : false <EOL> } ; <EOL> } <EOL> const initialState = { <EOL> loading : false , <EOL> data : [ ] , <EOL> error : "<STR_LIT>" , <EOL> enqueueEventsByEntryId : { } , <EOL> } ; <EOL> function schedulerEntriesReducer ( state = initialState , action ) { <EOL> switch ( action . type ) { <EOL> case LIST_SCHEDULER_ENTRIES_BEGIN : <EOL> return { <EOL> ... state , loading : true , <EOL> } ; <EOL> case LIST_SCHEDULER_ENTRIES_SUCCESS : <EOL> return { <EOL> ... state , error : "<STR_LIT>" , loading : false , data : action . payload . entries , <EOL> } ; <EOL> case LIST_SCHEDULER_ENTRIES_ERROR : <EOL> return { <EOL> ... state , loading : false , error : action . error , <EOL> } ; <EOL> case LIST_SCHEDULER_ENQUEUE_EVENTS_BEGIN : { <EOL> const entry = getEnqueueEventsEntry ( state , action . entryId ) ; <EOL> return { <EOL> ... state , <EOL> enqueueEventsByEntryId : { <EOL> ... state . enqueueEventsByEntryId , <EOL> [ action . entryId ] : { <EOL> ... entry , <EOL> loading : true , <EOL> } , <EOL> } , <EOL> } ; <EOL> } <EOL> case LIST_SCHEDULER_ENQUEUE_EVENTS_SUCCESS : { <EOL> const sortByEnqueuedAt = ( e1 , e2 ) : number = > { <EOL> return Date . parse ( e2 . enqueued_at ) - Date . parse ( e1 . enqueued_at ) ; <EOL> } ; <EOL> const entry = getEnqueueEventsEntry ( state , action . entryId ) ; <EOL> const newData = uniqBy ( [ ... entry . data , ... action . payload . events ] , "<STR_LIT>" ) . sort ( sortByEnqueuedAt ) ; <EOL> return { <EOL> ... state , <EOL> enqueueEventsByEntryId : { <EOL> ... state . enqueueEventsByEntryId , <EOL> [ action . entryId ] : { <EOL> loading : false , <EOL> data : newData , <EOL> } , <EOL> } , <EOL> } ; <EOL> } <EOL> case LIST_SCHEDULER_ENQUEUE_EVENTS_ERROR : { <EOL> const entry = getEnqueueEventsEntry ( state , action . entryId ) ; <EOL> return { <EOL> ... state , <EOL> enqueueEventsByEntryId : { <EOL> ... state . enqueueEventsByEntryId , <EOL> [ action . entryId ] : { <EOL> ... entry , <EOL> loading : false , <EOL> } , <EOL> } , <EOL> } ; <EOL> } <EOL> default : <EOL> return state ; <EOL> } <EOL> } <EOL> export default schedulerEntriesReducer ; </s>
<s> import { <EOL> TimeRange , <EOL> Filter , <EOL> Query , <EOL> opensearchFilters , <EOL> QueryState , <EOL> RefreshInterval , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> setStateToOsdUrl <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UrlGeneratorsDefinition <EOL> } from '<STR_LIT>' ; <EOL> export const DISCOVER_APP_URL_GENERATOR = '<STR_LIT>' ; <EOL> export interface DiscoverUrlGeneratorState { <EOL> / ** <EOL> * Optionally set saved search ID . <EOL> * / <EOL> savedSearchId   ? : string ; <EOL> / ** <EOL> * Optionally set index pattern ID . <EOL> * / <EOL> indexPatternId   ? : string ; <EOL> / ** <EOL> * Optionally set the time range in the time picker . <EOL> * / <EOL> timeRange   ? : TimeRange ; <EOL> / ** <EOL> * Optionally set the refresh interval . <EOL> * / <EOL> refreshInterval   ? : RefreshInterval ; <EOL> / ** <EOL> * Optionally apply filers . <EOL> * / <EOL> filters   ? : Filter [ ] ; <EOL> / ** <EOL> * Optionally set a query . NOTE : if given and used in conjunction with   ` dashboardId ` , and the <EOL> * saved dashboard has a query saved with it , this will _replace_ that query . <EOL> * / <EOL> query   ? : Query ; <EOL> / ** <EOL> * If not given , will use the uiSettings configuration for   ` storeInSessionStorage ` . useHash determines <EOL> * whether to hash the data in the url to avoid url length issues . <EOL> * / <EOL> useHash   ? : boolean ; <EOL> } <EOL> interface Params { <EOL> appBasePath : string ; useHash : boolean ; <EOL> } <EOL> export class DiscoverUrlGenerator implements UrlGeneratorsDefinition < typeof DISCOVER_APP_URL_GENERATOR > { <EOL> constructor ( private readonly params ) { } <EOL> public readonly id = DISCOVER_APP_URL_GENERATOR ; public readonly createUrl = async ( { <EOL> filters , <EOL> indexPatternId , <EOL> query , <EOL> refreshInterval , <EOL> savedSearchId , <EOL> timeRange , <EOL> useHash = this . params . useHash , <EOL> } ) : Promise < string > = > { <EOL> const savedSearchPath = savedSearchId   ? encodeURIComponent ( savedSearchId ) : '<STR_LIT>' ; <EOL> const appState = { } ; <EOL> const queryState = { } ; <EOL> if ( query ) appState . query = query ; <EOL> if ( filters & & filters . length ) appState . filters = filters ? . filter ( ( f ) = >   ! opensearchFilters . isFilterPinned ( f ) ) ; <EOL> if ( indexPatternId ) appState . index = indexPatternId ; <EOL> if ( timeRange ) queryState . time = timeRange ; <EOL> if ( filters & & filters . length ) queryState . filters = filters ? . filter ( ( f ) = > opensearchFilters . isFilterPinned ( f ) ) ; <EOL> if ( refreshInterval ) queryState . refreshInterval = refreshInterval ; <EOL> let url =   ` $ { this . params . appBasePath } <EOL> url = setStateToOsdUrl < QueryState > ( '<STR_LIT>' , queryState , { <EOL> useHash <EOL> } , url ) ; <EOL> url = setStateToOsdUrl ( '<STR_LIT>' , appState , { <EOL> useHash <EOL> } , url ) ; <EOL> return url ; <EOL> } ; <EOL> } </s>
<s> import * as path from '<STR_LIT>' ; <EOL> import chokidar , { <EOL> FSWatcher <EOL> } from '<STR_LIT>' ; <EOL> import slash from '<STR_LIT>' ; <EOL> import { <EOL> ModuleListener , <EOL> VirtuleModuleAPIs , <EOL> VirtualModuleGraph , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PendingTaskCounter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> File <EOL> } from '<STR_LIT>' ; <EOL> let nextWatcherId = <NUM_LIT> ; <EOL> / ** <EOL> * watch fs and update corresponding virtule module when a file changed <EOL> * / <EOL> export class VirtualModulesManager { <EOL> private watchers = new Set < FSWatcher > ( ) ; <EOL> private virtuleModules = new VirtualModuleGraph ( ) ; <EOL> private fileCache : { <EOL> [ path ] : File ; <EOL> } = { } ; <EOL> / ** <EOL> * don ' t return half - finished data when there are pending tasks <EOL> * / <EOL> private pendingTaskCounter = new PendingTaskCounter ( ) ; <EOL> constructor ( ) { <EOL> this . pendingTaskCounter . countPendingState ( this . virtuleModules . updateExecutingState ) ; <EOL> this . pendingTaskCounter . countPendingState ( this . virtuleModules . updateQueueEmptyState ) ; <EOL> } <EOL> public addFSWatcher ( baseDir , globs , fileHandler ) { <EOL> const watcherId = String ( nextWatcherId + + ) ; <EOL> const fsScanFinish = this . pendingTaskCounter . countTask ( ) ; <EOL> this . watchers . add ( chokidar . watch ( globs , { <EOL> cwd : baseDir , <EOL> ignored : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> } ) . on ( '<STR_LIT>' , this . handleFileChange ( baseDir , fileHandler , watcherId ) ) . on ( '<STR_LIT>' , this . handleFileChange ( baseDir , fileHandler , watcherId ) ) . on ( '<STR_LIT>' , this . handleFileUnLink ( baseDir , watcherId ) ) . on ( '<STR_LIT>' , ( ) = > { <EOL> setTimeout ( ( ) = > { <EOL> fsScanFinish ( ) ; <EOL> } , <NUM_LIT> ) ; <EOL> } ) ) ; <EOL> } <EOL> public getModules ( cb , filter   ? ) { <EOL> this . callOnceWhenIdle ( ( ) = > { <EOL> cb ( this . virtuleModules . getModules ( filter ) ) ; <EOL> } ) ; <EOL> } <EOL> public getModule ( moduleId , cb ) { <EOL> this . callOnceWhenIdle ( ( ) = > { <EOL> cb ( this . virtuleModules . getModuleData ( moduleId ) ) ; <EOL> } ) ; <EOL> } <EOL> / ** <EOL> * Idle means : <EOL> * fs watcher is ready <EOL> * no update is executing <EOL> * update queue is empty <EOL> * / <EOL> public callOnceWhenIdle ( cb ) { <EOL> this . pendingTaskCounter . callOnceWhenIdle ( cb ) ; <EOL> } <EOL> / ** <EOL> * return the current state of modules . <EOL> * it doesn ' t wait for update task to finish <EOL> * so it may see intermediate state . <EOL> * use it carefully . <EOL> * / <EOL> public _getModulesNow ( filter   ? ) { <EOL> return this . virtuleModules . getModules ( filter ) ; <EOL> } <EOL> / ** <EOL> * return the current state of module . <EOL> * it doesn ' t wait for update task to finish <EOL> * so it may see intermediate state . <EOL> * use it carefully . <EOL> * / <EOL> public _getModuleDataNow ( moduleId ) { <EOL> return this . virtuleModules . getModuleData ( moduleId ) ; <EOL> } <EOL> public addModuleListener ( handler , filter   ? ) { <EOL> return this . virtuleModules . addModuleListener ( handler , filter ) ; <EOL> } <EOL> public close ( ) { <EOL> this . watchers . forEach ( ( w ) = > w . close ( ) ) ; <EOL> } <EOL> public scheduleUpdate ( updaterId , updater ) { <EOL> return this . virtuleModules . scheduleUpdate ( updaterId , updater ) ; <EOL> } <EOL> private handleFileChange ( baseDir , fileHandler , watcherId ) { <EOL> return ( filePath ) = > { <EOL> filePath = slash ( path . join ( baseDir , filePath ) ) ; <EOL> const file = this . fileCache [ filePath ] | | ( this . fileCache [ filePath ] = new File ( filePath , baseDir ) ) ; <EOL> file . content = null ; <EOL> file . read ( ) ; <EOL> this . virtuleModules . scheduleUpdate ( ` $ { watcherId } - $ { filePath } ` , async ( apis ) = > { <EOL> const handlerAPI = { <EOL> addModuleData ( moduleId , data ) { <EOL> apis . addModuleData ( moduleId , data , filePath ) ; <EOL> } , <EOL> getModuleData : apis . getModuleData , <EOL> } ; <EOL> await fileHandler ( file , handlerAPI ) ; <EOL> } ) ; <EOL> } ; <EOL> } <EOL> private handleFileUnLink ( baseDir , watcherId ) { <EOL> return ( filePath ) = > { <EOL> filePath = slash ( path . join ( baseDir , filePath ) ) ; <EOL> this . virtuleModules . scheduleUpdate ( ` $ { watcherId } - $ { filePath } - unlink ` , async ( apis ) = > { <EOL> apis . deleteModule ( filePath ) ; <EOL> } ) ; <EOL> } ; <EOL> } <EOL> } <EOL> type FileHandler = ( file : File , api : FileHandlerAPIs ) = > void | Promise < void > ; <EOL> export interface FileHandlerAPIs { <EOL> addModuleData ( moduleId , data ) : void ; <EOL> getModuleData ( moduleId ) : any [ ] ; <EOL> } </s>
<s> import * as React from "<STR_LIT>" ; <EOL> import { <EOL> FunctionComponent <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> css <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> globalColors <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> RoomChat <EOL> } from "<STR_LIT>" ; <EOL> interface Props { <EOL> chat : RoomChat ; <EOL> } <EOL> const ChatMessage = ( { <EOL> chat <EOL> } ) = > ( < div css = { chat . isMine   ? [ wrapperStyle , mineStyle ] : wrapperStyle } > < div css = { headStyle } > { chat . from } at { new Date ( chat . time ) . toLocaleTimeString ( ) } < / div > { chat . text } < / div > ) ; export default ChatMessage ; const wrapperStyle = css ( { boxSizing : "<STR_LIT>" , width : "<STR_LIT>" , padding : "<STR_LIT>" , marginTop : <NUM_LIT> , marginBottom : <NUM_LIT> , wordBreak : "<STR_LIT>" , borderRadius : <NUM_LIT> , border :   ` <NUM_LIT> px solid   $ { globalColors . gray } ` , } ) ; const mineStyle = css ( { marginLeft : "<STR_LIT>" , backgroundColor : globalColors . gray , } ) ; const headStyle = css ( { fontSize : "<STR_LIT>" , } ) ; </s>
<s> import React , { <EOL> useRef , <EOL> useEffect <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DocViewRenderFn , <EOL> DocViewRenderProps <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> render : DocViewRenderFn ; renderProps : DocViewRenderProps ; <EOL> } <EOL> / ** <EOL> * Responsible for rendering a tab provided by a render function . <EOL> * So any other framework can be used ( E . g . legacy Angular <NUM_LIT> rd party plugin code ) <EOL> * The provided   ` render ` function is called with a reference to the <EOL> * component ' s   ` HTMLDivElement ` as <NUM_LIT> st arg and   ` renderProps ` as <NUM_LIT> nd arg <EOL> * / <EOL> export function DocViewRenderTab ( { <EOL> render , <EOL> renderProps <EOL> } ) { <EOL> const ref = useRef < HTMLDivElement > ( null ) ; <EOL> useEffect ( ( ) = > { <EOL> if ( ref & & ref . current ) { <EOL> return render ( ref . current , renderProps ) ; <EOL> } <EOL> } , [ render , renderProps ] ) ; <EOL> return < div ref = { ref } / > ; <EOL> } </s>
<s> import React , { <EOL> ReactNode , <EOL> Suspense <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiLoadingChart <EOL> } from '<STR_LIT>' ; <EOL> import classNames from '<STR_LIT>' ; <EOL> import { <EOL> VisualizationNoResults <EOL> } from '<STR_LIT>' ; <EOL> interface VisualizationContainerProps { <EOL> className   ? : string ; <EOL> children : ReactNode ; <EOL> showNoResult   ? : boolean ; <EOL> } <EOL> export const VisualizationContainer = ( { <EOL> className , <EOL> children , <EOL> showNoResult = false , <EOL> } ) = > { <EOL> const classes = classNames ( '<STR_LIT>' , className ) ; <EOL> const fallBack = ( < div className = "<STR_LIT>" > < EuiLoadingChart mono size = "<STR_LIT>" / > < / div > ) ; return ( < div className = { classes } > < Suspense fallback = { fallBack } > { showNoResult   ? < VisualizationNoResults / > : children } < / Suspense > < / div > ) ; } ; </s>
<s> import React , { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> I18nProvider <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiContextMenu , <EOL> EuiContextMenuPanelDescriptor <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> HttpStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> UrlPanelContent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ShareMenuItem , <EOL> ShareContextMenuPanelItem , <EOL> UrlParamExtension <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> allowEmbed : boolean ; allowShortUrl : boolean ; objectId   ? : string ; objectType : string ; shareableUrl   ? : string ; shareMenuItems : ShareMenuItem [ ] ; sharingData : any ; onClose : ( ) = > void ; basePath : string ; post : HttpStart [ '<STR_LIT>' ] ; embedUrlParamExtensions   ? : UrlParamExtension [ ] ; <EOL> } <EOL> export class ShareContextMenu extends Component < Props > { <EOL> public render ( ) { <EOL> const { <EOL> panels , <EOL> initialPanelId <EOL> } = this . getPanels ( ) ; <EOL> return ( < I18nProvider > < EuiContextMenu initialPanelId = { initialPanelId } panels = { panels } data - test - subj = "<STR_LIT>" / > < / I18nProvider > ) ; } private getPanels = ( ) = > { const panels = [ ] ; const menuItems = [ ] ; const permalinkPanel = { id : panels . length + <NUM_LIT> , title : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , content : ( < UrlPanelContent allowShortUrl = { this . props . allowShortUrl } objectId = { this . props . objectId } objectType = { this . props . objectType } basePath = { this . props . basePath } post = { this . props . post } shareableUrl = { this . props . shareableUrl } / > ) , } ; menuItems . push ( { name : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , icon : '<STR_LIT>' , panel : permalinkPanel . id , sortOrder : <NUM_LIT> , } ) ; panels . push ( permalinkPanel ) ; if ( this . props . allowEmbed ) { const embedPanel = { id : panels . length + <NUM_LIT> , title : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , content : ( < UrlPanelContent allowShortUrl = { this . props . allowShortUrl } isEmbedded objectId = { this . props . objectId } objectType = { this . props . objectType } basePath = { this . props . basePath } post = { this . props . post } shareableUrl = { this . props . shareableUrl } urlParamExtensions = { this . props . embedUrlParamExtensions } / > ) , } ; panels . push ( embedPanel ) ; menuItems . push ( { name : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , icon : '<STR_LIT>' , panel : embedPanel . id , sortOrder : <NUM_LIT> , } ) ; } this . props . shareMenuItems . forEach ( ( { shareMenuItem , panel } ) = > { const panelId = panels . length + <NUM_LIT> ; panels . push ( { ... panel , id : panelId , } ) ; menuItems . push ( { ... shareMenuItem , panel : panelId , } ) ; } ) ; if ( menuItems . length > <NUM_LIT> ) { const topLevelMenuPanel = { id : panels . length + <NUM_LIT> , title : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , values : { objectType : this . props . objectType , } , } ) , items : menuItems . sort ( ( a , b ) = > { const aSortOrder = a . sortOrder | | <NUM_LIT> ; const bSortOrder = b . sortOrder | | <NUM_LIT> ; if ( aSortOrder > bSortOrder ) { return <NUM_LIT> ; } if ( aSortOrder < bSortOrder ) { return - <NUM_LIT> ; } if ( a . name . toLowerCase ( ) . localeCompare ( b . name . toLowerCase ( ) ) > <NUM_LIT> ) { return <NUM_LIT> ; } return - <NUM_LIT> ; } ) . map ( ( menuItem ) = > { menuItem [ '<STR_LIT>' ] =   ` sharePanel - $ { menuItem . name . replace ( '<STR_LIT>' , '<STR_LIT>' ) } ` ; delete menuItem . sortOrder ; return menuItem ; } ) , } ; panels . push ( topLevelMenuPanel ) ; } const lastPanelIndex = panels . length - <NUM_LIT> ; const initialPanelId = panels [ lastPanelIndex ] . id ; return { panels , initialPanelId } ; } ; } </s>
<s> import { <EOL> update <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Action , <EOL> createAction <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Reducer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ActionCreator <EOL> } from '<STR_LIT>' ; <EOL> export interface IReducerAndAction < P > { <EOL> reducer : Reducer < { } > ; action : ActionCreator ; <EOL> } <EOL> export const makeScope = ( namespacing , excludeField   ? ) = > < LocalState , P > ( type , fn ) : IReducerAndAction < P > = > { const reducer = ( state , action ) = > { const keyPath = excludeField   ? namespacing . slice ( <NUM_LIT> , - <NUM_LIT> ) : namespacing . slice ( <NUM_LIT> ) ; const nextState = { ... state } ; if ( keyPath . length ) { return update ( nextState , keyPath . join ( '<STR_LIT>' ) , ( scopedState ) = > fn ( scopedState , action ) ) ; } return fn ( state as any , action ) ; } ; return { reducer , action : createAction ( type ) , } ; } ; </s>
<s> import { <EOL> EuiButtonEmpty , <EOL> EuiForm , <EOL> EuiFormRow , <EOL> EuiLink , <EOL> EuiPopover , <EOL> EuiPopoverTitle , <EOL> EuiSpacer , <EOL> EuiSwitch , <EOL> EuiText , <EOL> PopoverAnchorPosition , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import React , { <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> useOpenSearchDashboards <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> language : string ; onSelectLanguage : ( newLanguage : string ) = > void ; anchorPosition   ? : PopoverAnchorPosition ; <EOL> } <EOL> export function QueryLanguageSwitcher ( props ) { <EOL> const osdDQLDocs = useOpenSearchDashboards ( ) . services . docLinks ? . links . opensearchDashboards . dql . base ; <EOL> const [ isPopoverOpen , setIsPopoverOpen ] = useState ( false ) ; <EOL> const luceneLabel = ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) ; <EOL> const dqlLabel = ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) ; <EOL> const dqlFullName = ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) ; <EOL> const button = ( < EuiButtonEmpty size = "<STR_LIT>" onClick = { ( ) = > setIsPopoverOpen (   ! isPopoverOpen ) } className = "<STR_LIT>" data - test - subj = { '<STR_LIT>' } > { props . language == = '<STR_LIT>'   ? luceneLabel : dqlLabel } < / EuiButtonEmpty > ) ; return ( < EuiPopover id = "<STR_LIT>" anchorClassName = "<STR_LIT>" ownFocus anchorPosition = { props . anchorPosition | | '<STR_LIT>' } button = { button } isOpen = { isPopoverOpen } closePopover = { ( ) = > setIsPopoverOpen ( false ) } withTitle repositionOnScroll > < EuiPopoverTitle > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiPopoverTitle > < div style = { { width : '<STR_LIT>' } } > < EuiText > < p > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { docsLink : ( < EuiLink href = { osdDQLDocs } target = "<STR_LIT>" > { dqlFullName } < / EuiLink > ) , } } / > < / p > < / EuiText > < EuiSpacer size = "<STR_LIT>" / > < EuiForm > < EuiFormRow label = { dqlFullName } > < EuiSwitch id = "<STR_LIT>" name = "<STR_LIT>" label = { props . language == = '<STR_LIT>'   ? ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) : ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > ) } checked = { props . language == = '<STR_LIT>' } onChange = { ( ) = > { const newLanguage = props . language == = '<STR_LIT>'   ? '<STR_LIT>' : '<STR_LIT>' ; props . onSelectLanguage ( newLanguage ) ; } } data - test - subj = "<STR_LIT>" / > < / EuiFormRow > < / EuiForm > < / div > < / EuiPopover > ) ; } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> truncate <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldFormat <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TextContextTypeConvert , <EOL> FIELD_FORMAT_IDS <EOL> } from '<STR_LIT>' ; <EOL> const omission = '<STR_LIT>' ; <EOL> export class TruncateFormat extends FieldFormat { <EOL> static id = FIELD_FORMAT_IDS . TRUNCATE ; <EOL> static title = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> static fieldType = OSD_FIELD_TYPES . STRING ; <EOL> textConvert : TextContextTypeConvert = ( val ) = > { <EOL> const length = this . param ( '<STR_LIT>' ) ; <EOL> if ( length > <NUM_LIT> ) { <EOL> return truncate ( val , { <EOL> length : length + omission . length , <EOL> omission , <EOL> } ) ; <EOL> } <EOL> return val ; <EOL> } ; <EOL> } </s>
<s> import { <EOL> Subscription <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> filter , <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> import _ from '<STR_LIT>' ; <EOL> import { <EOL> BaseStateContainer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> QuerySetup , <EOL> QueryStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> QueryState , <EOL> QueryStateChange <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FilterStateStore , <EOL> COMPARE_ALL_OPTIONS , <EOL> compareFilters <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> validateTimeRange <EOL> } from '<STR_LIT>' ; <EOL> param QueryService param stateContainer <EOL> export const connectToQueryState = < S extends QueryState > ( { timefilter : { timefilter } , filterManager , queryString , state $ , } , stateContainer , syncConfig ) = > { const syncKeys = [ ] ; if ( syncConfig . time ) { syncKeys . push ( '<STR_LIT>' ) ; } if ( syncConfig . query ) { syncKeys . push ( '<STR_LIT>' ) ; } if ( syncConfig . refreshInterval ) { syncKeys . push ( '<STR_LIT>' ) ; } if ( syncConfig . filters ) { switch ( syncConfig . filters ) { case true : syncKeys . push ( '<STR_LIT>' ) ; break ; case FilterStateStore . APP_STATE : syncKeys . push ( '<STR_LIT>' ) ; break ; case FilterStateStore . GLOBAL_STATE : syncKeys . push ( '<STR_LIT>' ) ; break ; } } const initialState = { ... stateContainer . get ( ) } ; let initialDirty = false ; if ( syncConfig . time & &   ! _ . isEqual ( initialState . time , timefilter . getTime ( ) ) ) { initialState . time = timefilter . getTime ( ) ; initialDirty = true ; } if ( syncConfig . refreshInterval & &   ! _ . isEqual ( initialState . refreshInterval , timefilter . getRefreshInterval ( ) ) ) { initialState . refreshInterval = timefilter . getRefreshInterval ( ) ; initialDirty = true ; } if ( syncConfig . filters ) { if ( syncConfig . filters == = true ) { if (   ! initialState . filters | |   ! compareFilters ( initialState . filters , filterManager . getFilters ( ) , COMPARE_ALL_OPTIONS ) ) { initialState . filters = filterManager . getFilters ( ) ; initialDirty = true ; } } else if ( syncConfig . filters == = FilterStateStore . GLOBAL_STATE ) { if (   ! initialState . filters | |   ! compareFilters ( initialState . filters , filterManager . getGlobalFilters ( ) , { ... COMPARE_ALL_OPTIONS , state : false , } ) ) { initialState . filters = filterManager . getGlobalFilters ( ) ; initialDirty = true ; } } else if ( syncConfig . filters == = FilterStateStore . APP_STATE ) { if (   ! initialState . filters | |   ! compareFilters ( initialState . filters , filterManager . getAppFilters ( ) , { ... COMPARE_ALL_OPTIONS , state : false , } ) ) { initialState . filters = filterManager . getAppFilters ( ) ; initialDirty = true ; } } } if ( initialDirty ) { stateContainer . set ( { ... stateContainer . get ( ) , ... initialState } ) ; } let updateInProgress = false ; const subs = [ state $ . pipe ( filter ( ( { changes , state } ) = > { if ( updateInProgress ) return false ; return syncKeys . some ( ( syncKey ) = > changes [ syncKey ] ) ; } ) , map ( ( { changes } ) = > { const newState = { } ; if ( syncConfig . time & & changes . time ) { newState . time = timefilter . getTime ( ) ; } if ( syncConfig . query & & changes . query ) { newState . query = queryString . getQuery ( ) ; } if ( syncConfig . refreshInterval & & changes . refreshInterval ) { newState . refreshInterval = timefilter . getRefreshInterval ( ) ; } if ( syncConfig . filters ) { if ( syncConfig . filters == = true & & changes . filters ) { newState . filters = filterManager . getFilters ( ) ; } else if ( syncConfig . filters == = FilterStateStore . GLOBAL_STATE & & changes . globalFilters ) { newState . filters = filterManager . getGlobalFilters ( ) ; } else if ( syncConfig . filters == = FilterStateStore . APP_STATE & & changes . appFilters ) { newState . filters = filterManager . getAppFilters ( ) ; } } return newState ; } ) ) . subscribe ( ( newState ) = > { stateContainer . set ( { ... stateContainer . get ( ) , ... newState } ) ; } ) , stateContainer . state $ . subscribe ( ( state ) = > { updateInProgress = true ; if ( syncConfig . time ) { const time = validateTimeRange ( state . time )   ? state . time : timefilter . getTimeDefaults ( ) ; if (   ! _ . isEqual ( time , timefilter . getTime ( ) ) ) { timefilter . setTime ( _ . cloneDeep ( time   ! ) ) ; } } if ( syncConfig . refreshInterval ) { const refreshInterval = state . refreshInterval | | timefilter . getRefreshIntervalDefaults ( ) ; if (   ! _ . isEqual ( refreshInterval , timefilter . getRefreshInterval ( ) ) ) { timefilter . setRefreshInterval ( _ . cloneDeep ( refreshInterval ) ) ; } } if ( syncConfig . query ) { const curQuery = state . query | | queryString . getQuery ( ) ; if (   ! _ . isEqual ( curQuery , queryString . getQuery ( ) ) ) { queryString . setQuery ( _ . cloneDeep ( curQuery ) ) ; } } if ( syncConfig . filters ) { const filters = state . filters | | [ ] ; if ( syncConfig . filters == = true ) { if (   ! compareFilters ( filters , filterManager . getFilters ( ) , COMPARE_ALL_OPTIONS ) ) { filterManager . setFilters ( _ . cloneDeep ( filters ) ) ; } } else if ( syncConfig . filters == = FilterStateStore . APP_STATE ) { if (   ! compareFilters ( filters , filterManager . getAppFilters ( ) , { ... COMPARE_ALL_OPTIONS , state : false , } ) ) { filterManager . setAppFilters ( _ . cloneDeep ( filters ) ) ; } } else if ( syncConfig . filters == = FilterStateStore . GLOBAL_STATE ) { if (   ! compareFilters ( filters , filterManager . getGlobalFilters ( ) , { ... COMPARE_ALL_OPTIONS , state : false , } ) ) { filterManager . setGlobalFilters ( _ . cloneDeep ( filters ) ) ; } } } updateInProgress = false ; } ) , ] ; return ( ) = > { subs . forEach ( ( s ) = > s . unsubscribe ( ) ) ; } ; } ; </s>
<s> param text returns { <EOL> string <EOL> } <EOL> export function toUser ( text ) { <EOL> if ( text == null ) { <EOL> return '<STR_LIT>' ; <EOL> } <EOL> if ( typeof text == = '<STR_LIT>' ) { <EOL> if ( text . query_string ) { <EOL> return toUser ( text . query_string . query ) ; <EOL> } <EOL> return JSON . stringify ( text ) ; <EOL> } <EOL> return '<STR_LIT>' + text ; <EOL> } </s>
<s> import { <EOL> set <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedData <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TabbedTable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormatFactory <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> createFilter <EOL> } from '<STR_LIT>' ; <EOL> deprecated todo <EOL> export async function buildTabularInspectorData ( table , { <EOL> queryFilter , <EOL> deserializeFieldFormat , <EOL> } ) { <EOL> const aggConfigs = table . columns . map ( ( column ) = > column . aggConfig ) ; <EOL> const rows = table . rows . map ( ( row ) = > { <EOL> return table . columns . reduce < Record < string , FormattedData > > ( ( prev , cur , colIndex ) = > { <EOL> const value = row [ cur . id ] ; <EOL> let format = cur . aggConfig . toSerializedFieldFormat ( ) ; <EOL> if ( Object . keys ( format ) . length < <NUM_LIT> ) { <EOL> format = { <EOL> id : '<STR_LIT>' <EOL> } ; <EOL> } <EOL> const fieldFormatter = deserializeFieldFormat ( format ) ; <EOL> prev [ ` col - $ { colIndex } - $ { cur . aggConfig . id } ` ] = new FormattedData ( value , fieldFormatter . convert ( value ) ) ; <EOL> return prev ; <EOL> } , { } ) ; <EOL> } ) ; <EOL> const columns = table . columns . map ( ( col , colIndex ) = > { <EOL> const field = col . aggConfig . getField ( ) ; <EOL> const isCellContentFilterable = col . aggConfig . isFilterable ( ) & & ( ! field | | field . filterable ) ; <EOL> return { <EOL> name : col . name , <EOL> field :   ` col - $ { colIndex } - $ { col . aggConfig . id } ` , <EOL> filter : isCellContentFilterable & & ( ( value ) = > { <EOL> const rowIndex = rows . findIndex ( ( row ) = > row [ ` col - $ { colIndex } - $ { col . aggConfig . id } ` ] . raw == = value . raw ) ; <EOL> const filter = createFilter ( aggConfigs , table , colIndex , rowIndex , value . raw ) ; <EOL> if ( filter ) { <EOL> queryFilter . addFilters ( filter ) ; <EOL> } <EOL> } ) , <EOL> filterOut : isCellContentFilterable & & ( ( value ) = > { <EOL> const rowIndex = rows . findIndex ( ( row ) = > row [ ` col - $ { colIndex } - $ { col . aggConfig . id } ` ] . raw == = value . raw ) ; <EOL> const filter = createFilter ( aggConfigs , table , colIndex , rowIndex , value . raw ) ; <EOL> if ( filter ) { <EOL> const notOther = value . raw != = '<STR_LIT>' ; <EOL> const notMissing = value . raw != = '<STR_LIT>' ; <EOL> if ( Array . isArray ( filter ) ) { <EOL> filter . forEach ( ( f ) = > set ( f , '<STR_LIT>' , notOther & & notMissing ) ) ; <EOL> } else { <EOL> set ( filter , '<STR_LIT>' , notOther & & notMissing ) ; <EOL> } <EOL> queryFilter . addFilters ( filter ) ; <EOL> } <EOL> } ) , <EOL> } ; <EOL> } ) ; <EOL> return { <EOL> columns , <EOL> rows <EOL> } ; <EOL> } </s>
<s> import { <EOL> onConnected , <EOL> IBKRConnection <EOL> } from '<STR_LIT>' ; <EOL> interface IBKR { <EOL> host : string ; port : number ; <EOL> } <EOL> const ibkr = ( args   ? ) : Promise < boolean > = > { <EOL> const { <EOL> IB_PORT = <NUM_LIT> , IB_HOST = '<STR_LIT>' <EOL> } = process . env | | { } ; <EOL> const { <EOL> host = IB_HOST , port = IB_PORT <EOL> } = args | | { } ; <EOL> IBKRConnection . Instance . init ( host , + port ) ; <EOL> return new Promise ( ( resolve , reject ) = > { <EOL> async function runIbkrApp ( ) { <EOL> const connection = await onConnected ( ) ; <EOL> if ( connection ) { <EOL> return resolve ( true ) ; <EOL> } <EOL> reject ( '<STR_LIT>' ) ; <EOL> } <EOL> runIbkrApp ( ) ; <EOL> } ) ; <EOL> } ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export * from '<STR_LIT>' ; <EOL> export default ibkr ; </s>
<s> import { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TimelineFacade <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> combineLatest , <EOL> Observable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GetPrTimelinePayload , <EOL> Timeline , <EOL> TimelineChartRange , <EOL> TimelineProperties , <EOL> TimelineRecord , <EOL> TimelineSettings , <EOL> TimelineTotalStats <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ActivatedRoute , <EOL> Router <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PrTimelineStateType <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] <EOL> } ) export class PrTimelineComponent { <EOL> timelineState $ : Observable < PrTimelineStateType > ; records $ : Observable < TimelineRecord [ ] > ; timelineTotalStats $ : Observable < TimelineTotalStats > ; repositoryId : string ; constructor ( private timelineFacade , private activatedRoute ) { <EOL> this . records $ = timelineFacade . timelineRecords $ ; <EOL> this . timelineTotalStats $ = timelineFacade . getTotalStats ( { <EOL> fromDate : null , <EOL> toDate : null <EOL> } ) ; <EOL> this . timelineState $ = combineLatest ( [ timelineFacade . timelineError $ , timelineFacade . timelineLoading $ , timelineFacade . timelineProperties $ ] ) . pipe ( map ( ( [ error , loading , props ] ) : PrTimelineStateType = > { <EOL> if ( props ) return '<STR_LIT>' ; <EOL> else if ( error ) return '<STR_LIT>' ; <EOL> else if ( loading ) return '<STR_LIT>' ; <EOL> else return '<STR_LIT>' ; <EOL> } ) ) ; <EOL> this . activatedRoute . paramMap . pipe ( map ( params = > params . get ( '<STR_LIT>' ) ) ) . subscribe ( id = > ( this . repositoryId = id ) ) ; <EOL> } <EOL> handleTimelineRangeUpdated ( range ) { <EOL> this . timelineTotalStats $ = this . timelineFacade . getTotalStats ( range ) ; <EOL> } <EOL> handleSettingsUpdated ( settings ) { <EOL> const query = { <EOL> repositoryId : this . repositoryId , <EOL> ... settings <EOL> } ; <EOL> this . timelineFacade . getTimeline ( query ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> IMaterial <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> IGLTFExporterExtensionV2 <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> _Exporter <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Material <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PBRMaterial <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> StandardMaterial <EOL> } from '<STR_LIT>' ; <EOL> const NAME = "<STR_LIT>" ; <EOL> hidden <EOL> export class KHR_materials_unlit implements IGLTFExporterExtensionV2 { <EOL> / ** Name of this extension * / <EOL> public readonly name = NAME ; / ** Defines whether this extension is enabled * / <EOL> public enabled = true ; / ** Defines whether this extension is required * / <EOL> public required = false ; <EOL> private _wasUsed = false ; <EOL> constructor ( exporter ) { } <EOL> hidden public get wasUsed ( ) { <EOL> return this . _wasUsed ; <EOL> } <EOL> public dispose ( ) { } <EOL> public postExportMaterialAsync   ? ( context , node , babylonMaterial ) { <EOL> return new Promise ( ( resolve , reject ) = > { <EOL> let unlitMaterial = false ; <EOL> if ( babylonMaterial instanceof PBRMaterial ) { <EOL> unlitMaterial = babylonMaterial . unlit ; <EOL> } else if ( babylonMaterial instanceof StandardMaterial ) { <EOL> unlitMaterial = babylonMaterial . disableLighting ; <EOL> } <EOL> if ( unlitMaterial ) { <EOL> this . _wasUsed = true ; <EOL> if ( node . extensions == null ) { <EOL> node . extensions = { } ; <EOL> } <EOL> node . extensions [ NAME ] = { } ; <EOL> } <EOL> resolve ( node ) ; <EOL> } ) ; <EOL> } <EOL> } <EOL> _Exporter . RegisterExtension ( NAME , ( exporter ) = > new KHR_materials_unlit ( exporter ) ) ; </s>
<s> / ** <EOL> * Copyright ( c ) <NUM_LIT> , <NUM_LIT> Oracle and / or its affiliates . All rights reserved . <EOL> * This software is dual - licensed to you under the Universal Permissive License ( UPL ) <NUM_LIT> as shown at https : // oss . oracle . com / licenses / upl or Apache License <NUM_LIT> as shown at http : // www . apache . org / licenses / LICENSE - <NUM_LIT> . You may choose either license . <EOL> * / <EOL> import { <EOL> handleErrorBody , <EOL> handleErrorResponse <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> DefaultRetryCondition <EOL> } from "<STR_LIT>" ; <EOL> const Breaker = require ( "<STR_LIT>" ) ; <EOL> async function FetchWrapper ( req ) { <EOL> return new Promise ( async ( resolve , reject ) = > { <EOL> try { <EOL> const response = await fetch ( req ) ; <EOL> if ( response . status & & response . status >= <NUM_LIT> & & response . status <= <NUM_LIT> ) { <EOL> resolve ( { <EOL> response <EOL> } ) ; <EOL> } else { <EOL> const responseClone = response . clone ( ) ; <EOL> const errBody = await handleErrorBody ( responseClone ) ; <EOL> const errorObject = handleErrorResponse ( responseClone , errBody ) ; <EOL> reject ( { <EOL> response , <EOL> errorObject <EOL> } ) ; <EOL> } <EOL> } catch ( e ) { <EOL> reject ( e ) ; <EOL> } <EOL> } ) ; <EOL> } <EOL> function defaultErrorFilterFunction ( e ) { <EOL> console . log ( "<STR_LIT>" , e ) ; <EOL> if ( e . code | | ( e . errorObject & & DefaultRetryCondition . shouldBeRetried ( e . errorObject ) ) ) { <EOL> return false ; <EOL> } <EOL> return true ; <EOL> } <EOL> interface CircuitBreakerOptions { <EOL> timeout   ? : number ; <EOL> resetTimeout   ? : number ; <EOL> rollingCountTimeout   ? : number ; <EOL> rollingCountBuckets   ? : number ; <EOL> name   ? : string ; <EOL> rollingPercentilesEnabled   ? : boolean ; <EOL> capacity   ? : number ; <EOL> errorThresholdPercentage   ? : number ; <EOL> enabled   ? : boolean ; <EOL> allowWarmUp   ? : boolean ; <EOL> volumeThreshold   ? : number ; <EOL> errorFilter   ? : Function ; <EOL> cache   ? : boolean ; <EOL> disableClientCircuitBreaker   ? : boolean ; <EOL> } <EOL> export default class CircuitBreaker { <EOL> circuit : any = null ; noCircuit : boolean = false ; static get envVariableCheckForDefaultCircuitBreaker ( ) { <EOL> if ( process . env . OCI_SDK_DEFAULT_CIRCUITBREAKER_ENABLED == = "<STR_LIT>" ) { <EOL> CircuitBreaker . DefaultCircuitBreakerOverriden = true ; <EOL> } else if ( process . env . OCI_SDK_DEFAULT_CIRCUITBREAKER_ENABLED == = "<STR_LIT>" ) { <EOL> CircuitBreaker . DefaultCircuitBreakerOverriden = true ; <EOL> } <EOL> return process . env . OCI_SDK_DEFAULT_CIRCUITBREAKER_ENABLED ; <EOL> } <EOL> static EnableGlobalCircuitBreaker = true ; static EnableDefaultCircuitBreaker = CircuitBreaker . envVariableCheckForDefaultCircuitBreaker ; public static DefaultCircuitBreakerOverriden = false ; private static DefaultConfiguration : CircuitBreakerOptions = { <EOL> timeout : <NUM_LIT> , <EOL> errorThresholdPercentage : <NUM_LIT> , <EOL> resetTimeout : <NUM_LIT> , <EOL> rollingCountTimeout : <NUM_LIT> , <EOL> rollingCountBuckets : <NUM_LIT> , <EOL> volumeThreshold : <NUM_LIT> , <EOL> errorFilter : defaultErrorFilterFunction <EOL> } ; static get defaultConfiguration ( ) : CircuitBreakerOptions { <EOL> return CircuitBreaker . DefaultConfiguration ; <EOL> } <EOL> static set defaultConfiguration ( circuitBreakerConfig ) { <EOL> CircuitBreaker . DefaultConfiguration = { <EOL> ... CircuitBreaker . DefaultConfiguration , <EOL> ... circuitBreakerConfig <EOL> } ; <EOL> CircuitBreaker . DefaultCircuitBreakerOverriden = true ; <EOL> } <EOL> static internalCircuit = new Breaker ( FetchWrapper , { <EOL> timeout : <NUM_LIT> , <EOL> errorThresholdPercentage : <NUM_LIT> , <EOL> resetTimeout : <NUM_LIT> <EOL> } ) ; constructor ( options   ? ) { <EOL> if ( options ? . disableClientCircuitBreaker ) { <EOL> this . noCircuit = true ; <EOL> return ; <EOL> } <EOL> this . circuit = options   ? new Breaker ( FetchWrapper , options ) : new Breaker ( FetchWrapper , CircuitBreaker . DefaultConfiguration ) ; <EOL> this . circuit . on ( "<STR_LIT>" , ( ) = > { <EOL> console . log ( "<STR_LIT>" ) ; <EOL> } ) ; <EOL> this . circuit . on ( "<STR_LIT>" , ( ) = > { <EOL> console . log ( "<STR_LIT>" ) ; <EOL> } ) ; <EOL> this . circuit . on ( "<STR_LIT>" , ( ) = > { <EOL> console . log ( "<STR_LIT>" ) ; <EOL> } ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> hot <EOL> } from "<STR_LIT>" ; <EOL> import React from "<STR_LIT>" ; <EOL> const App = ( ) = > { <EOL> const [ count , setCount ] = React . useState < number > ( <NUM_LIT> ) ; <EOL> const increment = ( ) = > { <EOL> setCount ( ( count ) = > count + <NUM_LIT> ) ; <EOL> } ; <EOL> const decrement = ( ) = > { <EOL> setCount ( ( count ) = > count - <NUM_LIT> ) ; <EOL> } ; <EOL> return ( < div > < h2 > Number : < b > { count } < / b > < / h2 > < br / > < br / > < button onClick = { ( ) = > increment ( ) } > Increment < / button > { '<STR_LIT>' } < button onClick = { ( ) = > decrement ( ) } > Decrement < / button > { '<STR_LIT>' } < / div > ) ; } ; export default hot ( module ) ( App ) ; </s>
<s> import { <EOL> TriggerContextMapping <EOL> } from '<STR_LIT>' ; <EOL> export interface VisualizationListItem { <EOL> editUrl : string ; editApp   ? : string ; error   ? : string ; icon : string ; id : string ; stage : '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' ; savedObjectType : string ; title : string ; description   ? : string ; getSupportedTriggers   ? : ( ) = > Array < keyof TriggerContextMapping > ; typeTitle : string ; image   ? : string ; <EOL> } <EOL> export interface VisualizationsAppExtension { <EOL> docTypes : string [ ] ; searchFields   ? : string [ ] ; toListItem : ( savedObject : { <EOL> id : string ; type : string ; attributes : object ; <EOL> } ) = > VisualizationListItem ; <EOL> } <EOL> export interface VisTypeAliasPromotion { <EOL> description : string ; buttonText : string ; <EOL> } <EOL> export interface VisTypeAlias { <EOL> aliasPath : string ; aliasApp : string ; name : string ; title : string ; icon : string ; promotion   ? : VisTypeAliasPromotion ; description : string ; getSupportedTriggers   ? : ( ) = > Array < keyof TriggerContextMapping > ; stage : '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' ; appExtensions   ? : { <EOL> visualizations : VisualizationsAppExtension ; <EOL> [ appName ] : unknown ; <EOL> } ; <EOL> } <EOL> const registry = [ ] ; <EOL> interface VisTypeAliasRegistry { <EOL> get : ( ) = > VisTypeAlias [ ] ; add : ( newVisTypeAlias : VisTypeAlias ) = > void ; <EOL> } <EOL> export const visTypeAliasRegistry = { <EOL> get : ( ) = > [ ... registry ] , <EOL> add : ( newVisTypeAlias ) = > { <EOL> if ( registry . find ( ( visTypeAlias ) = > visTypeAlias . name == = newVisTypeAlias . name ) ) { <EOL> throw new Error ( ` $ { newVisTypeAlias . name } already registered ` ) ; <EOL> } <EOL> registry . push ( newVisTypeAlias ) ; <EOL> } , <EOL> } ; </s>
<s> import { <EOL> PbContext <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> DataSourceSettings <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> DataSource , <EOL> DataSourcePlugin <EOL> } from "<STR_LIT>" ; <EOL> export const loadDataSources = async ( settings , variables , context ) = > { <EOL> const dataSources = [ ] ; <EOL> const dataSourcePlugins = context . plugins . byType < DataSourcePlugin > ( DataSourcePlugin . type ) ; <EOL> const sourcesByType = { } ; <EOL> dataSourcePlugins . forEach ( pl = > { <EOL> sourcesByType [ pl . getType ( ) ] = pl . getDataSource ( ) ; <EOL> } ) ; <EOL> for ( const dsConfig of settings ) { <EOL> const { <EOL> id , <EOL> type , <EOL> config <EOL> } = dsConfig ; <EOL> const dataSource = sourcesByType [ type ] ; <EOL> if ( ! dataSource ) { <EOL> continue ; <EOL> } <EOL> const data = await dataSource . loadData ( variables , config , context ) ; <EOL> dataSources . push ( { <EOL> id , <EOL> type , <EOL> data <EOL> } ) ; <EOL> } <EOL> return dataSources ; <EOL> } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> NavLink <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Menu , <EOL> MenuList , <EOL> MenuButton , <EOL> MenuItem , <EOL> MenuLink <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> api <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Avatar <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Logo <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> import { <EOL> useAuth <EOL> } from '<STR_LIT>' ; <EOL> export const PrimaryHeader = ( ) = > { <EOL> const { <EOL> user , <EOL> logout <EOL> } = useAuth ( ) ; <EOL> function handleLogout ( ) { <EOL> logout ( ) ; <EOL> api . auth . logout ( ) ; <EOL> } <EOL> function resetData ( ) { <EOL> if ( ! user ) return ; <EOL> api . users . resetAccountBoardData ( user . id ) . then ( ( ) = > { <EOL> window . location . href = '<STR_LIT>' ; <EOL> } ) ; <EOL> } <EOL> return ( < header className = "<STR_LIT>" > < div className = "<STR_LIT>" > < div > < Logo / > < / div > < div > < nav className = "<STR_LIT>" > < NavLink to = "<STR_LIT>" exact className = "<STR_LIT>" > Dashboard < / NavLink > < NavLink to = "<STR_LIT>" className = "<STR_LIT>" > Boards < / NavLink > < Menu > < MenuButton className = "<STR_LIT>" > < Avatar src = { user   ? . avatarUrl   ! } size = { <NUM_LIT> } / > < / MenuButton > < MenuList className = "<STR_LIT>" > < MenuItem onSelect = { handleLogout } > Logout < / MenuItem > < MenuItem onSelect = { resetData } > Reset Database Boards < / MenuItem > < MenuLink href = "<STR_LIT>" as = "<STR_LIT>" > More Workshops < / MenuLink > < / MenuList > < / Menu > < / nav > < / div > < / div > < / header > ) ; } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage , <EOL> I18nProvider <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiButton , <EOL> EuiEmptyPrompt , <EOL> EuiPage , <EOL> EuiPageBody , <EOL> EuiPageContent <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> onRefresh : ( ) = > void ; <EOL> } <EOL> export const DiscoverUninitialized = ( { <EOL> onRefresh <EOL> } ) = > { <EOL> return ( < I18nProvider > < EuiPage > < EuiPageBody > < EuiPageContent horizontalPosition = "<STR_LIT>" > < EuiEmptyPrompt iconType = "<STR_LIT>" title = { < h2 > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / h2 > } body = { < p > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / p > } actions = { < EuiButton color = "<STR_LIT>" fill onClick = { onRefresh } > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiButton > } / > < / EuiPageContent > < / EuiPageBody > < / EuiPage > < / I18nProvider > ) ; } ; </s>
<s> import { <EOL> PagedAsyncIterableIterator <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> UserAssignedIdentities <EOL> } from "<STR_LIT>" ; <EOL> import * as coreClient from "<STR_LIT>" ; <EOL> import * as Mappers from "<STR_LIT>" ; <EOL> import * as Parameters from "<STR_LIT>" ; <EOL> import { <EOL> ManagedServiceIdentityClient <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Identity , <EOL> UserAssignedIdentitiesListBySubscriptionNextOptionalParams , <EOL> UserAssignedIdentitiesListBySubscriptionOptionalParams , <EOL> UserAssignedIdentitiesListByResourceGroupNextOptionalParams , <EOL> UserAssignedIdentitiesListByResourceGroupOptionalParams , <EOL> UserAssignedIdentitiesListBySubscriptionResponse , <EOL> UserAssignedIdentitiesListByResourceGroupResponse , <EOL> UserAssignedIdentitiesCreateOrUpdateOptionalParams , <EOL> UserAssignedIdentitiesCreateOrUpdateResponse , <EOL> IdentityUpdate , <EOL> UserAssignedIdentitiesUpdateOptionalParams , <EOL> UserAssignedIdentitiesUpdateResponse , <EOL> UserAssignedIdentitiesGetOptionalParams , <EOL> UserAssignedIdentitiesGetResponse , <EOL> UserAssignedIdentitiesDeleteOptionalParams , <EOL> UserAssignedIdentitiesListBySubscriptionNextResponse , <EOL> UserAssignedIdentitiesListByResourceGroupNextResponse <EOL> } from "<STR_LIT>" ; / ** Class containing UserAssignedIdentities operations . * / <EOL> export class UserAssignedIdentitiesImpl implements UserAssignedIdentities { <EOL> private readonly client : ManagedServiceIdentityClient ; <EOL> param client constructor ( client ) { <EOL> this . client = client ; <EOL> } <EOL> param options public listBySubscription ( options   ? ) { <EOL> const iter = this . listBySubscriptionPagingAll ( options ) ; <EOL> return { <EOL> next ( ) { <EOL> return iter . next ( ) ; <EOL> } , <EOL> [ Symbol . asyncIterator ] ( ) { <EOL> return this ; <EOL> } , <EOL> byPage : ( ) = > { <EOL> return this . listBySubscriptionPagingPage ( options ) ; <EOL> } <EOL> } ; <EOL> } <EOL> private async * listBySubscriptionPagingPage ( options   ? ) { <EOL> let result = await this . _listBySubscription ( options ) ; <EOL> yield result . value | | [ ] ; <EOL> let continuationToken = result . nextLink ; <EOL> while ( continuationToken ) { <EOL> result = await this . _listBySubscriptionNext ( continuationToken , options ) ; <EOL> continuationToken = result . nextLink ; <EOL> yield result . value | | [ ] ; <EOL> } <EOL> } <EOL> private async * listBySubscriptionPagingAll ( options   ? ) { <EOL> for await ( const page of this . listBySubscriptionPagingPage ( options ) ) { <EOL> yield * page ; <EOL> } <EOL> } <EOL> param resourceGroupName param options public listByResourceGroup ( resourceGroupName , options   ? ) { <EOL> const iter = this . listByResourceGroupPagingAll ( resourceGroupName , options ) ; <EOL> return { <EOL> next ( ) { <EOL> return iter . next ( ) ; <EOL> } , <EOL> [ Symbol . asyncIterator ] ( ) { <EOL> return this ; <EOL> } , <EOL> byPage : ( ) = > { <EOL> return this . listByResourceGroupPagingPage ( resourceGroupName , options ) ; <EOL> } <EOL> } ; <EOL> } <EOL> private async * listByResourceGroupPagingPage ( resourceGroupName , options   ? ) { <EOL> let result = await this . _listByResourceGroup ( resourceGroupName , options ) ; <EOL> yield result . value | | [ ] ; <EOL> let continuationToken = result . nextLink ; <EOL> while ( continuationToken ) { <EOL> result = await this . _listByResourceGroupNext ( resourceGroupName , continuationToken , options ) ; <EOL> continuationToken = result . nextLink ; <EOL> yield result . value | | [ ] ; <EOL> } <EOL> } <EOL> private async * listByResourceGroupPagingAll ( resourceGroupName , options   ? ) { <EOL> for await ( const page of this . listByResourceGroupPagingPage ( resourceGroupName , options ) ) { <EOL> yield * page ; <EOL> } <EOL> } <EOL> param options private _listBySubscription ( options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> options <EOL> } , listBySubscriptionOperationSpec ) ; <EOL> } <EOL> param resourceGroupName param options private _listByResourceGroup ( resourceGroupName , options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> resourceGroupName , <EOL> options <EOL> } , listByResourceGroupOperationSpec ) ; <EOL> } <EOL> param resourceGroupName param resourceName param parameters param options createOrUpdate ( resourceGroupName , resourceName , parameters , options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> resourceGroupName , <EOL> resourceName , <EOL> parameters , <EOL> options <EOL> } , createOrUpdateOperationSpec ) ; <EOL> } <EOL> param resourceGroupName param resourceName param parameters param options update ( resourceGroupName , resourceName , parameters , options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> resourceGroupName , <EOL> resourceName , <EOL> parameters , <EOL> options <EOL> } , updateOperationSpec ) ; <EOL> } <EOL> param resourceGroupName param resourceName param options get ( resourceGroupName , resourceName , options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> resourceGroupName , <EOL> resourceName , <EOL> options <EOL> } , getOperationSpec ) ; <EOL> } <EOL> param resourceGroupName param resourceName param options delete ( resourceGroupName , resourceName , options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> resourceGroupName , <EOL> resourceName , <EOL> options <EOL> } , deleteOperationSpec ) ; <EOL> } <EOL> param nextLink param options private _listBySubscriptionNext ( nextLink , options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> nextLink , <EOL> options <EOL> } , listBySubscriptionNextOperationSpec ) ; <EOL> } <EOL> param resourceGroupName param nextLink param options private _listByResourceGroupNext ( resourceGroupName , nextLink , options   ? ) { <EOL> return this . client . sendOperationRequest ( { <EOL> resourceGroupName , <EOL> nextLink , <EOL> options <EOL> } , listByResourceGroupNextOperationSpec ) ; <EOL> } <EOL> } <EOL> const serializer = coreClient . createSerializer ( Mappers , false ) ; <EOL> const listBySubscriptionOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . UserAssignedIdentitiesListResult <EOL> } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . subscriptionId ] , <EOL> headerParameters : [ Parameters . accept ] , <EOL> serializer <EOL> } ; <EOL> const listByResourceGroupOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . UserAssignedIdentitiesListResult <EOL> } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . subscriptionId , Parameters . resourceGroupName ] , <EOL> headerParameters : [ Parameters . accept ] , <EOL> serializer <EOL> } ; <EOL> const createOrUpdateOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . Identity <EOL> } , <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . Identity <EOL> } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> requestBody : Parameters . parameters , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . subscriptionId , Parameters . resourceGroupName , Parameters . resourceName ] , <EOL> headerParameters : [ Parameters . accept , Parameters . contentType ] , <EOL> mediaType : "<STR_LIT>" , <EOL> serializer <EOL> } ; <EOL> const updateOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . Identity <EOL> } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> requestBody : Parameters . parameters1 , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . subscriptionId , Parameters . resourceGroupName , Parameters . resourceName ] , <EOL> headerParameters : [ Parameters . accept , Parameters . contentType ] , <EOL> mediaType : "<STR_LIT>" , <EOL> serializer <EOL> } ; <EOL> const getOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . Identity <EOL> } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . subscriptionId , Parameters . resourceGroupName , Parameters . resourceName ] , <EOL> headerParameters : [ Parameters . accept ] , <EOL> serializer <EOL> } ; <EOL> const deleteOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { } , <EOL> <NUM_LIT> : { } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . subscriptionId , Parameters . resourceGroupName , Parameters . resourceName ] , <EOL> headerParameters : [ Parameters . accept ] , <EOL> serializer <EOL> } ; <EOL> const listBySubscriptionNextOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . UserAssignedIdentitiesListResult <EOL> } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . nextLink , Parameters . subscriptionId ] , <EOL> headerParameters : [ Parameters . accept ] , <EOL> serializer <EOL> } ; <EOL> const listByResourceGroupNextOperationSpec = { <EOL> path : "<STR_LIT>" , <EOL> httpMethod : "<STR_LIT>" , <EOL> responses : { <EOL> <NUM_LIT> : { <EOL> bodyMapper : Mappers . UserAssignedIdentitiesListResult <EOL> } , <EOL> default : { <EOL> bodyMapper : Mappers . CloudError <EOL> } <EOL> } , <EOL> queryParameters : [ Parameters . apiVersion ] , <EOL> urlParameters : [ Parameters . $ host , Parameters . nextLink , Parameters . subscriptionId , Parameters . resourceGroupName ] , <EOL> headerParameters : [ Parameters . accept ] , <EOL> serializer <EOL> } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> EuiSwitch , <EOL> EuiFormRow <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggParamEditorProps <EOL> } from '<STR_LIT>' ; <EOL> function UseGeocentroidParamEditor ( { <EOL> value = false , <EOL> setValue <EOL> } ) { <EOL> const label = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> return ( < EuiFormRow compressed > < EuiSwitch compressed = { true } label = { label } checked = { value } onChange = { ( ev ) = > setValue ( ev . target . checked ) } / > < / EuiFormRow > ) ; } export { UseGeocentroidParamEditor } ; </s>
<s> export class PendingTaskCounter { <EOL> private count = <NUM_LIT> ; <EOL> private callbacks : ( ( ) = > void ) [ ] = [ ] ; <EOL> public countTask ( ) { <EOL> this . count + + ; <EOL> let ended = false ; <EOL> return ( ) = > { <EOL> if ( ended ) return ; <EOL> ended = true ; <EOL> this . count - - ; <EOL> if ( this . count == = <NUM_LIT> ) { <EOL> this . callbacks . forEach ( ( cb ) = > cb ( ) ) ; <EOL> this . callbacks . length = <NUM_LIT> ; <EOL> } <EOL> } ; <EOL> } <EOL> / ** <EOL> * the callback style is preferred over the promise style <EOL> * because cb will be called ** synchronously ** when count turn <NUM_LIT> <EOL> * while promise - then - cb would be called in next microtask ( at that time the state may have changed ) <EOL> * / <EOL> public callOnceWhenIdle ( cb ) { <EOL> if ( this . count == = <NUM_LIT> ) { <EOL> cb ( ) ; <EOL> } else { <EOL> this . callbacks . push ( cb ) ; <EOL> } <EOL> } / ** track a changeable pending state * / <EOL> public countPendingState ( pendingState ) { <EOL> let stopCounting ; <EOL> pendingState . onStateChange ( ( isPending ) = > { <EOL> if ( isPending ) { <EOL> if ( stopCounting ) return ; <EOL> stopCounting = this . countTask ( ) ; <EOL> } else { <EOL> stopCounting ? . ( ) ; <EOL> stopCounting = undefined ; <EOL> } <EOL> } ) ; <EOL> } <EOL> } <EOL> export class PendingState { <EOL> private _isPending = false ; <EOL> get isPending ( ) { <EOL> return this . _isPending ; <EOL> } <EOL> set isPending ( value ) { <EOL> if ( this . _isPending == = value ) return ; <EOL> this . _isPending = value ; <EOL> this . cbs . forEach ( ( cb ) = > cb ( value ) ) ; <EOL> } <EOL> private cbs : Array < ( isPending : boolean ) = > void > = [ ] ; <EOL> onStateChange ( cb ) { <EOL> this . cbs . push ( cb ) ; <EOL> return ( ) = > { <EOL> this . cbs = this . cbs . filter ( ( v ) = > v != = cb ) ; <EOL> } ; <EOL> } <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> Image , <EOL> ImageURISource , <EOL> StyleProp , <EOL> Text , <EOL> TextInput , <EOL> TextStyle , <EOL> TouchableOpacity , <EOL> View , <EOL> ViewStyle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> style as S <EOL> } from '<STR_LIT>' ; <EOL> const icons = { <EOL> increase : require ( '<STR_LIT>' ) , <EOL> decrease : require ( '<STR_LIT>' ) <EOL> } ; <EOL> const nonNumericRegex = / \ D / g ; <EOL> export interface SerializableStatelessStepperProps { <EOL> format   ? : '<STR_LIT>' | '<STR_LIT>' | '<STR_LIT>' ; <EOL> stepperStyle   ? : ViewStyle ; <EOL> count : number ; <EOL> countUpperLimit   ? : number ; <EOL> counterStyle   ? : TextStyle ; <EOL> editable   ? : boolean ; <EOL> prefix   ? : string ; <EOL> } <EOL> export interface StatelessStepperProps extends Omit < SerializableStatelessStepperProps , '<STR_LIT>' | '<STR_LIT>' > { <EOL> onChange   ? : ( count : number ) = > void ; stepperStyle   ? : StyleProp < ViewStyle > ; counterStyle   ? : StyleProp < TextStyle > ; renderText   ? : ( text : string , style : StyleProp < TextStyle > , value : number ) = > React . ReactNode ; onDecreaseButtonPress : ( count : number ) = > void ; decreaseButtonImage   ? : ImageURISource ; renderDecreaseButton   ? : ( count : number , handlePress : ( ) = > void ) = > React . ReactNode ; onIncreaseButtonPress : ( count : number ) = > void ; increaseButtonImage   ? : ImageURISource ; renderIncreaseButton   ? : ( count : number , handlePress : ( ) = > void ) = > React . ReactNode ; <EOL> } <EOL> const defaultProps = { <EOL> increaseButtonImage : icons . increase , <EOL> decreaseButtonImage : icons . decrease <EOL> } ; <EOL> export const StatelessStepper = ( props = defaultProps ) : JSX . Element = > { <EOL> const kButtonTouchabilityOpacity = <NUM_LIT> ; <EOL> const handleDecreasePress = ( ) = > { <EOL> const oldCount = props . count ; <EOL> const newCount = oldCount & & oldCount - <NUM_LIT> ; <EOL> if ( props . onDecreaseButtonPress & & newCount ) { <EOL> props . onDecreaseButtonPress ( newCount ) ; <EOL> } <EOL> if ( props . onChange & & newCount ) { <EOL> props . onChange ( newCount ) ; <EOL> } <EOL> } ; <EOL> const handleIncreasePress = ( ) = > { <EOL> const newCount = props . count & & props . count + <NUM_LIT> ; <EOL> if ( props . onIncreaseButtonPress & & newCount ) { <EOL> props . onIncreaseButtonPress ( newCount ) ; <EOL> } <EOL> if ( props . onChange & & newCount ) { <EOL> props . onChange ( newCount ) ; <EOL> } <EOL> } ; <EOL> const renderDecreaseButton = ( style = { } ) = > { <EOL> const { <EOL> decreaseButtonImage = icons . decrease , renderDecreaseButton , count <EOL> } = props ; <EOL> if ( renderDecreaseButton & & count ) { <EOL> return renderDecreaseButton ( count , handleDecreasePress ) ; <EOL> } <EOL> return ( < TouchableOpacity accessibilityLabel = '<STR_LIT>' activeOpacity = { kButtonTouchabilityOpacity } disabled = { props . count & & props . count <= <NUM_LIT> | | true } onPress = { handleDecreasePress } > < Image resizeMode = '<STR_LIT>' source = { decreaseButtonImage } style = { [ S . buttonImage , style ] } / > < / TouchableOpacity > ) ; } ; const renderIncreaseButton = ( style = { } ) = > { const { countUpperLimit , increaseButtonImage = icons . increase , renderIncreaseButton } = props ; if ( renderIncreaseButton & & props . count ) { return renderIncreaseButton ( props . count , handleIncreasePress ) ; } return ( < TouchableOpacity accessibilityLabel = '<STR_LIT>' activeOpacity = { kButtonTouchabilityOpacity } disabled = {   ! countUpperLimit | | props . count & & props . count >= countUpperLimit | | true } onPress = { handleIncreasePress } > < Image resizeMode = '<STR_LIT>' source = { increaseButtonImage } style = { [ S . buttonImage , style ] } / > < / TouchableOpacity > ) ; } ; const onTextChange = ( text ) = > { text = text . replace ( nonNumericRegex , '<STR_LIT>' ) ; let value = parseInt ( text , <NUM_LIT> ) ; if (   ! isNaN ( value ) ) { if ( props . countUpperLimit & & value > props . countUpperLimit ) { value = props . countUpperLimit ; } if ( props . onChange ) { props . onChange ( value ) ; } } } ; const renderText = ( counterStyle , counterText ) = > { if ( props . renderText & & props . count ) { return props . renderText ( counterText , counterStyle , props . count ) ; } if ( props . editable ) { return ( < TextInput keyboardType = { '<STR_LIT>' } onChangeText = { onTextChange } style = { counterStyle } value = { counterText } / > ) ; } return ( < Text style = { counterStyle } > { counterText } < / Text > ) ; } ; const renderHorizontalCenter = ( counterText , counterStyle , stepperStyle ) = > { return ( < View style = { stepperStyle   ? stepperStyle : S . stepperHorizontalContainer } > { renderDecreaseButton ( ) } { renderText ( counterStyle   ? counterStyle : S . counterHorizontalCenter , counterText ) } { renderIncreaseButton ( ) } < / View > ) ; } ; const renderHorizontalLeft = ( counterText , counterStyle , stepperStyle ) = > { return ( < View style = { stepperStyle   ? stepperStyle : S . stepperHorizontalContainer } > { renderText ( counterStyle   ? counterStyle : S . counterHorizontalLeft , counterText ) } { renderDecreaseButton ( ) } { renderIncreaseButton ( S . buttonIncreaseHorizontalLeft ) } < / View > ) ; } ; const renderVertical = ( counterText , counterStyle , stepperStyle ) = > { return ( < View style = { stepperStyle   ? stepperStyle : S . stepperVerticalContainer } > { renderIncreaseButton ( ) } { renderText ( counterStyle   ? counterStyle : S . counterVertical , counterText ) } { renderDecreaseButton ( ) } < / View > ) ; } ; const { counterStyle , format , prefix , stepperStyle } = props ; const { count } = props ; const counterText = prefix   ?   ` $ { prefix }   $ { count } ` :   ` $ { count } ` ; switch ( format ) { case '<STR_LIT>' : return renderHorizontalCenter ( counterText , counterStyle , stepperStyle ) ; case '<STR_LIT>' : return renderHorizontalLeft ( counterText , counterStyle , stepperStyle ) ; case '<STR_LIT>' : return renderVertical ( counterText , counterStyle , stepperStyle ) ; default : return renderHorizontalCenter ( counterText , counterStyle , stepperStyle ) ; } } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage , <EOL> I18nProvider <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> startItem : number ; endItem : number ; totalItems : number ; <EOL> } <EOL> export function ToolBarPagerText ( { <EOL> startItem , <EOL> endItem , <EOL> totalItems <EOL> } ) { <EOL> return ( < I18nProvider > < div className = "<STR_LIT>" data - test - subj = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { startItem , endItem , totalItems } } / > < / div > < / I18nProvider > ) ; } </s>
<s> const _cleanCSS = require ( '<STR_LIT>' ) ; <EOL> const cleanCSS = new _cleanCSS ( { } ) ; <EOL> export function minifyCSS ( css ) { <EOL> return cleanCSS . minify ( css ) . styles ; <EOL> } </s>
<s> import { <EOL> fromHex , <EOL> toHex <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> BatchPart , <EOL> JsonRpcSenders <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> throwIfCancelled <EOL> } from "<STR_LIT>" ; <EOL> export interface NewHeadsEvent { <EOL> author : string ; difficulty : string ; extraData : string ; gasLimit : string ; gasUsed : string ; hash : string ; logsBloom : string ; miner : string ; mixHash : string ; nonce : string ; number : string ; parentHash : string ; receiptsRoot : string ; sealFields : string [ ] ; sha3Uncles : string ; size : string ; stateRoot : string ; timestamp : string ; transactionsRoot : string ; <EOL> } <EOL> / ** <EOL> * The return type of eth_getBlocksByHash . <EOL> * / <EOL> export interface BlockHead extends NewHeadsEvent { <EOL> totalDifficulty : string ; transactions : any [ ] ; uncles : string [ ] ; <EOL> } <EOL> export interface LogsEvent { <EOL> address : string ; blockHash : string ; blockNumber : string ; data : string ; logIndex : string ; topics : string [ ] ; transactionHash : string ; transactionIndex : string ; removed   ? : boolean ; <EOL> } <EOL> export interface LogsSubscriptionFilter { <EOL> address   ? : string | string [ ] ; <EOL> topics   ? : Array < string | string [ ] | null > ; <EOL> } <EOL> interface GetLogsOptions extends LogsSubscriptionFilter { <EOL> fromBlock   ? : string ; <EOL> toBlock   ? : string ; <EOL> } <EOL> export type Backfiller = ReturnType < typeof makeBackfiller > ; <EOL> / ** <EOL> * The maximum number of blocks to backfill . If more than this many blocks have <EOL> * been missed , then we '<STR_LIT>' t <EOL> * end up requesting thousands of blocks if somebody left their laptop closed <EOL> * for a week . <EOL> * / <EOL> const MAX_BACKFILL_BLOCKS = <NUM_LIT> ; <EOL> export function makeBackfiller ( senders ) { <EOL> return { <EOL> getNewHeadsBackfill , <EOL> getLogsBackfill <EOL> } ; <EOL> async function getNewHeadsBackfill ( isCancelled , previousHeads , fromBlockNumber ) { <EOL> throwIfCancelled ( isCancelled ) ; <EOL> const toBlockNumber = await getBlockNumber ( ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> if ( previousHeads . length == = <NUM_LIT> ) { <EOL> return getHeadEventsInRange ( Math . max ( fromBlockNumber , toBlockNumber - MAX_BACKFILL_BLOCKS ) + <NUM_LIT> , toBlockNumber + <NUM_LIT> ) ; <EOL> } <EOL> const lastSeenBlockNumber = fromHex ( previousHeads [ previousHeads . length - <NUM_LIT> ] . number ) ; <EOL> const minBlockNumber = Math . max ( <NUM_LIT> , lastSeenBlockNumber - MAX_BACKFILL_BLOCKS ) ; <EOL> if ( lastSeenBlockNumber < minBlockNumber ) { <EOL> return getHeadEventsInRange ( minBlockNumber , toBlockNumber + <NUM_LIT> ) ; <EOL> } <EOL> const reorgHeads = await getReorgHeads ( isCancelled , previousHeads ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> const intermediateHeads = await getHeadEventsInRange ( lastSeenBlockNumber + <NUM_LIT> , toBlockNumber + <NUM_LIT> ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> return [ ... reorgHeads , ... intermediateHeads ] ; <EOL> } <EOL> async function getReorgHeads ( isCancelled , previousHeads ) { <EOL> const result = [ ] ; <EOL> for ( let i = previousHeads . length - <NUM_LIT> ; i >= <NUM_LIT> ; i - - ) { <EOL> const oldEvent = previousHeads [ i ] ; <EOL> const blockHead = await getBlockByNumber ( fromHex ( oldEvent . number ) ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> if ( oldEvent . hash == = blockHead . hash ) { <EOL> break ; <EOL> } <EOL> result . push ( toNewHeadsEvent ( blockHead ) ) ; <EOL> } <EOL> return result . reverse ( ) ; <EOL> } <EOL> async function getHeadEventsInRange ( fromBlockInclusive , toBlockExclusive ) { <EOL> if ( fromBlockInclusive >= toBlockExclusive ) { <EOL> return [ ] ; <EOL> } <EOL> const batchParts = [ ] ; <EOL> for ( let i = fromBlockInclusive ; i < toBlockExclusive ; i + + ) { <EOL> batchParts . push ( { <EOL> method : "<STR_LIT>" , <EOL> params : [ toHex ( i ) , false ] , <EOL> } ) ; <EOL> } <EOL> const heads = await senders . sendBatch ( batchParts ) ; <EOL> return heads . map ( toNewHeadsEvent ) ; <EOL> } <EOL> async function getBlockByNumber ( blockNumber ) { <EOL> return senders . send ( "<STR_LIT>" , [ toHex ( blockNumber ) , false ] ) ; <EOL> } <EOL> async function getLogsBackfill ( isCancelled , filter , previousLogs , fromBlockNumber ) { <EOL> throwIfCancelled ( isCancelled ) ; <EOL> const toBlockNumber = await getBlockNumber ( ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> if ( previousLogs . length == = <NUM_LIT> ) { <EOL> return getLogsInRange ( filter , Math . max ( fromBlockNumber , toBlockNumber - MAX_BACKFILL_BLOCKS ) + <NUM_LIT> , toBlockNumber + <NUM_LIT> ) ; <EOL> } <EOL> const lastSeenBlockNumber = fromHex ( previousLogs [ previousLogs . length - <NUM_LIT> ] . blockNumber ) ; <EOL> const minBlockNumber = Math . max ( <NUM_LIT> , lastSeenBlockNumber - MAX_BACKFILL_BLOCKS ) ; <EOL> if ( lastSeenBlockNumber < minBlockNumber ) { <EOL> return getLogsInRange ( filter , minBlockNumber , toBlockNumber + <NUM_LIT> ) ; <EOL> } <EOL> const commonAncestorNumber = await getCommonAncestorNumber ( isCancelled , previousLogs ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> const removedLogs = previousLogs . filter ( ( log ) = > fromHex ( log . blockNumber ) > commonAncestorNumber ) . map ( ( log ) = > ( { <EOL> ... log , <EOL> removed : true <EOL> } ) ) ; <EOL> const addedLogs = await getLogsInRange ( filter , commonAncestorNumber + <NUM_LIT> , toBlockNumber + <NUM_LIT> ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> return [ ... removedLogs , ... addedLogs ] ; <EOL> } <EOL> async function getCommonAncestorNumber ( isCancelled , previousLogs ) { <EOL> for ( let i = previousLogs . length - <NUM_LIT> ; i >= <NUM_LIT> ; i - - ) { <EOL> const { <EOL> blockHash , <EOL> blockNumber <EOL> } = previousLogs [ i ] ; <EOL> const { <EOL> hash <EOL> } = await getBlockByNumber ( fromHex ( blockNumber ) ) ; <EOL> throwIfCancelled ( isCancelled ) ; <EOL> if ( blockHash == = hash ) { <EOL> return fromHex ( blockNumber ) ; <EOL> } <EOL> } <EOL> return Number . NEGATIVE_INFINITY ; <EOL> } <EOL> async function getLogsInRange ( filter , fromBlockInclusive , toBlockExclusive ) { <EOL> if ( fromBlockInclusive >= toBlockExclusive ) { <EOL> return [ ] ; <EOL> } <EOL> const rangeFilter = { <EOL> ... filter , <EOL> fromBlock : toHex ( fromBlockInclusive ) , <EOL> toBlock : toHex ( toBlockExclusive - <NUM_LIT> ) , <EOL> } ; <EOL> return senders . send ( "<STR_LIT>" , [ rangeFilter ] ) ; <EOL> } <EOL> async function getBlockNumber ( ) { <EOL> const blockNumberHex = await senders . send ( "<STR_LIT>" ) ; <EOL> return fromHex ( blockNumberHex ) ; <EOL> } <EOL> } <EOL> function toNewHeadsEvent ( head ) { <EOL> const result = { <EOL> ... head <EOL> } ; <EOL> delete result . totalDifficulty ; <EOL> delete result . transactions ; <EOL> delete result . uncles ; <EOL> return result ; <EOL> } <EOL> export function dedupeNewHeads ( events ) { <EOL> return dedupe ( events , ( event ) = > event . hash ) ; <EOL> } <EOL> export function dedupeLogs ( events ) { <EOL> return dedupe ( events , ( event ) = >   ` $ { event . blockHash } / $ { event . logIndex } ` ) ; <EOL> } <EOL> function dedupe < T > ( items , getKey ) { <EOL> const keysSeen = new Set ( ) ; <EOL> const result = [ ] ; <EOL> items . forEach ( ( item ) = > { <EOL> const key = getKey ( item ) ; <EOL> if ( ! keysSeen . has ( key ) ) { <EOL> keysSeen . add ( key ) ; <EOL> result . push ( item ) ; <EOL> } <EOL> } ) ; <EOL> return result ; <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SerializedFieldFormat <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldFormat , <EOL> FieldFormatsContentType , <EOL> IFieldFormat , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> convertDateRangeToString , <EOL> DateRangeKey <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> convertIPRangeToString , <EOL> IpRangeKey <EOL> } from '<STR_LIT>' ; <EOL> type GetFieldFormat = ( mapping : SerializedFieldFormat ) = > IFieldFormat ; <EOL> internal <EOL> export function getFormatWithAggs ( getFieldFormat ) { <EOL> return ( mapping ) = > { <EOL> const { <EOL> id , <EOL> params = { } <EOL> } = mapping ; <EOL> const customFormats = { <EOL> range : ( ) = > { <EOL> const RangeFormat = FieldFormat . from ( ( range ) = > { <EOL> const nestedFormatter = params as SerializedFieldFormat ; <EOL> const format = getFieldFormat ( { <EOL> id : nestedFormatter . id , <EOL> params : nestedFormatter . params , <EOL> } ) ; <EOL> const gte = '<STR_LIT>' ; <EOL> const lt = '<STR_LIT>' ; <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> gte , <EOL> from : format . convert ( range . gte ) , <EOL> lt , <EOL> to : format . convert ( range . lt ) , <EOL> } , <EOL> } ) ; <EOL> } ) ; <EOL> return new RangeFormat ( ) ; <EOL> } , <EOL> date_range : ( ) = > { <EOL> const nestedFormatter = params as SerializedFieldFormat ; <EOL> const DateRangeFormat = FieldFormat . from ( ( range ) = > { <EOL> const format = getFieldFormat ( { <EOL> id : nestedFormatter . id , <EOL> params : nestedFormatter . params , <EOL> } ) ; <EOL> return convertDateRangeToString ( range , format . convert . bind ( format ) ) ; <EOL> } ) ; <EOL> return new DateRangeFormat ( ) ; <EOL> } , <EOL> ip_range : ( ) = > { <EOL> const nestedFormatter = params as SerializedFieldFormat ; <EOL> const IpRangeFormat = FieldFormat . from ( ( range ) = > { <EOL> const format = getFieldFormat ( { <EOL> id : nestedFormatter . id , <EOL> params : nestedFormatter . params , <EOL> } ) ; <EOL> return convertIPRangeToString ( range , format . convert . bind ( format ) ) ; <EOL> } ) ; <EOL> return new IpRangeFormat ( ) ; <EOL> } , <EOL> terms : ( ) = > { <EOL> const convert = ( val , type ) = > { <EOL> const format = getFieldFormat ( { <EOL> id : params . id , <EOL> params <EOL> } ) ; <EOL> if ( val == = '<STR_LIT>' ) { <EOL> return params . otherBucketLabel ; <EOL> } <EOL> if ( val == = '<STR_LIT>' ) { <EOL> return params . missingBucketLabel ; <EOL> } <EOL> return format . convert ( val , type ) ; <EOL> } ; <EOL> return { <EOL> convert , <EOL> getConverterFor : ( type ) = > ( val ) = > convert ( val , type ) , <EOL> } <EOL> as IFieldFormat ; <EOL> } , <EOL> } ; <EOL> if ( ! id | |   ! ( id in customFormats ) ) { <EOL> return getFieldFormat ( mapping ) ; <EOL> } <EOL> return customFormats [ id ] ( ) ; <EOL> } ; <EOL> } </s>
<s> import { <EOL> Component , <EOL> OnInit <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> styleUrls : [ '<STR_LIT>' ] <EOL> } ) export class PrTimelineLoadingComponent implements OnInit { <EOL> constructor ( ) { } <EOL> ngOnInit ( ) { } <EOL> } </s>
<s> import { <EOL> browser , <EOL> element , <EOL> by <EOL> } from '<STR_LIT>' ; <EOL> export class WebFrontendPage { <EOL> navigateTo ( ) { <EOL> return browser . get ( '<STR_LIT>' ) ; <EOL> } <EOL> getParagraphText ( ) { <EOL> return element ( by . css ( '<STR_LIT>' ) ) . getText ( ) ; <EOL> } <EOL> } <EOL> export class WebFrontendAbout { <EOL> navigateTo ( ) { <EOL> return browser . get ( '<STR_LIT>' ) ; <EOL> } <EOL> getH1Text ( ) { <EOL> return element ( by . css ( '<STR_LIT>' ) ) . getText ( ) ; <EOL> } <EOL> } <EOL> export class WebFrontendLogin { <EOL> navigateTo ( ) { <EOL> return browser . get ( '<STR_LIT>' ) ; <EOL> } <EOL> getInputEmail ( ) { <EOL> return element ( by . css ( '<STR_LIT>' ) ) ; <EOL> } <EOL> getInputPassword ( ) { <EOL> return element ( by . css ( '<STR_LIT>' ) ) ; <EOL> } <EOL> getLoginButton ( ) { <EOL> return element ( by . css ( '<STR_LIT>' ) ) ; <EOL> } <EOL> getSnackBar ( ) { <EOL> return element ( by . css ( '<STR_LIT>' ) ) ; <EOL> } <EOL> } </s>
<s> import React , { <EOL> useEffect , <EOL> useState <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiLink , <EOL> EuiText <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisOptionsProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SelectOption <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SwitchOption <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ColorSchemaParams <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ColorSchema <EOL> } from '<STR_LIT>' ; <EOL> export type SetColorSchemaOptionsValue = < T extends keyof ColorSchemaParams > ( paramName : T , value : ColorSchemaParams [ T ] ) = > void ; interface ColorSchemaOptionsProps extends ColorSchemaParams { disabled   ? : boolean ; colorSchemas : ColorSchema [ ] ; uiState : VisOptionsProps [ '<STR_LIT>' ] ; setValue : SetColorSchemaOptionsValue ; showHelpText   ? : boolean ; } function ColorSchemaOptions ( { disabled , colorSchema , colorSchemas , invertColors , uiState , setValue , showHelpText = true , } ) { const [ isCustomColors , setIsCustomColors ] = useState ( ( ) = >   !   ! uiState . get ( '<STR_LIT>' ) ) ; useEffect ( ( ) = > { uiState . on ( '<STR_LIT>' , ( ) = > { setIsCustomColors ( true ) ; } ) ; } , [ uiState ] ) ; const resetColorsButton = ( < EuiText size = "<STR_LIT>" > < EuiLink onClick = { ( ) = > { uiState . set ( '<STR_LIT>' , null ) ; setIsCustomColors ( false ) ; } } > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiLink > < / EuiText > ) ; return ( < > < SelectOption disabled = { disabled } helpText = { showHelpText & & i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } labelAppend = { isCustomColors & & resetColorsButton } options = { colorSchemas } paramName = "<STR_LIT>" value = { colorSchema } setValue = { setValue } / > < SwitchOption disabled = { disabled } label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } paramName = "<STR_LIT>" value = { invertColors } setValue = { setValue } / > < / > ) ; } export { ColorSchemaOptions } ; </s>
<s> import * as vscode from "<STR_LIT>" ; <EOL> import * as CompletionUtils from "<STR_LIT>" ; <EOL> import * as TestUtils from "<STR_LIT>" ; <EOL> suite ( "<STR_LIT>" , async ( ) = > { <EOL> const docUri = TestUtils . getDocUri ( "<STR_LIT>" ) ; <EOL> vscode . window . showInformationMessage ( ` Starting tests using based file :   $ { docUri } ` ) ; <EOL> test ( "<STR_LIT>" , async ( ) = > { <EOL> await CompletionUtils . testCompletion ( docUri , new vscode . Position ( <NUM_LIT> , <NUM_LIT> ) , { <EOL> items : [ { <EOL> label : "<STR_LIT>" , <EOL> kind : vscode . CompletionItemKind . Function <EOL> } ] <EOL> } , CompletionUtils . VertificationType . Contains ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import React , { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import PropTypes from '<STR_LIT>' ; <EOL> import { <EOL> EuiButtonIcon , <EOL> EuiFlexGroup , <EOL> EuiFlexItem , <EOL> EuiInMemoryTable , <EOL> EuiSpacer , <EOL> EuiToolTip , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataDownloadOptions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataViewRow , <EOL> DataViewColumn <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> TabularData <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IUiSettingsClient <EOL> } from '<STR_LIT>' ; <EOL> interface DataTableFormatState { <EOL> columns : DataViewColumn [ ] ; rows : DataViewRow [ ] ; <EOL> } <EOL> interface DataTableFormatProps { <EOL> data : TabularData ; exportTitle : string ; uiSettings : IUiSettingsClient ; isFormatted   ? : boolean ; <EOL> } <EOL> export class DataTableFormat extends Component < DataTableFormatProps , DataTableFormatState > { <EOL> static propTypes = { <EOL> data : PropTypes . object . isRequired , <EOL> exportTitle : PropTypes . string . isRequired , <EOL> uiSettings : PropTypes . object . isRequired , <EOL> isFormatted : PropTypes . bool , <EOL> } ; csvSeparator = this . props . uiSettings . get ( '<STR_LIT>' , '<STR_LIT>' ) ; quoteValues = this . props . uiSettings . get ( '<STR_LIT>' , true ) ; state = { } <EOL> as DataTableFormatState ; static renderCell ( dataColumn , value , isFormatted = false ) { <EOL> return ( < EuiFlexGroup responsive = { false } gutterSize = "<STR_LIT>" alignItems = "<STR_LIT>" > < EuiFlexItem grow = { false } > { isFormatted   ? value . formatted : value } < / EuiFlexItem > < EuiFlexItem grow = { false } > < EuiFlexGroup responsive = { false } gutterSize = "<STR_LIT>" alignItems = "<STR_LIT>" > { dataColumn . filter & & ( < EuiToolTip position = "<STR_LIT>" content = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > } > < EuiButtonIcon iconType = "<STR_LIT>" color = "<STR_LIT>" aria - label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } data - test - subj = "<STR_LIT>" className = "<STR_LIT>" onClick = { ( ) = > dataColumn . filter ( value ) } / > < / EuiToolTip > ) } { dataColumn . filterOut & & ( < EuiFlexItem grow = { false } > < EuiToolTip position = "<STR_LIT>" content = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > } > < EuiButtonIcon iconType = "<STR_LIT>" color = "<STR_LIT>" aria - label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } data - test - subj = "<STR_LIT>" className = "<STR_LIT>" onClick = { ( ) = > dataColumn . filterOut ( value ) } / > < / EuiToolTip > < / EuiFlexItem > ) } < / EuiFlexGroup > < / EuiFlexItem > < / EuiFlexGroup > ) ; } static getDerivedStateFromProps ( { data , isFormatted } ) { if (   ! data ) { return { columns : null , rows : null , } ; } const columns = data . columns . map ( ( dataColumn ) = > ( { name : dataColumn . name , field : dataColumn . field , sortable : isFormatted   ? ( row ) = > row [ dataColumn . field ] . raw : true , render : ( value ) = > DataTableFormat . renderCell ( dataColumn , value , isFormatted ) , } ) ) ; return { columns , rows : data . rows } ; } render ( ) { const { columns , rows } = this . state ; const pagination = { pageSizeOptions : [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , initialPageSize : <NUM_LIT> , } ; return ( < > < EuiFlexGroup > < EuiFlexItem grow = { true } / > < EuiFlexItem grow = { false } > < DataDownloadOptions isFormatted = { this . props . isFormatted } title = { this . props . exportTitle } csvSeparator = { this . csvSeparator } quoteValues = { this . quoteValues } columns = { columns } rows = { rows } / > < / EuiFlexItem > < / EuiFlexGroup > < EuiSpacer size = "<STR_LIT>" / > < EuiInMemoryTable className = "<STR_LIT>" data - test - subj = "<STR_LIT>" columns = { columns } items = { rows } sorting = { true } pagination = { pagination } / > < / > ) ; } } </s>
<s> import { <EOL> isEmpty <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IUiSettingsClient , <EOL> SavedObjectsClientContract <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> indexPatterns , <EOL> IndexPatternAttributes <EOL> } from '<STR_LIT>' ; <EOL> export async function fetchIndexPatterns ( savedObjectsClient , indexPatternStrings , uiSettings ) { <EOL> if ( ! indexPatternStrings | | isEmpty ( indexPatternStrings ) ) { <EOL> return [ ] ; <EOL> } <EOL> const searchString = indexPatternStrings . map ( ( string ) = >   ` "<STR_LIT>" ` ) . join ( '<STR_LIT>' ) ; <EOL> const indexPatternsFromSavedObjects = await savedObjectsClient . find < IndexPatternAttributes > ( { <EOL> type : '<STR_LIT>' , <EOL> fields : [ '<STR_LIT>' , '<STR_LIT>' ] , <EOL> search : searchString , <EOL> searchFields : [ '<STR_LIT>' ] , <EOL> } ) ; <EOL> const exactMatches = indexPatternsFromSavedObjects . savedObjects . filter ( ( savedObject ) = > { <EOL> return indexPatternStrings . includes ( savedObject . attributes . title ) ; <EOL> } ) ; <EOL> const defaultIndex = uiSettings . get ( '<STR_LIT>' ) ; <EOL> const allMatches = exactMatches . length == = indexPatternStrings . length   ? exactMatches : [ ... exactMatches , await savedObjectsClient . get < IndexPatternAttributes > ( '<STR_LIT>' , defaultIndex ) , ] ; <EOL> return allMatches . map ( indexPatterns . getFromSavedObject ) ; <EOL> } </s>
<s> import { <EOL> isPlatformBrowser <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ClassProvider , <EOL> FactoryProvider , <EOL> InjectionToken , <EOL> PLATFORM_ID <EOL> } from '<STR_LIT>' ; <EOL> export const WINDOW = new InjectionToken ( '<STR_LIT>' ) ; <EOL> export abstract class WindowRef { <EOL> get nativeWindow ( ) : Window | Object { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> } <EOL> export class BrowserWindowRef extends WindowRef { <EOL> constructor ( ) { <EOL> super ( ) ; <EOL> } <EOL> get nativeWindow ( ) : Window | Object { <EOL> return window ; <EOL> } <EOL> } <EOL> export function windowFactory ( browserWindowRef , platformId ) { <EOL> if ( isPlatformBrowser ( platformId ) ) { <EOL> return browserWindowRef . nativeWindow ; <EOL> } <EOL> return { } ; <EOL> } <EOL> const browserWindowProvider = { <EOL> provide : WindowRef , <EOL> useClass : BrowserWindowRef , <EOL> } ; <EOL> / ** <EOL> * Create an injectable provider that uses the windowFactory <EOL> * function for returning the native window object . <EOL> * / <EOL> const windowProvider = { <EOL> provide : WINDOW , <EOL> useFactory : windowFactory , <EOL> deps : [ WindowRef , PLATFORM_ID ] , <EOL> } ; <EOL> export const WINDOW_PROVIDERS = [ browserWindowProvider , windowProvider ] ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Assign <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . MOVING_FN > ; <EOL> type Arguments = Assign < AggArgs , { <EOL> customMetric   ? : AggExpressionType ; <EOL> } > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , Arguments , Output > ; <EOL> export const aggMovingAvg = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> metricAgg : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customMetric : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> window : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> buckets_path : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> script : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . MOVING_FN , <EOL> params : { <EOL> ... rest , <EOL> customMetric : args . customMetric ? . value , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> TypeData , <EOL> TypePoint , <EOL> TypePointCursor <EOL> } from '<STR_LIT>' ; <EOL> import Board from '<STR_LIT>' ; <EOL> import { <EOL> Helper <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Element <EOL> } from '<STR_LIT>' ; <EOL> const _board = Symbol ( '<STR_LIT>' ) ; <EOL> const _helper = Symbol ( '<STR_LIT>' ) ; <EOL> const _element = Symbol ( '<STR_LIT>' ) ; <EOL> const _opts = Symbol ( '<STR_LIT>' ) ; <EOL> type Options = { <EOL> board : Board ; element : Element ; helper : Helper ; <EOL> } ; <EOL> export class Mapper { <EOL> private [ _opts ] : Options ; <EOL> private [ _board ] : Board ; <EOL> private [ _helper ] : Helper ; <EOL> private [ _element ] : Element ; <EOL> constructor ( opts ) { <EOL> this [ _opts ] = opts ; <EOL> this [ _board ] = this [ _opts ] . board ; <EOL> this [ _element ] = this [ _opts ] . element ; <EOL> this [ _helper ] = this [ _opts ] . helper ; <EOL> } <EOL> isEffectivePoint ( p ) { <EOL> const scrollLineWidth = this [ _board ] . getScrollLineWidth ( ) ; <EOL> const screenInfo = this [ _board ] . getScreenInfo ( ) ; <EOL> if ( p . x <= ( screenInfo . width - scrollLineWidth ) & & p . y <= ( screenInfo . height - scrollLineWidth ) ) { <EOL> return true ; <EOL> } <EOL> return false ; <EOL> } <EOL> judgePointCursor ( p , data ) { <EOL> let cursor = '<STR_LIT>' ; <EOL> let elementUUID = null ; <EOL> if ( ! this . isEffectivePoint ( p ) ) { <EOL> return { <EOL> cursor , <EOL> elementUUID <EOL> } ; <EOL> } <EOL> const { <EOL> uuid , <EOL> hoverControllerDirection <EOL> } = this [ _helper ] . isPointInElementWrapperController ( p , data ) ; <EOL> const direction = hoverControllerDirection ; <EOL> if ( uuid & & direction ) { <EOL> switch ( direction ) { <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> case '<STR_LIT>' : { <EOL> cursor = '<STR_LIT>' ; <EOL> break ; <EOL> } <EOL> default : { <EOL> break ; <EOL> } <EOL> } <EOL> if ( uuid ) { <EOL> elementUUID = uuid ; <EOL> } <EOL> } else { <EOL> const [ index , uuid ] = this [ _element ] . isPointInElement ( p , data ) ; <EOL> if ( index >= <NUM_LIT> ) { <EOL> cursor = '<STR_LIT>' ; <EOL> } <EOL> if ( uuid ) { <EOL> elementUUID = uuid ; <EOL> } <EOL> } <EOL> return { <EOL> cursor , <EOL> elementUUID , <EOL> } ; <EOL> } <EOL> } </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import Heading from '<STR_LIT>' ; <EOL> function Account ( ) { <EOL> return ( < > < Heading > My Account < / Heading > < p > Since you don   ' t come to this page that often , maybe we can lazy load the code for it ! < / p > < / > ) ; } export default Account ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> withOpenSearchDashboards <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> QueryBarTopRowProps <EOL> } from '<STR_LIT>' ; <EOL> import type { <EOL> QueryStringInputProps <EOL> } from '<STR_LIT>' ; <EOL> const Fallback = ( ) = > < div / > ; <EOL> const LazyQueryBarTopRow = React . lazy ( ( ) = > import ( '<STR_LIT>' ) ) ; <EOL> export const QueryBarTopRow = ( props ) = > ( < React . Suspense fallback = { < Fallback / > } > < LazyQueryBarTopRow { ... props } / > < / React . Suspense > ) ; const LazyQueryStringInputUI = withOpenSearchDashboards ( React . lazy ( ( ) = > import ( '<STR_LIT>' ) ) ) ; export const QueryStringInput = ( props ) = > ( < React . Suspense fallback = { < Fallback / > } > < LazyQueryStringInputUI { ... props } / > < / React . Suspense > ) ; export type { QueryStringInputProps } ; </s>
<s> import { <EOL> findFile <EOL> } from "<STR_LIT>" ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> it ( "<STR_LIT>" , async ( ) = > { <EOL> const cwd = process . cwd ( ) ; <EOL> const result = findFile ( cwd , '<STR_LIT>' ) ; <EOL> expect ( result ) . toBeNull ( ) ; <EOL> } ) ; <EOL> } ) ; <EOL> } ) ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> const medianTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export interface AggParamsMedian extends BaseAggParams { <EOL> field : string ; <EOL> } <EOL> export const getMedianMetricAgg = ( ) = > { <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . MEDIAN , <EOL> dslName : '<STR_LIT>' , <EOL> title : medianTitle , <EOL> makeLabel ( aggConfig ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> field : aggConfig . getFieldDisplayName ( ) <EOL> } , <EOL> } ) ; <EOL> } , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : [ OSD_FIELD_TYPES . NUMBER , OSD_FIELD_TYPES . DATE , OSD_FIELD_TYPES . HISTOGRAM ] , <EOL> write ( agg , output ) { <EOL> output . params . field = agg . getParam ( '<STR_LIT>' ) . name ; <EOL> output . params . percents = [ <NUM_LIT> ] ; <EOL> } , <EOL> } , ] , <EOL> getValue ( agg , bucket ) { <EOL> return bucket [ agg . id ] . values [ '<STR_LIT>' ] ; <EOL> } , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> Unit <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> export class InvalidOpenSearchCalendarIntervalError extends Error { <EOL> constructor ( public readonly interval , public readonly value , public readonly unit , public readonly type ) { <EOL> super ( i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> interval <EOL> } , <EOL> } ) ) ; <EOL> this . name = '<STR_LIT>' ; <EOL> this . value = value ; <EOL> this . unit = unit ; <EOL> this . type = type ; <EOL> if ( Error . captureStackTrace ) { <EOL> Error . captureStackTrace ( this , InvalidOpenSearchCalendarIntervalError ) ; <EOL> } <EOL> Object . setPrototypeOf ( this , InvalidOpenSearchCalendarIntervalError . prototype ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> HttpClient <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> GetUserSuccessPayload , <EOL> LoginPayload <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> LoginSuccessPayload , <EOL> LoginSuccessResponse , <EOL> UserInfoResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> urlFactory <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Observable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class AuthDataService { <EOL> readonly endpoints = { <EOL> getAccessToken : urlFactory ( '<STR_LIT>' ) , <EOL> getUser : urlFactory ( '<STR_LIT>' ) <EOL> } ; <EOL> readonly TOKEN_KEY = '<STR_LIT>' ; <EOL> constructor ( private http ) { } <EOL> clearSavedToken ( ) { <EOL> localStorage . removeItem ( this . TOKEN_KEY ) ; <EOL> } <EOL> login ( payload ) { <EOL> return this . http . post < LoginSuccessResponse > ( this . endpoints . getAccessToken . url ( ) , { <EOL> code : payload . code , <EOL> platform : payload . platform <EOL> } ) . pipe ( map ( ( res ) = > res . data ) ) ; <EOL> } <EOL> getToken ( ) { <EOL> return JSON . parse ( localStorage . getItem ( this . TOKEN_KEY ) ) ; <EOL> } <EOL> saveToken ( authToken ) { <EOL> localStorage . setItem ( this . TOKEN_KEY , JSON . stringify ( authToken ) ) ; <EOL> } <EOL> getUser ( ) { <EOL> return this . http . get < UserInfoResponse > ( this . endpoints . getUser . url ( ) ) . pipe ( map ( ( res ) = > ( { <EOL> data : res . data <EOL> } ) ) ) ; <EOL> } <EOL> } </s>
<s> import "<STR_LIT>" ; <EOL> import { <EOL> Red <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Counter , <EOL> peer , <EOL> sleep <EOL> } from "<STR_LIT>" ; <EOL> describe ( "<STR_LIT>" , ( ) = > { <EOL> const receiverTransform = ( receiver , expectPT , done ) = > { <EOL> const receiverStreams = ( receiver as any ) . createEncodedStreams ( ) ; <EOL> const readableStream = receiverStreams . readable ; <EOL> const writableStream = receiverStreams . writable ; <EOL> const counter = new Counter ( <NUM_LIT> , done ) ; <EOL> let count = <NUM_LIT> ; <EOL> const transformStream = new TransformStream ( { <EOL> transform : ( encodedFrame , controller ) = > { <EOL> const data = encodedFrame . data ; <EOL> const red = Red . deSerialize ( Buffer . from ( data ) ) ; <EOL> expect ( red . payloads . length ) . toBe ( count ) ; <EOL> if ( count < <NUM_LIT> ) { <EOL> count + + ; <EOL> } <EOL> for ( const payload of red . payloads ) { <EOL> expect ( payload . blockPT ) . toBe ( expectPT ) ; <EOL> } <EOL> if ( count == = <NUM_LIT> ) { <EOL> counter . done ( ) ; <EOL> } <EOL> controller . enqueue ( encodedFrame ) ; <EOL> } , <EOL> } ) ; <EOL> readableStream . pipeThrough ( transformStream ) . pipeTo ( writableStream ) ; <EOL> } ; <EOL> const mediachannel_red_client_answer = "<STR_LIT>" ; <EOL> it ( mediachannel_red_client_answer , async ( ) = > new Promise < void > ( async ( done ) = > { <EOL> if ( ! peer . connected ) await new Promise < void > ( ( r ) = > peer . on ( "<STR_LIT>" , r ) ) ; <EOL> await sleep ( <NUM_LIT> ) ; <EOL> const pc = new RTCPeerConnection ( { <EOL> encodedInsertableStreams : true , <EOL> iceServers : [ { <EOL> urls : "<STR_LIT>" <EOL> } ] , <EOL> } ) ; <EOL> pc . onicecandidate = ( { <EOL> candidate <EOL> } ) = > { <EOL> peer . request ( mediachannel_red_client_answer , { <EOL> type : "<STR_LIT>" , <EOL> payload : candidate , <EOL> } ) . catch ( ( ) = > { } ) ; <EOL> } ; <EOL> pc . ontrack = async ( ev ) = > { <EOL> const receiver = ev . receiver ; <EOL> receiverTransform ( receiver , <NUM_LIT> , ( ) = > { <EOL> pc . close ( ) ; <EOL> done ( ) ; <EOL> } ) ; <EOL> } ; <EOL> const offer = await peer . request ( mediachannel_red_client_answer , { <EOL> type : "<STR_LIT>" , <EOL> } ) ; <EOL> await pc . setRemoteDescription ( offer ) ; <EOL> await pc . setLocalDescription ( await pc . createAnswer ( ) ) ; <EOL> peer . request ( mediachannel_red_client_answer , { <EOL> type : "<STR_LIT>" , <EOL> payload : pc . localDescription , <EOL> } ) . catch ( ( ) = > { } ) ; <EOL> } ) , <NUM_LIT> * <NUM_LIT> ) ; <EOL> const mediachannel_red_client_offer = "<STR_LIT>" ; <EOL> it ( mediachannel_red_client_offer , async ( ) = > new Promise < void > ( async ( done ) = > { <EOL> if ( ! peer . connected ) await new Promise < void > ( ( r ) = > peer . on ( "<STR_LIT>" , r ) ) ; <EOL> await sleep ( <NUM_LIT> ) ; <EOL> await peer . request ( mediachannel_red_client_offer , { <EOL> type : "<STR_LIT>" <EOL> } ) ; <EOL> const pc = new RTCPeerConnection ( { <EOL> encodedInsertableStreams : true , <EOL> iceServers : [ { <EOL> urls : "<STR_LIT>" <EOL> } ] , <EOL> } ) ; <EOL> pc . ontrack = async ( ev ) = > { <EOL> const receiver = ev . receiver ; <EOL> receiverTransform ( receiver , <NUM_LIT> , ( ) = > { <EOL> pc . close ( ) ; <EOL> done ( ) ; <EOL> } ) ; <EOL> } ; <EOL> pc . onicecandidate = ( { <EOL> candidate <EOL> } ) = > { <EOL> peer . request ( mediachannel_red_client_offer , { <EOL> type : "<STR_LIT>" , <EOL> payload : candidate , <EOL> } ) . catch ( ( ) = > { } ) ; <EOL> } ; <EOL> const transceiver = pc . addTransceiver ( "<STR_LIT>" , { <EOL> direction : "<STR_LIT>" , <EOL> } ) ; <EOL> const { <EOL> codecs <EOL> } = RTCRtpSender . getCapabilities ( "<STR_LIT>" )   ! ; <EOL> ( transceiver as any ) . setCodecPreferences ( [ codecs . find ( ( c ) = > c . mimeType . includes ( "<STR_LIT>" ) ) , ... codecs , ] ) ; <EOL> await pc . setLocalDescription ( await pc . createOffer ( ) ) ; <EOL> const answer = await peer . request ( mediachannel_red_client_offer , { <EOL> type : "<STR_LIT>" , <EOL> payload : pc . localDescription , <EOL> } ) ; <EOL> await pc . setRemoteDescription ( answer ) ; <EOL> } ) , <NUM_LIT> * <NUM_LIT> ) ; <EOL> } ) ; </s>
<s> import type { <EOL> ParsingExtension <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AppConfigError <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> named , <EOL> forKey , <EOL> keysToPath , <EOL> validateOptions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> currentEnvFromContext , <EOL> defaultAliases , <EOL> asEnvOptions , <EOL> EnvironmentAliases , <EOL> } from '<STR_LIT>' ; / ** Looks up an environment - specific value ( $ env ) * / <EOL> export function envDirective ( aliases = defaultAliases , environmentOverride   ? , environmentSourceNames   ? ) { <EOL> const metadata = { <EOL> shouldOverride : true <EOL> } ; <EOL> return named ( '<STR_LIT>' , forKey ( '<STR_LIT>' , validateOptions ( ( SchemaBuilder ) = > SchemaBuilder . emptySchema ( ) . addAdditionalProperties ( ) , ( value , _ , parentKeys , context ) = > ( parse ) = > { <EOL> const environment = currentEnvFromContext ( context , asEnvOptions ( environmentOverride , aliases , environmentSourceNames ) ) ; <EOL> if ( ! environment ) { <EOL> if ( '<STR_LIT>' in value ) { <EOL> return parse ( value . none , metadata ) ; <EOL> } <EOL> if ( '<STR_LIT>' in value ) { <EOL> return parse ( value . default , metadata ) ; <EOL> } <EOL> const path = keysToPath ( parentKeys ) ; <EOL> throw new AppConfigError ( ` An   $ env directive was used ( in   $ { path } ) , but current environment ( eg . NODE_ENV ) is undefined ` ) ; <EOL> } <EOL> for ( const [ envName , envValue ] of Object . entries ( value ) ) { <EOL> if ( envName == = environment | | aliases [ envName ] == = environment ) { <EOL> return parse ( envValue , metadata ) ; <EOL> } <EOL> } <EOL> if ( '<STR_LIT>' in value ) { <EOL> return parse ( value . default , metadata ) ; <EOL> } <EOL> const found = Object . keys ( value ) . join ( '<STR_LIT>' ) ; <EOL> const path = keysToPath ( parentKeys ) ; <EOL> throw new AppConfigError ( ` An   $ env directive was used ( in   $ { path } ) , but none matched the current environment ( wanted   $ { environment } , saw [ $ { found } ] ) ` ) ; <EOL> } , { <EOL> lazy : true <EOL> } ) ) ) ; <EOL> } </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage , <EOL> I18nProvider <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiCallOut , <EOL> EuiLink , <EOL> EuiLoadingSpinner , <EOL> EuiPageContent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternsContract <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OpenSearchRequestState , <EOL> useOpenSearchDocSearch <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DocViewer <EOL> } from '<STR_LIT>' ; <EOL> export interface DocProps { <EOL> / ** <EOL> * Id of the doc in OpenSearch <EOL> * / <EOL> id : string ; <EOL> / ** <EOL> * Index in OpenSearch to query <EOL> * / <EOL> index : string ; <EOL> / ** <EOL> * IndexPattern ID used to get IndexPattern entity <EOL> * that ' s used for adding additional fields ( stored_fields , script_fields , docvalue_fields ) <EOL> * / <EOL> indexPatternId : string ; <EOL> / ** <EOL> * IndexPatternService to get a given index pattern by ID <EOL> * / <EOL> indexPatternService : IndexPatternsContract ; <EOL> } <EOL> export function Doc ( props ) { <EOL> const [ reqState , hit , indexPattern ] = useOpenSearchDocSearch ( props ) ; <EOL> return ( < I18nProvider > < EuiPageContent > { reqState == = OpenSearchRequestState . NotFoundIndexPattern & & ( < EuiCallOut color = "<STR_LIT>" data - test - subj = {   ` doc - msg - notFoundIndexPattern ` } iconType = "<STR_LIT>" title = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { indexPatternId : props . indexPatternId } } / > } / > ) } { reqState == = OpenSearchRequestState . NotFound & & ( < EuiCallOut color = "<STR_LIT>" data - test - subj = {   ` doc - msg - notFound ` } iconType = "<STR_LIT>" title = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > } > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiCallOut > ) } { reqState == = OpenSearchRequestState . Error & & ( < EuiCallOut color = "<STR_LIT>" data - test - subj = {   ` doc - msg - error ` } iconType = "<STR_LIT>" title = { < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > } > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { indexName : props . index } } / > { '<STR_LIT>' } < EuiLink href = {   ` https : // opensearch . org / docs / latest / opensearch / rest - api / index - apis / exists / ` } target = "<STR_LIT>" > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiLink > < / EuiCallOut > ) } { reqState == = OpenSearchRequestState . Loading & & ( < EuiCallOut data - test - subj = {   ` doc - msg - loading ` } > < EuiLoadingSpinner size = "<STR_LIT>" / > { '<STR_LIT>' } < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiCallOut > ) } { reqState == = OpenSearchRequestState . Found & & hit != = null & & indexPattern & & ( < div data - test - subj = "<STR_LIT>" > < DocViewer hit = { hit } indexPattern = { indexPattern } / > < / div > ) } < / EuiPageContent > < / I18nProvider > ) ; } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggExpressionType , <EOL> AggExpressionFunctionArgs , <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getParsedValue <EOL> } from '<STR_LIT>' ; <EOL> const fnName = '<STR_LIT>' ; <EOL> type Input = any ; <EOL> type AggArgs = AggExpressionFunctionArgs < typeof METRIC_TYPES . MIN > ; <EOL> type Output = AggExpressionType ; <EOL> type FunctionDefinition = ExpressionFunctionDefinition < typeof fnName , Input , AggArgs , Output > ; <EOL> export const aggMin = ( ) : FunctionDefinition = > ( { <EOL> name : fnName , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> type : '<STR_LIT>' , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> enabled : { <EOL> types : [ '<STR_LIT>' ] , <EOL> default : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> schema : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> field : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> json : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> customLabel : { <EOL> types : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> fn : ( input , args ) = > { <EOL> const { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> ... rest <EOL> } = args ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : { <EOL> id , <EOL> enabled , <EOL> schema , <EOL> type : METRIC_TYPES . MIN , <EOL> params : { <EOL> ... rest , <EOL> json : getParsedValue ( args , '<STR_LIT>' ) , <EOL> } , <EOL> } , <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parentPipelineAggHelper <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> makeNestedLabel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggConfigSerialized , <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsCumulativeSum extends BaseAggParams { <EOL> buckets_path : string ; customMetric   ? : AggConfigSerialized ; metricAgg   ? : string ; <EOL> } <EOL> const cumulativeSumLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const cumulativeSumTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export const getCumulativeSumMetricAgg = ( ) = > { <EOL> const { <EOL> subtype , <EOL> params , <EOL> getSerializedFormat <EOL> } = parentPipelineAggHelper ; <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . CUMULATIVE_SUM , <EOL> title : cumulativeSumTitle , <EOL> makeLabel : ( agg ) = > makeNestedLabel ( agg , cumulativeSumLabel ) , <EOL> subtype , <EOL> params : [ ... params ( ) ] , <EOL> getSerializedFormat , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> CoreSetup <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getUrlIdFromGotoRoute , <EOL> getUrlPath , <EOL> GOTO_PREFIX <EOL> } from '<STR_LIT>' ; <EOL> export const createShortUrlRedirectApp = ( core , location ) = > ( { <EOL> id : '<STR_LIT>' , <EOL> appRoute : GOTO_PREFIX , <EOL> chromeless : true , <EOL> title : '<STR_LIT>' , <EOL> async mount ( ) { <EOL> const urlId = getUrlIdFromGotoRoute ( location . pathname ) ; <EOL> if ( ! urlId ) { <EOL> throw new Error ( '<STR_LIT>' ) ; <EOL> } <EOL> const response = await core . http . get < { <EOL> url : string ; <EOL> } > ( getUrlPath ( urlId ) ) ; <EOL> const redirectUrl = response . url ; <EOL> const { <EOL> hashUrl <EOL> } = await import ( '<STR_LIT>' ) ; <EOL> const hashedUrl = hashUrl ( redirectUrl ) ; <EOL> const url = core . http . basePath . prepend ( hashedUrl ) ; <EOL> location . href = url ; <EOL> return ( ) = > { } ; <EOL> } , <EOL> } ) ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> makeNestedLabel <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> siblingPipelineAggHelper <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggConfigSerialized , <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> export interface AggParamsBucketMax extends BaseAggParams { <EOL> customMetric   ? : AggConfigSerialized ; <EOL> customBucket   ? : AggConfigSerialized ; <EOL> } <EOL> const overallMaxLabel = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const maxBucketTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export const getBucketMaxMetricAgg = ( ) = > { <EOL> const { <EOL> subtype , <EOL> params , <EOL> getSerializedFormat <EOL> } = siblingPipelineAggHelper ; <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . MAX_BUCKET , <EOL> title : maxBucketTitle , <EOL> makeLabel : ( agg ) = > makeNestedLabel ( agg , overallMaxLabel ) , <EOL> subtype , <EOL> params : [ ... params ( ) ] , <EOL> getSerializedFormat , <EOL> } ) ; <EOL> } ; </s>
<s> import '<STR_LIT>' ; <EOL> import React , { <EOL> useState , <EOL> useMemo , <EOL> useCallback <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiFormRow , <EOL> EuiIconTip , <EOL> EuiCodeEditor , <EOL> EuiScreenReaderOnly <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggParamEditorProps <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> function RawJsonParamEditor ( { <EOL> showValidation , <EOL> value = '<STR_LIT>' , <EOL> setValidity , <EOL> setValue , <EOL> setTouched , <EOL> } ) { <EOL> const [ isFieldValid , setFieldValidity ] = useState ( true ) ; <EOL> const [ editorReady , setEditorReady ] = useState ( false ) ; <EOL> const editorTooltipText = useMemo ( ( ) = > i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : "<STR_LIT>" , <EOL> } ) , [ ] ) ; <EOL> const jsonEditorLabelText = useMemo ( ( ) = > i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , [ ] ) ; <EOL> const label = useMemo ( ( ) = > ( < > { jsonEditorLabelText } { '<STR_LIT>' } < EuiIconTip position = "<STR_LIT>" content = { editorTooltipText } type = "<STR_LIT>" / > < / > ) , [ jsonEditorLabelText , editorTooltipText ] ) ; const onEditorValidate = useCallback ( ( annotations ) = > { if ( editorReady ) { const validity = annotations . length == = <NUM_LIT> ; setFieldValidity ( validity ) ; setValidity ( validity ) ; } else { setEditorReady ( true ) ; } } , [ setValidity , editorReady ] ) ; return ( < EuiFormRow label = { label } isInvalid = { showValidation   ?   ! isFieldValid : false } fullWidth = { true } compressed > < > < EuiCodeEditor mode = "<STR_LIT>" theme = "<STR_LIT>" width = "<STR_LIT>" height = "<STR_LIT>" value = { value } onValidate = { onEditorValidate } setOptions = { { fontSize : '<STR_LIT>' , } } onChange = { setValue } onBlur = { setTouched } aria - label = { jsonEditorLabelText } aria - describedby = "<STR_LIT>" / > < EuiScreenReaderOnly > < p id = "<STR_LIT>" > { editorTooltipText } < / p > < / EuiScreenReaderOnly > < / > < / EuiFormRow > ) ; } export { RawJsonParamEditor } ; </s>
<s> import React , { <EOL> useCallback <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiFieldText , <EOL> EuiFlexItem <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> InputList , <EOL> InputListConfig , <EOL> InputObject , <EOL> InputModel , <EOL> InputItem <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> search <EOL> } from '<STR_LIT>' ; <EOL> const EMPTY_STRING = '<STR_LIT>' ; <EOL> export interface MaskObject extends InputObject { <EOL> mask   ? : string ; <EOL> } <EOL> type MaskModel = InputModel & { <EOL> mask : InputItem ; <EOL> } ; <EOL> interface MaskListProps { <EOL> list : MaskObject [ ] ; showValidation : boolean ; onBlur ( ) : void ; onChange ( list ) : void ; setValidity ( isValid ) : void ; <EOL> } <EOL> const defaultConfig = { <EOL> defaultValue : { <EOL> mask : { <EOL> model : '<STR_LIT>' , <EOL> value : '<STR_LIT>' , <EOL> isInvalid : false <EOL> } , <EOL> } , <EOL> validateClass : search . aggs . CidrMask , <EOL> getModelValue : ( item = { } ) = > ( { <EOL> mask : { <EOL> model : item . mask | | EMPTY_STRING , <EOL> value : item . mask | | EMPTY_STRING , <EOL> isInvalid : false , <EOL> } , <EOL> } ) , <EOL> getRemoveBtnAriaLabel : ( item ) = > item . mask . value   ? i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> mask : item . mask . value <EOL> } , <EOL> } ) : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> onChangeFn : ( { <EOL> mask <EOL> } ) = > { <EOL> if ( mask . model ) { <EOL> return { <EOL> mask : mask . model <EOL> } ; <EOL> } <EOL> return { } ; <EOL> } , <EOL> hasInvalidValuesFn : ( { <EOL> mask <EOL> } ) = > mask . isInvalid , <EOL> modelNames : '<STR_LIT>' , <EOL> } ; <EOL> function MaskList ( { <EOL> showValidation , <EOL> onBlur , <EOL> ... rest <EOL> } ) { <EOL> const renderInputRow = useCallback ( ( { <EOL> mask <EOL> } , index , onChangeValue ) = > ( < EuiFlexItem > < EuiFieldText aria - label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , values : { mask : mask . value | | '<STR_LIT>' } , } ) } compressed fullWidth isInvalid = { showValidation   ? mask . isInvalid : false } placeholder = "<STR_LIT>" onChange = { ( ev ) = > { onChangeValue ( index , ev . target . value , '<STR_LIT>' ) ; } } value = { mask . value } onBlur = { onBlur } / > < / EuiFlexItem > ) , [ onBlur , showValidation ] ) ; const maskListConfig = { ... defaultConfig , renderInputRow , } ; return < InputList config = { maskListConfig } { ... rest } / > ; } export { MaskList } ; </s>
<s> / ** <EOL> * This helper automatically handles matching pairs . <EOL> * Specifically , it does the following : <EOL> * <EOL> * <NUM_LIT> If the key is a closer , and the character in front of the cursor is the <EOL> * same , simply move the cursor forward . <EOL> * <NUM_LIT> If the key is an opener , insert the opener at the beginning of the <EOL> * selection , and the closer at the end of the selection , and move the <EOL> * selection forward . <EOL> * <NUM_LIT> If the backspace is hit , and the characters before and after the cursor <EOL> * are a pair , remove both characters and move the cursor backward . <EOL> * / <EOL> const pairs = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ,   ` '<STR_LIT>' ` , '<STR_LIT>' ] ; <EOL> const openers = pairs . map ( ( pair ) = > pair [ <NUM_LIT> ] ) ; <EOL> const closers = pairs . map ( ( pair ) = > pair [ <NUM_LIT> ] ) ; <EOL> interface MatchPairsOptions { <EOL> value : string ; selectionStart : number ; selectionEnd : number ; key : string ; metaKey : boolean ; updateQuery : ( query : string , selectionStart : number , selectionEnd : number ) = > void ; preventDefault : ( ) = > void ; <EOL> } <EOL> export function matchPairs ( { <EOL> value , <EOL> selectionStart , <EOL> selectionEnd , <EOL> key , <EOL> metaKey , <EOL> updateQuery , <EOL> preventDefault , <EOL> } ) { <EOL> if ( shouldMoveCursorForward ( key , value , selectionStart , selectionEnd ) ) { <EOL> preventDefault ( ) ; <EOL> updateQuery ( value , selectionStart + <NUM_LIT> , selectionEnd + <NUM_LIT> ) ; <EOL> } else if ( shouldInsertMatchingCloser ( key , value , selectionStart , selectionEnd ) ) { <EOL> preventDefault ( ) ; <EOL> const newValue = value . substr ( <NUM_LIT> , selectionStart ) + key + value . substring ( selectionStart , selectionEnd ) + closers [ openers . indexOf ( key ) ] + value . substr ( selectionEnd ) ; <EOL> updateQuery ( newValue , selectionStart + <NUM_LIT> , selectionEnd + <NUM_LIT> ) ; <EOL> } else if ( shouldRemovePair ( key , metaKey , value , selectionStart , selectionEnd ) ) { <EOL> preventDefault ( ) ; <EOL> const newValue = value . substr ( <NUM_LIT> , selectionEnd - <NUM_LIT> ) + value . substr ( selectionEnd + <NUM_LIT> ) ; <EOL> updateQuery ( newValue , selectionStart - <NUM_LIT> , selectionEnd - <NUM_LIT> ) ; <EOL> } <EOL> } <EOL> function shouldMoveCursorForward ( key , value , selectionStart , selectionEnd ) { <EOL> if ( ! closers . includes ( key ) ) { <EOL> return false ; <EOL> } <EOL> if ( selectionStart != = selectionEnd ) { <EOL> return false ; <EOL> } <EOL> return value . charAt ( selectionEnd ) == = key ; <EOL> } <EOL> function shouldInsertMatchingCloser ( key , value , selectionStart , selectionEnd ) { <EOL> if ( ! openers . includes ( key ) ) { <EOL> return false ; <EOL> } <EOL> if ( selectionStart != = selectionEnd ) { <EOL> return true ; <EOL> } <EOL> const precedingCharacter = value . charAt ( selectionStart - <NUM_LIT> ) ; <EOL> const followingCharacter = value . charAt ( selectionStart + <NUM_LIT> ) ; <EOL> if ( precedingCharacter == = '<STR_LIT>' ) { <EOL> return false ; <EOL> } <EOL> return   ! ( [ '<STR_LIT>' ,   ` ' ` ] . includes ( key ) & & ( isAlphanumeric ( precedingCharacter ) | | isAlphanumeric ( followingCharacter ) ) ) ; <EOL> } <EOL> function shouldRemovePair ( key , metaKey , value , selectionStart , selectionEnd ) { <EOL> if ( key != = '<STR_LIT>' | | metaKey ) { <EOL> return false ; <EOL> } <EOL> if ( selectionStart != = selectionEnd ) { <EOL> return false ; <EOL> } <EOL> return pairs . includes ( value . substr ( selectionEnd - <NUM_LIT> , <NUM_LIT> ) ) ; <EOL> } <EOL> function isAlphanumeric ( value = '<STR_LIT>' ) { <EOL> return value . match ( / [ a - zA - Z0 - <NUM_LIT> _ ] / ) ; <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> const minTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export interface AggParamsMin extends BaseAggParams { <EOL> field : string ; <EOL> } <EOL> export const getMinMetricAgg = ( ) = > { <EOL> return new MetricAggType ( { <EOL> name : METRIC_TYPES . MIN , <EOL> title : minTitle , <EOL> makeLabel ( aggConfig ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> field : aggConfig . getFieldDisplayName ( ) <EOL> } , <EOL> } ) ; <EOL> } , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : [ OSD_FIELD_TYPES . NUMBER , OSD_FIELD_TYPES . DATE ] , <EOL> } , ] , <EOL> } ) ; <EOL> } ; </s>
<s> import { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' <EOL> } ) export class LeafletDemoComponent { <EOL> showDemo = false ; <EOL> ngOnInit ( ) { <EOL> setTimeout ( ( ) = > { <EOL> this . showDemo = true ; <EOL> } , <NUM_LIT> ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MatSnackBar <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MatSnackBarRef <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SimpleSnackBar <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class SnackBarService { <EOL> public static readonly durationShort = <NUM_LIT> ; <EOL> public static readonly durationLong = <NUM_LIT> ; <EOL> public static readonly defaultDuration = <NUM_LIT> ; <EOL> private defaultAction = '<STR_LIT>' ; <EOL> param { <EOL> MatSnackBar <EOL> } <EOL> matSnackBar constructor ( private matSnackBar ) { } <EOL> param defaultAction setDefaultAction ( defaultAction ) { <EOL> this . defaultAction = defaultAction ; <EOL> } <EOL> param { <EOL> string <EOL> } <EOL> message param { <EOL> number <EOL> } <EOL> duration returns { <EOL> MatSnackBarRef < SimpleSnackBar > <EOL> } <EOL> open ( message , duration = SnackBarService . defaultDuration ) { <EOL> return this . matSnackBar . open ( message , this . defaultAction , { <EOL> duration : duration <EOL> } ) ; <EOL> } <EOL> param { <EOL> string <EOL> } <EOL> message returns { <EOL> MatSnackBarRef < SimpleSnackBar > <EOL> } <EOL> openShort ( message ) { <EOL> return this . open ( message , SnackBarService . durationShort ) ; <EOL> } <EOL> param { <EOL> string <EOL> } <EOL> message returns { <EOL> MatSnackBarRef < SimpleSnackBar > <EOL> } <EOL> openLong ( message ) { <EOL> return this . open ( message , SnackBarService . durationLong ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> IBufferView , <EOL> AccessorType , <EOL> AccessorComponentType , <EOL> IAccessor <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> FloatArray , <EOL> Nullable <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> Vector3 , <EOL> Vector4 , <EOL> Quaternion <EOL> } from "<STR_LIT>" ; <EOL> hidden <EOL> export class _GLTFUtilities { <EOL> param bufferIndex param byteOffset param byteLength param byteStride param name returns public static _CreateBufferView ( bufferIndex , byteOffset , byteLength , byteStride   ? , name   ? ) { <EOL> let bufferview = { <EOL> buffer : bufferIndex , <EOL> byteLength : byteLength <EOL> } ; <EOL> if ( byteOffset ) { <EOL> bufferview . byteOffset = byteOffset ; <EOL> } <EOL> if ( name ) { <EOL> bufferview . name = name ; <EOL> } <EOL> if ( byteStride ) { <EOL> bufferview . byteStride = byteStride ; <EOL> } <EOL> return bufferview ; <EOL> } <EOL> param bufferviewIndex param name param type param componentType param count param byteOffset param min param max returns public static _CreateAccessor ( bufferviewIndex , name , type , componentType , count , byteOffset , min , max ) { <EOL> let accessor = { <EOL> name : name , <EOL> bufferView : bufferviewIndex , <EOL> componentType : componentType , <EOL> count : count , <EOL> type : type <EOL> } ; <EOL> if ( min != null ) { <EOL> accessor . min = min ; <EOL> } <EOL> if ( max != null ) { <EOL> accessor . max = max ; <EOL> } <EOL> if ( byteOffset != null ) { <EOL> accessor . byteOffset = byteOffset ; <EOL> } <EOL> return accessor ; <EOL> } <EOL> param positions param vertexStart param vertexCount returns public static _CalculateMinMaxPositions ( positions , vertexStart , vertexCount , convertToRightHandedSystem ) { <EOL> const min = [ Infinity , Infinity , Infinity ] ; <EOL> const max = [ - Infinity , - Infinity , - Infinity ] ; <EOL> const positionStrideSize = <NUM_LIT> ; <EOL> let indexOffset ; <EOL> let position ; <EOL> let vector ; <EOL> if ( vertexCount ) { <EOL> for ( let i = vertexStart , length = vertexStart + vertexCount ; i < length ; + + i ) { <EOL> indexOffset = positionStrideSize * i ; <EOL> position = Vector3 . FromArray ( positions , indexOffset ) ; <EOL> if ( convertToRightHandedSystem ) { <EOL> _GLTFUtilities . _GetRightHandedPositionVector3FromRef ( position ) ; <EOL> } <EOL> vector = position . asArray ( ) ; <EOL> for ( let j = <NUM_LIT> ; j < positionStrideSize ; + + j ) { <EOL> let num = vector [ j ] ; <EOL> if ( num < min [ j ] ) { <EOL> min [ j ] = num ; <EOL> } <EOL> if ( num > max [ j ] ) { <EOL> max [ j ] = num ; <EOL> } + + indexOffset ; <EOL> } <EOL> } <EOL> } <EOL> return { <EOL> min , <EOL> max <EOL> } ; <EOL> } <EOL> param vector returns public static _GetRightHandedPositionVector3 ( vector ) { <EOL> return new Vector3 ( vector . x , vector . y , - vector . z ) ; <EOL> } <EOL> param vector public static _GetRightHandedPositionVector3FromRef ( vector ) { <EOL> vector . z *= - <NUM_LIT> ; <EOL> } <EOL> param vector public static _GetRightHandedPositionArray3FromRef ( vector ) { <EOL> vector [ <NUM_LIT> ] *= - <NUM_LIT> ; <EOL> } <EOL> param vector returns public static _GetRightHandedNormalVector3 ( vector ) { <EOL> return new Vector3 ( vector . x , vector . y , - vector . z ) ; <EOL> } <EOL> param vector public static _GetRightHandedNormalVector3FromRef ( vector ) { <EOL> vector . z *= - <NUM_LIT> ; <EOL> } <EOL> param vector public static _GetRightHandedNormalArray3FromRef ( vector ) { <EOL> vector [ <NUM_LIT> ] *= - <NUM_LIT> ; <EOL> } <EOL> param vector public static _GetRightHandedVector4FromRef ( vector ) { <EOL> vector . z *= - <NUM_LIT> ; <EOL> vector . w *= - <NUM_LIT> ; <EOL> } <EOL> param vector public static _GetRightHandedArray4FromRef ( vector ) { <EOL> vector [ <NUM_LIT> ] *= - <NUM_LIT> ; <EOL> vector [ <NUM_LIT> ] *= - <NUM_LIT> ; <EOL> } <EOL> param quaternion public static _GetRightHandedQuaternionFromRef ( quaternion ) { <EOL> quaternion . x *= - <NUM_LIT> ; <EOL> quaternion . y *= - <NUM_LIT> ; <EOL> } <EOL> param quaternion public static _GetRightHandedQuaternionArrayFromRef ( quaternion ) { <EOL> quaternion [ <NUM_LIT> ] *= - <NUM_LIT> ; <EOL> quaternion [ <NUM_LIT> ] *= - <NUM_LIT> ; <EOL> } <EOL> public static _NormalizeTangentFromRef ( tangent ) { <EOL> const length = Math . sqrt ( tangent . x * tangent . x + tangent . y * tangent . y + tangent . z * tangent . z ) ; <EOL> if ( length > <NUM_LIT> ) { <EOL> tangent . x /= length ; <EOL> tangent . y /= length ; <EOL> tangent . z /= length ; <EOL> } <EOL> } <EOL> public static _GetDataAccessorElementCount ( accessorType ) { <EOL> switch ( accessorType ) { <EOL> case AccessorType . MAT2 : <EOL> return <NUM_LIT> ; <EOL> case AccessorType . MAT3 : <EOL> return <NUM_LIT> ; <EOL> case AccessorType . MAT4 : <EOL> return <NUM_LIT> ; <EOL> case AccessorType . SCALAR : <EOL> return <NUM_LIT> ; <EOL> case AccessorType . VEC2 : <EOL> return <NUM_LIT> ; <EOL> case AccessorType . VEC3 : <EOL> return <NUM_LIT> ; <EOL> case AccessorType . VEC4 : <EOL> return <NUM_LIT> ; <EOL> } <EOL> } <EOL> } </s>
<s> import { <EOL> ExpressionAstExpression <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> format <EOL> } from '<STR_LIT>' ; <EOL> param ast <EOL> export function formatExpression ( ast ) { <EOL> return format ( ast , '<STR_LIT>' ) ; <EOL> } </s>
<s> import { <EOL> OpenSearchQuerySortValue , <EOL> IndexPattern <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SortOrder <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getSort <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getDefaultSort <EOL> } from '<STR_LIT>' ; <EOL> / ** <EOL> * Prepares sort for search source , that ' s sending the request to OpenSearch <EOL> * - Adds default sort if necessary <EOL> * - Handles the special case when there ' s sorting by date_nanos typed fields <EOL> * the addon of the numeric_type guarantees the right sort order <EOL> * when there are indices with date and indices with date_nanos field <EOL> * / <EOL> export function getSortForSearchSource ( sort   ? , indexPattern   ? , defaultDirection = '<STR_LIT>' ) { <EOL> if ( ! sort | |   ! indexPattern ) { <EOL> return [ ] ; <EOL> } else if ( Array . isArray ( sort ) & & sort . length == = <NUM_LIT> ) { <EOL> sort = getDefaultSort ( indexPattern , defaultDirection ) ; <EOL> } <EOL> const { <EOL> timeFieldName <EOL> } = indexPattern ; <EOL> return getSort ( sort , indexPattern ) . map ( ( sortPair ) = > { <EOL> if ( indexPattern . isTimeNanosBased ( ) & & timeFieldName & & sortPair [ timeFieldName ] ) { <EOL> return { <EOL> [ timeFieldName ] : { <EOL> order : sortPair [ timeFieldName ] , <EOL> numeric_type : '<STR_LIT>' , <EOL> } , <EOL> } <EOL> as OpenSearchQuerySortValue ; <EOL> } <EOL> return sortPair as OpenSearchQuerySortValue ; <EOL> } ) ; <EOL> } </s>
<s> import { <EOL> Body , <EOL> Controller , <EOL> Post <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Interval <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AppService <EOL> } from '<STR_LIT>' ; <EOL> import * as cheerio from '<STR_LIT>' ; <EOL> import got from '<STR_LIT>' ; <EOL> @ Controller ( ) export class AppController { <EOL> constructor ( private readonly appService ) { } <EOL> @ Post ( '<STR_LIT>' ) async getUpdates ( @ Body ( ) body ) { <EOL> const { <EOL> message <EOL> } = body ; <EOL> if ( message ) { <EOL> const { <EOL> text , <EOL> chat <EOL> } = message ; <EOL> if ( text == = '<STR_LIT>' ) { <EOL> await this . appService . sendMessage ( '<STR_LIT>' , chat . id ) ; <EOL> const chatIds = await this . appService . getChatIds ( ) ; <EOL> if ( chatIds != = null ) { <EOL> if ( ! chatIds . includes ( chat . id ) ) await this . appService . addChatId ( chat . id ) ; <EOL> } <EOL> } else { <EOL> await this . appService . sendMessage ( '<STR_LIT>' , chat . id ) ; <EOL> } <EOL> } <EOL> } <EOL> @ Interval ( <NUM_LIT> ) async scrape ( ) { <EOL> const chatIds = await this . appService . getChatIds ( ) ; <EOL> const lastSeen = await this . appService . getLastSeen ( ) ; <EOL> const response = await got ( '<STR_LIT>' ) ; <EOL> const   $ = cheerio . load ( response . body ) ; <EOL> let lastStock = <NUM_LIT> ; <EOL>                 $ ( '<STR_LIT>' ) . each ( ( i , item ) = > { <EOL>                         $ ( '<STR_LIT>' , item ) . each ( async ( i , item ) = > { <EOL> let trade = '<STR_LIT>' ; <EOL>                                 $ ( '<STR_LIT>' , item ) . each ( ( i , item ) = > { <EOL> trade +=   ` $ {   $ ( item ) . text ( ) . trim ( ) } | ` ; <EOL> } ) ; <EOL> const [ X , fillingDate , tradeDate , ticker , companyName , insiderName , title , tradeType , price , qty , owned , ownUp , value , day , week , month , sixMonths , ] = trade . split ( '<STR_LIT>' ) ; <EOL> const payload = { <EOL> fillingDate , <EOL> tradeDate , <EOL> symbol : ticker , <EOL> companyName , <EOL> insiderName , <EOL> title , <EOL> tradeType , <EOL> price , <EOL> qty : qty . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> value : value . replace ( '<STR_LIT>' , '<STR_LIT>' ) . replace ( '<STR_LIT>' , '<STR_LIT>' ) , <EOL> } ; <EOL> if ( new Date ( fillingDate ) . getTime ( ) > parseInt ( lastSeen ) ) { <EOL> if ( lastStock == = <NUM_LIT> ) { <EOL> lastStock = new Date ( fillingDate ) . getTime ( ) ; <EOL> } <EOL> chatIds . forEach ( async ( id ) = > { <EOL> await this . appService . sendMessage ( ` 🚨 * Insider Trade Alert * 🚨 \ n \ n * Filling Date * :   $ { payload . fillingDate }   \ n * Trade Date * :   $ { payload . tradeDate }   \ n * Ticker * :   $ { payload . symbol }   \ n * Company Name * :   $ { payload . companyName }   \ n * Insider Name * :   $ { payload . insiderName }   \ n * Title * :   $ { payload . title }   \ n * Trade Type * :   ⚠ ️ $ { payload . tradeType } ⚠ ️   \ n * Price * :   $ { payload . price }   \ n * Qty * :   $ { payload . qty } \ n * Value * :   🔥 $ { payload . value } 🔥 \ n ` , id ) ; <EOL> } ) ; <EOL> } <EOL> } ) ; <EOL> } ) ; <EOL> if ( lastStock != = <NUM_LIT> ) { <EOL> this . appService . saveLastSeen ( lastStock + '<STR_LIT>' ) ; <EOL> } <EOL> } <EOL> } </s>
<s> import CharacterSetECI from '<STR_LIT>' ; <EOL> / ** <EOL> * Just to make a shortcut between Java code and TS code . <EOL> * / <EOL> export default class Charset extends CharacterSetECI { <EOL> public static forName ( name ) { <EOL> return this . getCharacterSetECIByName ( name ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Directive , <EOL> HostBinding , <EOL> Input , <EOL> OnInit , <EOL> OnDestroy , <EOL> SimpleChange <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DomSanitizer , <EOL> SafeStyle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IUser <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> User <EOL> } from '<STR_LIT>' ; <EOL> @ Directive ( { <EOL> selector : '<STR_LIT>' <EOL> } ) export class UserImageDirective implements OnInit , OnDestroy { <EOL> @ Input ( '<STR_LIT>' ) user : IUser ; <EOL> @ Input ( '<STR_LIT>' ) size = '<STR_LIT>' ; <EOL> @ HostBinding ( '<STR_LIT>' ) backgroundImage : SafeStyle ; <EOL> @ HostBinding ( '<STR_LIT>' ) width : string ; <EOL> @ HostBinding ( '<STR_LIT>' ) height : string ; <EOL> @ HostBinding ( '<STR_LIT>' ) borderRadius : string ; <EOL> private objectUrl : string ; <EOL> constructor ( private domSanitizer ) { } <EOL> async ngOnChanges ( changes ) { <EOL> for ( const propName in changes ) { <EOL> if ( changes . hasOwnProperty ( propName ) ) { <EOL> const changedProp = changes [ propName ] ; <EOL> this [ propName ] = changedProp . currentValue ; <EOL> } <EOL> } <EOL> await this . updateImage ( ) ; <EOL> } <EOL> async ngOnInit ( ) { <EOL> await this . updateImage ( ) ; <EOL> } <EOL> ngOnDestroy ( ) { <EOL> URL . revokeObjectURL ( this . objectUrl ) ; <EOL> } <EOL> async updateImage ( ) { <EOL> if ( this . user ) { <EOL> this . width = this . size ; <EOL> this . height = this . size ; <EOL> this . borderRadius = '<STR_LIT>' ; <EOL> const user = new User ( this . user ) ; <EOL> const url = user . getUserImageURL ( ) ; <EOL> this . backgroundImage = this . domSanitizer . bypassSecurityTrustStyle ( ` url ( $ { url } ) ` ) ; <EOL> } <EOL> } <EOL> } </s>
<s> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> export type ExpressionFunctionClog = ExpressionFunctionDefinition < '<STR_LIT>' , unknown , { } , unknown > ; <EOL> export const clog = { <EOL> name : '<STR_LIT>' , <EOL> args : { } , <EOL> help : '<STR_LIT>' , <EOL> fn : ( input ) = > { <EOL> console . log ( input ) ; <EOL> return input ; <EOL> } , <EOL> } ; </s>
<s> import React , { <EOL> useState , <EOL> useCallback <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiFormRow <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> NumberList <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AggParamEditorProps <EOL> } from '<STR_LIT>' ; <EOL> function PercentilesEditor ( { <EOL> agg , <EOL> showValidation , <EOL> value = [ ] , <EOL> setTouched , <EOL> setValidity , <EOL> setValue , <EOL> } ) { <EOL> const label = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const [ isValid , setIsValid ] = useState ( true ) ; <EOL> const setModelValidity = useCallback ( ( isListValid ) = > { <EOL> setIsValid ( isListValid ) ; <EOL> setValidity ( isListValid ) ; <EOL> } , [ setValidity ] ) ; <EOL> return ( < EuiFormRow label = { label } labelType = "<STR_LIT>" fullWidth = { true } id = {   ` visEditorPercentileLabel $ { agg . id } ` } isInvalid = { showValidation   ?   ! isValid : false } compressed > < NumberList labelledbyId = {   ` visEditorPercentileLabel $ { agg . id } - legend ` } numberArray = { value } range = "<STR_LIT>" disallowDuplicates = { true } unitName = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } showValidation = { showValidation } onChange = { setValue } setTouched = { setTouched } setValidity = { setModelValidity } / > < / EuiFormRow > ) ; } export { PercentilesEditor } ; </s>
<s> import React , { <EOL> Suspense , <EOL> lazy <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> render , <EOL> unmountComponentAtNode <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EventEmitter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiErrorBoundary , <EOL> EuiLoadingChart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EditorRenderProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Vis , <EOL> VisualizeEmbeddableContract <EOL> } from '<STR_LIT>' ; <EOL> const DefaultEditor = lazy ( ( ) = > import ( '<STR_LIT>' ) ) ; <EOL> class DefaultEditorController { <EOL> constructor ( private el , private vis , private eventEmitter , private embeddableHandler ) { } <EOL> render ( props ) { <EOL> render ( < EuiErrorBoundary > < Suspense fallback = { < div style = { { display : '<STR_LIT>' , flex : '<STR_LIT>' , justifyContent : '<STR_LIT>' , alignItems : '<STR_LIT>' , } } > < EuiLoadingChart size = "<STR_LIT>" mono / > < / div > } > < DefaultEditor eventEmitter = { this . eventEmitter } embeddableHandler = { this . embeddableHandler } vis = { this . vis } { ... props } / > < / Suspense > < / EuiErrorBoundary > , this . el ) ; } destroy ( ) { unmountComponentAtNode ( this . el ) ; } } export { DefaultEditorController } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiToolTip <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SortOrder <EOL> } from '<STR_LIT>' ; <EOL> interface Props { <EOL> colLeftIdx : number ; colRightIdx : number ; displayName : string ; isRemoveable : boolean ; isSortable : boolean ; name : string ; onChangeSortOrder   ? : ( sortOrder : SortOrder [ ] ) = > void ; onMoveColumn   ? : ( name : string , idx : number ) = > void ; onRemoveColumn   ? : ( name : string ) = > void ; sortOrder : SortOrder [ ] ; <EOL> } <EOL> const sortDirectionToIcon = { <EOL> desc : '<STR_LIT>' , <EOL> asc : '<STR_LIT>' , <EOL> '<STR_LIT>' : '<STR_LIT>' , <EOL> } ; <EOL> export function TableHeaderColumn ( { <EOL> colLeftIdx , <EOL> colRightIdx , <EOL> displayName , <EOL> isRemoveable , <EOL> isSortable , <EOL> name , <EOL> onChangeSortOrder , <EOL> onMoveColumn , <EOL> onRemoveColumn , <EOL> sortOrder , <EOL> } ) { <EOL> const [ , sortDirection = '<STR_LIT>' ] = sortOrder . find ( ( sortPair ) = > name == = sortPair [ <NUM_LIT> ] ) | | [ ] ; <EOL> const currentSortWithoutColumn = sortOrder . filter ( ( pair ) = > pair [ <NUM_LIT> ] != = name ) ; <EOL> const currentColumnSort = sortOrder . find ( ( pair ) = > pair [ <NUM_LIT> ] == = name ) ; <EOL> const currentColumnSortDirection = ( currentColumnSort & & currentColumnSort [ <NUM_LIT> ] ) | | '<STR_LIT>' ; <EOL> const btnSortIcon = sortDirectionToIcon [ sortDirection ] ; <EOL> const btnSortClassName = sortDirection != = '<STR_LIT>'   ? btnSortIcon :   ` osdDocTableHeader__sortChange   $ { btnSortIcon } ` ; <EOL> const handleChangeSortOrder = ( ) = > { <EOL> if ( ! onChangeSortOrder ) return ; <EOL> if ( currentColumnSort == = undefined ) { <EOL> onChangeSortOrder ( [ ... currentSortWithoutColumn , [ name , '<STR_LIT>' ] ] ) ; <EOL> } else if ( currentColumnSortDirection == = '<STR_LIT>' ) { <EOL> onChangeSortOrder ( [ ... currentSortWithoutColumn , [ name , '<STR_LIT>' ] ] ) ; <EOL> } else if ( currentColumnSortDirection == = '<STR_LIT>' & & currentSortWithoutColumn . length == = <NUM_LIT> ) { <EOL> onChangeSortOrder ( [ <EOL> [ name , '<STR_LIT>' ] <EOL> ] ) ; <EOL> } else { <EOL> onChangeSortOrder ( currentSortWithoutColumn ) ; <EOL> } <EOL> } ; <EOL> const getSortButtonAriaLabel = ( ) = > { <EOL> const sortAscendingMessage = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> columnName : name <EOL> } , <EOL> } ) ; <EOL> const sortDescendingMessage = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> columnName : name <EOL> } , <EOL> } ) ; <EOL> const stopSortingMessage = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> columnName : name <EOL> } , <EOL> } ) ; <EOL> if ( currentColumnSort == = undefined ) { <EOL> return sortAscendingMessage ; <EOL> } else if ( sortDirection == = '<STR_LIT>' ) { <EOL> return sortDescendingMessage ; <EOL> } else if ( sortDirection == = '<STR_LIT>' & & currentSortWithoutColumn . length == = <NUM_LIT> ) { <EOL> return sortAscendingMessage ; <EOL> } else { <EOL> return stopSortingMessage ; <EOL> } <EOL> } ; <EOL> const buttons = [ { <EOL> active : isSortable & & typeof onChangeSortOrder == = '<STR_LIT>' , <EOL> ariaLabel : getSortButtonAriaLabel ( ) , <EOL> className : btnSortClassName , <EOL> onClick : handleChangeSortOrder , <EOL> testSubject :   ` docTableHeaderFieldSort_ $ { name } ` , <EOL> tooltip : getSortButtonAriaLabel ( ) , <EOL> } , { <EOL> active : isRemoveable & & typeof onRemoveColumn == = '<STR_LIT>' , <EOL> ariaLabel : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> columnName : name <EOL> } , <EOL> } ) , <EOL> className : '<STR_LIT>' , <EOL> onClick : ( ) = > onRemoveColumn & & onRemoveColumn ( name ) , <EOL> testSubject :   ` docTableRemoveHeader - $ { name } ` , <EOL> tooltip : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , { <EOL> active : colLeftIdx >= <NUM_LIT> & & typeof onMoveColumn == = '<STR_LIT>' , <EOL> ariaLabel : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> columnName : name <EOL> } , <EOL> } ) , <EOL> className : '<STR_LIT>' , <EOL> onClick : ( ) = > onMoveColumn & & onMoveColumn ( name , colLeftIdx ) , <EOL> testSubject :   ` docTableMoveLeftHeader - $ { name } ` , <EOL> tooltip : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , { <EOL> active : colRightIdx >= <NUM_LIT> & & typeof onMoveColumn == = '<STR_LIT>' , <EOL> ariaLabel : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> columnName : name <EOL> } , <EOL> } ) , <EOL> className : '<STR_LIT>' , <EOL> onClick : ( ) = > onMoveColumn & & onMoveColumn ( name , colRightIdx ) , <EOL> testSubject :   ` docTableMoveRightHeader - $ { name } ` , <EOL> tooltip : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , ] ; <EOL> return ( < th data - test - subj = "<STR_LIT>" > < span data - test - subj = {   ` docTableHeader - $ { name } ` } > { displayName } { buttons . filter ( ( button ) = > button . active ) . map ( ( button , idx ) = > ( < EuiToolTip id = {   ` docTableHeader - $ { name } - tt ` } content = { button . tooltip } key = {   ` button - $ { idx } ` } > < button aria - label = { button . ariaLabel } className = { button . className } data - test - subj = { button . testSubject } onClick = { button . onClick } / > < / EuiToolTip > ) ) } < / span > < / th > ) ; } </s>
<s> import { <EOL> AbstractControl , <EOL> ValidationErrors <EOL> } from '<STR_LIT>' ; <EOL> export function integerValidator ( control ) { <EOL> const numValue = Number ( control . value ) ; <EOL> if ( ! isNaN ( numValue ) & & numValue == = Math . floor ( numValue ) ) { <EOL> return null ; <EOL> } else { <EOL> return { <EOL> notInteger : { <EOL> value : control . value <EOL> } <EOL> } ; <EOL> } <EOL> } </s>
<s> import React , { <EOL> Component <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ImageStyle , <EOL> ImageURISource , <EOL> StyleProp , <EOL> TextStyle , <EOL> TouchableWithoutFeedback , <EOL> View , <EOL> ViewStyle <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> CommerceTypes <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ButtonProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ReviewIndicatorProps <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SwatchesProps , <EOL> SwatchItemType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ProductItemBrand , <EOL> ProductItemButton , <EOL> ProductItemImage , <EOL> ProductItemPrice , <EOL> ProductItemPromos , <EOL> ProductItemReviews , <EOL> ProductItemSwatches , <EOL> ProductItemTitle , <EOL> ProductItemVariant <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> style as S <EOL> } from '<STR_LIT>' ; <EOL> export interface ProductItemProps extends CommerceTypes . Product { <EOL> style   ? : StyleProp < ViewStyle > ; <EOL> contentStyle   ? : StyleProp < ViewStyle > ; <EOL> titleStyle   ? : StyleProp < TextStyle > ; <EOL> brandStyle   ? : StyleProp < TextStyle > ; <EOL> imageStyle   ? : StyleProp < ImageStyle > ; <EOL> imageContainerStyle   ? : StyleProp < ViewStyle > ; <EOL> onPress : ( ) = > void ; <EOL> priceStyle   ? : StyleProp < TextStyle > ; <EOL> originalPriceStyle   ? : StyleProp < TextStyle > ; <EOL> salePriceStyle   ? : StyleProp < TextStyle > ; <EOL> promoContainerStyle   ? : StyleProp < ViewStyle > ; <EOL> promoStyle   ? : StyleProp < TextStyle > ; <EOL> variantText   ? : string ; <EOL> variantTextStyle   ? : StyleProp < TextStyle > ; <EOL> reviewStyle   ? : StyleProp < ViewStyle > ; <EOL> reviewCountStyle   ? : StyleProp < TextStyle > ; <EOL> reviewIndicatorProps   ? : Partial < ReviewIndicatorProps > ; <EOL> extraElement   ? : JSX . Element ; <EOL> swatchItems   ? : SwatchItemType [ ] ; <EOL> swatchStyle   ? : StyleProp < ViewStyle > ; <EOL> swatchesProps   ? : SwatchesProps ; <EOL> deprecated promos   ? : string [ ] ; <EOL> deprecated image   ? : ImageURISource ; <EOL> deprecated reviewValue   ? : number ; <EOL> deprecated reviewCount   ? : number ; <EOL> showReviewCount   ? : boolean ; <EOL> buttonText   ? : string ; <EOL> buttonStyle   ? : StyleProp < ViewStyle > ; <EOL> buttonTextStyle   ? : StyleProp < TextStyle > ; <EOL> buttonProps   ? : Partial < ButtonProps > ; <EOL> onButtonPress   ? : ( ) = > void ; <EOL> renderButton   ? : ( ) = > React . ReactNode ; <EOL> onFavButtonPress   ? : ( ) = > void ; <EOL> favButtonImage   ? : ImageURISource ; <EOL> renderFavButton   ? : ( ) = > React . ReactNode ; <EOL> renderPrice   ? : ( ) = > React . ReactNode ; <EOL> renderPromos   ? : ( ) = > React . ReactNode ; <EOL> renderTitle   ? : ( ) = > React . ReactNode ; <EOL> renderVariantText   ? : ( ) = > React . ReactNode ; <EOL> renderBrand   ? : ( ) = > React . ReactNode ; <EOL> renderImage   ? : ( ) = > React . ReactNode ; <EOL> renderReviews   ? : ( ) = > React . ReactNode ; <EOL> renderSwatches   ? : ( ) = > React . ReactNode ; <EOL> hidePrice   ? : boolean ; <EOL> hidePromos   ? : boolean ; <EOL> hideTitle   ? : boolean ; <EOL> hideVariantText   ? : boolean ; <EOL> hideBrand   ? : boolean ; <EOL> hideImage   ? : boolean ; <EOL> hideReviews   ? : boolean ; <EOL> hideSwatches   ? : boolean ; <EOL> hideButton   ? : boolean ; <EOL> orientation   ? : '<STR_LIT>' | '<STR_LIT>' ; <EOL> } <EOL> export class ProductItem extends Component < ProductItemProps > { <EOL> render ( ) { <EOL> const { <EOL> style , <EOL> contentStyle , <EOL> onPress , <EOL> extraElement = null , <EOL> title , <EOL> images , <EOL> imageStyle , <EOL> imageContainerStyle , <EOL> renderImage , <EOL> image , <EOL> variantText , <EOL> variantTextStyle , <EOL> renderVariantText , <EOL> brand , <EOL> brandStyle , <EOL> renderBrand , <EOL> titleStyle , <EOL> renderTitle , <EOL> review , <EOL> reviewStyle , <EOL> reviewCountStyle , <EOL> reviewIndicatorProps , <EOL> renderReviews , <EOL> price , <EOL> originalPrice , <EOL> priceStyle , <EOL> originalPriceStyle , <EOL> salePriceStyle , <EOL> renderPrice , <EOL> promotions , <EOL> promoStyle , <EOL> promoContainerStyle , <EOL> renderPromos , <EOL> promos , <EOL> swatchItems , <EOL> swatchStyle , <EOL> swatchesProps , <EOL> renderSwatches , <EOL> hidePrice , <EOL> hidePromos , <EOL> hideTitle , <EOL> hideVariantText , <EOL> hideBrand , <EOL> hideImage , <EOL> hideReviews , <EOL> hideSwatches , <EOL> hideButton , <EOL> buttonText , <EOL> buttonStyle , <EOL> buttonTextStyle , <EOL> buttonProps , <EOL> onButtonPress , <EOL> renderButton , <EOL> orientation = '<STR_LIT>' <EOL> } = this . props ; <EOL> const isHorizontal = ( orientation == = '<STR_LIT>' ) ; <EOL> let { <EOL> reviewCount , <EOL> reviewValue <EOL> } = this . props ; <EOL> if ( review ) { <EOL> if ( review . summary ) { <EOL> reviewValue = review . summary . averageRating ; <EOL> reviewCount = review . summary . reviewCount ; <EOL> } else if ( review . statistics ) { <EOL> reviewValue = review . statistics . averageRating ; <EOL> reviewCount = review . statistics . reviewCount ; <EOL> } <EOL> } <EOL> return ( < TouchableWithoutFeedback accessibilityLabel = { title } onPress = { onPress } > < View style = { style } > < View style = { isHorizontal   ? S . horizontalListContainer : null } > < View style = { isHorizontal   ? S . horizontalLeft : null } > {   ! hideImage & & ( < ProductItemImage images = { images } imageStyle = { imageStyle } imageContainerStyle = { imageContainerStyle } renderImage = { renderImage } image = { image } / > ) } {   ! hideVariantText & & ( < ProductItemVariant variantText = { variantText } variantTextStyle = { variantTextStyle } renderVariantText = { renderVariantText } / > ) } < / View > < View style = { [ isHorizontal   ? S . horizontalRight : null , contentStyle ] } > {   ! hideSwatches & & ( < ProductItemSwatches swatchItems = { swatchItems } swatchStyle = { swatchStyle } swatchesProps = { swatchesProps } renderSwatches = { renderSwatches } / > ) } {   ! hideBrand & & ( < ProductItemBrand brand = { brand } brandStyle = { brandStyle } renderBrand = { renderBrand } / > ) } {   ! hideTitle & & ( < ProductItemTitle title = { title } titleStyle = { titleStyle } renderTitle = { renderTitle } / > ) } {   ! hidePrice & & ( < ProductItemPrice price = { price } originalPrice = { originalPrice } priceStyle = { priceStyle } originalPriceStyle = { originalPriceStyle } salePriceStyle = { salePriceStyle } renderPrice = { renderPrice } / > ) } {   ! hideReviews & & ( < ProductItemReviews review = { review } reviewStyle = { reviewStyle } reviewCountStyle = { reviewCountStyle } reviewIndicatorProps = { reviewIndicatorProps } renderReviews = { renderReviews } reviewValue = { reviewValue } reviewCount = { reviewCount } / > ) } {   ! hidePromos & & ( < ProductItemPromos promotions = { promotions } promoStyle = { promoStyle } promoContainerStyle = { promoContainerStyle } renderPromos = { renderPromos } promos = { promos } / > ) } { extraElement } < / View > < / View > < View > {   ! hideButton & & ( < ProductItemButton buttonText = { buttonText } buttonStyle = { buttonStyle } buttonTextStyle = { buttonTextStyle } onButtonPress = { onButtonPress } renderButton = { renderButton } { ... buttonProps } / > ) } < / View > < / View > < / TouchableWithoutFeedback > ) ; } } </s>
<s> export const INSTRUCTION_VARIANT = { <EOL> ESC : '<STR_LIT>' , <EOL> OSX : '<STR_LIT>' , <EOL> DEB : '<STR_LIT>' , <EOL> RPM : '<STR_LIT>' , <EOL> DOCKER : '<STR_LIT>' , <EOL> WINDOWS : '<STR_LIT>' , <EOL> NODE : '<STR_LIT>' , <EOL> DJANGO : '<STR_LIT>' , <EOL> FLASK : '<STR_LIT>' , <EOL> RAILS : '<STR_LIT>' , <EOL> RACK : '<STR_LIT>' , <EOL> JS : '<STR_LIT>' , <EOL> GO : '<STR_LIT>' , <EOL> JAVA : '<STR_LIT>' , <EOL> DOTNET : '<STR_LIT>' , <EOL> LINUX : '<STR_LIT>' , <EOL> } ; <EOL> const DISPLAY_MAP = { <EOL> [ INSTRUCTION_VARIANT . ESC ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . OSX ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . DEB ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . RPM ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . DOCKER ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . WINDOWS ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . NODE ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . DJANGO ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . FLASK ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . RAILS ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . RACK ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . JS ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . GO ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . JAVA ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . DOTNET ] : '<STR_LIT>' , <EOL> [ INSTRUCTION_VARIANT . LINUX ] : '<STR_LIT>' , <EOL> } ; <EOL> params <EOL> return { <EOL> String <EOL> } <EOL> export function getDisplayText ( id ) { <EOL> if ( id in DISPLAY_MAP ) { <EOL> return DISPLAY_MAP [ id ] ; <EOL> } <EOL> return id ; <EOL> } </s>
<s> import { <EOL> IndexPatternField <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FieldFilterState , <EOL> isFieldFiltered <EOL> } from '<STR_LIT>' ; <EOL> interface GroupedFields { <EOL> selected : IndexPatternField [ ] ; popular : IndexPatternField [ ] ; unpopular : IndexPatternField [ ] ; <EOL> } <EOL> / ** <EOL> * group the fields into selected , popular and unpopular , filter by fieldFilterState <EOL> * / <EOL> export function groupFields ( fields , columns , popularLimit , fieldCounts , fieldFilterState ) { <EOL> const result = { <EOL> selected : [ ] , <EOL> popular : [ ] , <EOL> unpopular : [ ] , <EOL> } ; <EOL> if ( ! Array . isArray ( fields ) | |   ! Array . isArray ( columns ) | | typeof fieldCounts != = '<STR_LIT>' ) { <EOL> return result ; <EOL> } <EOL> const popular = fields . filter ( ( field ) = >   ! columns . includes ( field . name ) & & field . count ) . sort ( ( a , b ) = > ( b . count | | <NUM_LIT> ) - ( a . count | | <NUM_LIT> ) ) . map ( ( field ) = > field . name ) . slice ( <NUM_LIT> , popularLimit ) ; <EOL> const compareFn = ( a , b ) = > { <EOL> if ( ! a . displayName ) { <EOL> return <NUM_LIT> ; <EOL> } <EOL> return a . displayName . localeCompare ( b . displayName | | '<STR_LIT>' ) ; <EOL> } ; <EOL> const fieldsSorted = fields . sort ( compareFn ) ; <EOL> for ( const field of fieldsSorted ) { <EOL> if ( ! isFieldFiltered ( field , fieldFilterState , fieldCounts ) ) { <EOL> continue ; <EOL> } <EOL> if ( columns . includes ( field . name ) ) { <EOL> result . selected . push ( field ) ; <EOL> } else if ( popular . includes ( field . name ) & & field . type != = '<STR_LIT>' ) { <EOL> result . popular . push ( field ) ; <EOL> } else if ( field . type != = '<STR_LIT>' ) { <EOL> result . unpopular . push ( field ) ; <EOL> } <EOL> } <EOL> return result ; <EOL> } </s>
<s> import { <EOL> HttpClient <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> AddRepositoryPayload , <EOL> DeleteRepositoryPayload , <EOL> EditRepositoryPayload , <EOL> Repository <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> urlFactory <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Observable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class RepositoryDataService { <EOL> readonly endpoints = { <EOL> getRepositoryCollection : urlFactory ( '<STR_LIT>' ) , <EOL> addRepository : urlFactory ( '<STR_LIT>' ) , <EOL> deleteRepository : urlFactory < '<STR_LIT>' > ( '<STR_LIT>' , true ) , <EOL> editRepository : urlFactory < '<STR_LIT>' > ( '<STR_LIT>' , true ) <EOL> } ; <EOL> constructor ( private http ) { } <EOL> getRepositoryCollection ( ) { <EOL> return this . http . get < IResponse < Repository [ ] > > ( this . endpoints . getRepositoryCollection . url ( ) ) . pipe ( map ( res = > res . data ) ) ; <EOL> } <EOL> addRepository ( data ) { <EOL> return this . http . post < IResponse < Repository > > ( this . endpoints . addRepository . url ( ) , data ) . pipe ( map ( resp = > resp . data ) ) ; <EOL> } <EOL> deleteRepository ( data ) { <EOL> return this . http . delete < void > ( this . endpoints . deleteRepository . url ( { <EOL> id : data . repositoryId <EOL> } ) ) ; <EOL> } <EOL> editRepository ( { <EOL> repositoryId , <EOL> ... body <EOL> } ) { <EOL> return this . http . put < void > ( this . endpoints . editRepository . url ( { <EOL> id : repositoryId <EOL> } ) , body ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> HttpErrorResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Actions , <EOL> Effect , <EOL> ofType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DataPersistence <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> map <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RepositoryDataService <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> fromRepositoryActions <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RepositoryPartialState <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class RepositoryEffects { <EOL> @ Effect ( ) getRepositoryCollection $ = this . dp . fetch ( fromRepositoryActions . Types . GetRepositoryCollection , { <EOL> run : ( action ) = > { <EOL> return this . repositoryDataService . getRepositoryCollection ( ) . pipe ( map ( data = > new fromRepositoryActions . GetRepositoryCollectionSuccess ( data ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromRepositoryActions . GetRepositoryCollectionFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> @ Effect ( ) addRepository $ = this . dp . fetch ( fromRepositoryActions . Types . AddRepository , { <EOL> run : ( action ) = > { <EOL> return this . repositoryDataService . addRepository ( action . payload ) . pipe ( map ( resp = > new fromRepositoryActions . AddRepositorySuccess ( { <EOL> repository : resp <EOL> } ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromRepositoryActions . AddRepositoryFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> @ Effect ( ) addRepositorySuccess $ = this . actions $ . pipe ( ofType ( fromRepositoryActions . Types . AddRepositorySuccess ) , map ( ( ) = > new fromRepositoryActions . GetRepositoryCollection ( ) ) ) ; <EOL> @ Effect ( ) deleteRepository $ = this . dp . fetch ( fromRepositoryActions . Types . DeleteRepository , { <EOL> run : ( action ) = > { <EOL> return this . repositoryDataService . deleteRepository ( action . payload ) . pipe ( map ( ( ) = > new fromRepositoryActions . DeleteRepositorySuccess ( ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromRepositoryActions . DeleteRepositoryFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> @ Effect ( ) deleteRepositorySuccess $ = this . actions $ . pipe ( ofType ( fromRepositoryActions . Types . DeleteRepositorySuccess ) , map ( ( ) = > new fromRepositoryActions . GetRepositoryCollection ( ) ) ) ; <EOL> @ Effect ( ) editRepository $ = this . dp . fetch ( fromRepositoryActions . Types . EditRepository , { <EOL> run : ( action ) = > { <EOL> return this . repositoryDataService . editRepository ( action . payload ) . pipe ( map ( ( ) = > new fromRepositoryActions . EditRepositorySuccess ( ) ) ) ; <EOL> } , <EOL> onError : ( action , error ) = > { <EOL> return new fromRepositoryActions . EditRepositoryFail ( error ) ; <EOL> } <EOL> } ) ; <EOL> @ Effect ( ) editRepositorySuccess $ = this . actions $ . pipe ( ofType ( fromRepositoryActions . Types . EditRepositorySuccess ) , map ( ( ) = > new fromRepositoryActions . GetRepositoryCollection ( ) ) ) ; <EOL> constructor ( private dp , private repositoryDataService , private actions $ ) { } <EOL> } </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import * as ReactDOM from '<STR_LIT>' ; <EOL> import { <EOL> FaAngleRight <EOL> } from '<STR_LIT>' ; <EOL> import '<STR_LIT>' ; <EOL> function App ( ) { <EOL> return ( < div className = "<STR_LIT>" > < button className = "<STR_LIT>" > < FaAngleRight / > Click Me < / button > < div className = "<STR_LIT>" > Panel Contents < / div > < / div > ) ; } ReactDOM . render ( < App / > , document . getElementById ( '<STR_LIT>' ) ) ; </s>
<s> import Web3 from "<STR_LIT>" ; <EOL> import { <EOL> Log , <EOL> LogsOptions , <EOL> Transaction <EOL> } from "<STR_LIT>" ; <EOL> import web3CoreSubscriptions , { <EOL> Subscription <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> BlockHeader , <EOL> Eth , <EOL> Syncing <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> decodeParameter <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> toHex <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> AlchemyWeb3Config , <EOL> FullConfig , <EOL> Provider , <EOL> TransactionsOptions , <EOL> Web3Callback , <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> formatBlock <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> JsonRpcSenders <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> callWhenDone <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> makeAlchemyContext <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> patchEnableCustomRPC <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> patchEthFeeHistoryMethod <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> patchEthMaxPriorityFeePerGasMethod <EOL> } from "<STR_LIT>" ; <EOL> const DEFAULT_MAX_RETRIES = <NUM_LIT> ; <EOL> const DEFAULT_RETRY_INTERVAL = <NUM_LIT> ; <EOL> const DEFAULT_RETRY_JITTER = <NUM_LIT> ; <EOL> export interface AlchemyWeb3 extends Web3 { <EOL> alchemy : AlchemyMethods ; eth : AlchemyEth ; setWriteProvider ( provider ) : void ; <EOL> } <EOL> export interface AlchemyMethods { <EOL> getTokenAllowance ( params , callback   ? ) : Promise < TokenAllowanceResponse > ; <EOL> getTokenBalances ( address , contractAddresses , callback   ? ) : Promise < TokenBalancesResponse > ; <EOL> getTokenMetadata ( address , callback   ? ) : Promise < TokenMetadataResponse > ; <EOL> getAssetTransfers ( params , callback   ? ) : Promise < AssetTransfersResponse > ; <EOL> getNftMetadata ( params , callback   ? ) : Promise < NftMetadataResponse > ; <EOL> } <EOL> export interface TokenAllowanceParams { <EOL> contract : string ; owner : string ; spender : string ; <EOL> } <EOL> export type TokenAllowanceResponse = string ; <EOL> export interface TokenBalancesResponse { <EOL> address : string ; tokenBalances : TokenBalance [ ] ; <EOL> } <EOL> export type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure ; <EOL> export interface TokenBalanceSuccess { <EOL> address : string ; tokenBalance : string ; error : null ; <EOL> } <EOL> export interface TokenBalanceFailure { <EOL> address : string ; tokenBalance : null ; error : string ; <EOL> } <EOL> export interface TokenMetadataResponse { <EOL> decimals : number | null ; logo : string | null ; name : string | null ; symbol : string | null ; <EOL> } <EOL> export interface AssetTransfersParams { <EOL> fromBlock   ? : string ; <EOL> toBlock   ? : string ; <EOL> order   ? : AssetTransfersOrder ; <EOL> fromAddress   ? : string ; <EOL> toAddress   ? : string ; <EOL> contractAddresses   ? : string [ ] ; <EOL> excludeZeroValue   ? : boolean ; <EOL> maxCount   ? : number ; <EOL> category   ? : AssetTransfersCategory [ ] ; <EOL> pageKey   ? : string ; <EOL> } <EOL> export enum AssetTransfersCategory { <EOL> EXTERNAL = "<STR_LIT>" , INTERNAL = "<STR_LIT>" , TOKEN = "<STR_LIT>" , ERC20 = "<STR_LIT>" , ERC721 = "<STR_LIT>" , ERC1155 = "<STR_LIT>" <EOL> } <EOL> export enum AssetTransfersOrder { <EOL> ASCENDING = "<STR_LIT>" , DESCENDING = "<STR_LIT>" <EOL> } <EOL> export interface AssetTransfersResponse { <EOL> transfers : AssetTransfersResult [ ] ; pageKey   ? : string ; <EOL> } <EOL> export interface AssetTransfersResult { <EOL> category : AssetTransfersCategory ; blockNum : string ; from : string ; to : string | null ; value : number | null ; erc721TokenId : string | null ; erc1155Metadata : ERC1155Metadata [ ] | null ; asset : string | null ; hash : string ; rawContract : RawContract ; <EOL> } <EOL> export interface NftMetadataParams { <EOL> contractAddress : string ; tokenId : string ; tokenType : "<STR_LIT>" | "<STR_LIT>" ; <EOL> } <EOL> export interface NftMetadataResponse { <EOL> contract : string ; tokenType : "<STR_LIT>" | "<STR_LIT>" ; tokenId : string ; rawMetadataUri : string | null ; alchemyMetadataUri : string | null ; rawImageUri : string | null ; alchemyImageUri : string | null ; name : string | null ; description : string | null ; attributes : Array < Record < string , <EOL> any > > ; rawMetadata : Record < string , <EOL> any > ; <EOL> } <EOL> export interface ERC1155Metadata { <EOL> tokenId : string ; value : string ; <EOL> } <EOL> export interface RawContract { <EOL> value : string | null ; address : string | null ; decimal : string | null ; <EOL> } <EOL> / ** <EOL> * Same as Eth , but with   ` subscribe ` allowing more types . <EOL> * / <EOL> export interface AlchemyEth extends Eth { <EOL> subscribe ( type , options   ? , callback   ? ) : Subscription < Log > ; <EOL> subscribe ( type , callback   ? ) : Subscription < Syncing > ; <EOL> subscribe ( type , callback   ? ) : Subscription < BlockHeader > ; <EOL> subscribe ( type , callback   ? ) : Subscription < string > ; <EOL> subscribe ( type , callback   ? ) : Subscription < Transaction > ; <EOL> subscribe ( type , options   ? , callback   ? ) : Subscription < Transaction > ; <EOL> subscribe ( type , options   ? , callback   ? ) : Subscription < Log | BlockHeader | Syncing | string > ; <EOL> } <EOL> interface EthereumWindow extends Window { <EOL> ethereum   ? : any ; <EOL> } <EOL> declare const window ; <EOL> export function createAlchemyWeb3 ( alchemyUrl , config   ? ) { <EOL> const fullConfig = fillInConfigDefaults ( config ) ; <EOL> const { <EOL> provider , <EOL> senders , <EOL> setWriteProvider <EOL> } = makeAlchemyContext ( alchemyUrl , fullConfig ) ; <EOL> const alchemyWeb3 = new Web3 ( provider ) as AlchemyWeb3 ; <EOL> alchemyWeb3 . setProvider = ( ) = > { <EOL> throw new Error ( "<STR_LIT>" ) ; <EOL> } ; <EOL> alchemyWeb3 . setWriteProvider = setWriteProvider ; <EOL> alchemyWeb3 . alchemy = { <EOL> getTokenAllowance : ( params , callback ) = > callAlchemyMethod ( { <EOL> senders , <EOL> callback , <EOL> method : "<STR_LIT>" , <EOL> params : [ params ] , <EOL> } ) , <EOL> getTokenBalances : ( address , contractAddresses , callback ) = > callAlchemyMethod ( { <EOL> senders , <EOL> callback , <EOL> method : "<STR_LIT>" , <EOL> params : [ address , contractAddresses ] , <EOL> processResponse : processTokenBalanceResponse , <EOL> } ) , <EOL> getTokenMetadata : ( address , callback ) = > callAlchemyMethod ( { <EOL> senders , <EOL> callback , <EOL> params : [ address ] , <EOL> method : "<STR_LIT>" , <EOL> } ) , <EOL> getAssetTransfers : ( params , callback ) = > callAlchemyMethod ( { <EOL> senders , <EOL> callback , <EOL> params : [ { <EOL> ... params , <EOL> fromBlock : params . fromBlock != null   ? formatBlock ( params . fromBlock ) : undefined , <EOL> toBlock : params . toBlock != null   ? formatBlock ( params . toBlock ) : undefined , <EOL> maxCount : params . maxCount != null   ? toHex ( params . maxCount ) : undefined , <EOL> } , ] , <EOL> method : "<STR_LIT>" , <EOL> } ) , <EOL> getNftMetadata : ( params , callback ) = > callAlchemyMethod ( { <EOL> senders , <EOL> callback , <EOL> params : [ { <EOL> ... params <EOL> } ] , <EOL> method : "<STR_LIT>" , <EOL> } ) , <EOL> } ; <EOL> patchSubscriptions ( alchemyWeb3 ) ; <EOL> patchEnableCustomRPC ( alchemyWeb3 ) ; <EOL> patchEthFeeHistoryMethod ( alchemyWeb3 ) ; <EOL> patchEthMaxPriorityFeePerGasMethod ( alchemyWeb3 ) ; <EOL> return alchemyWeb3 ; <EOL> } <EOL> function fillInConfigDefaults ( { <EOL> writeProvider = getWindowProvider ( ) , <EOL> maxRetries = DEFAULT_MAX_RETRIES , <EOL> retryInterval = DEFAULT_RETRY_INTERVAL , <EOL> retryJitter = DEFAULT_RETRY_JITTER , <EOL> } = { } ) { <EOL> return { <EOL> writeProvider , <EOL> maxRetries , <EOL> retryInterval , <EOL> retryJitter <EOL> } ; <EOL> } <EOL> function getWindowProvider ( ) { <EOL> return typeof window != = "<STR_LIT>"   ? window . ethereum : null ; <EOL> } <EOL> interface CallAlchemyMethodParams < T > { <EOL> senders : JsonRpcSenders ; method : string ; params : any [ ] ; callback   ? : Web3Callback < T > ; processResponse   ? ( response ) : T ; <EOL> } <EOL> function callAlchemyMethod < T > ( { <EOL> senders , <EOL> method , <EOL> params , <EOL> callback = noop , <EOL> processResponse = identity , <EOL> } ) { <EOL> const promise = ( async ( ) = > { <EOL> const result = await senders . send ( method , params ) ; <EOL> return processResponse ( result ) ; <EOL> } ) ( ) ; <EOL> callWhenDone ( promise , callback ) ; <EOL> return promise ; <EOL> } <EOL> function processTokenBalanceResponse ( rawResponse ) { <EOL> const fixedTokenBalances = rawResponse . tokenBalances . map ( ( balance ) = > balance . tokenBalance != null   ? { <EOL> ... balance , <EOL> tokenBalance : decodeParameter ( "<STR_LIT>" , balance . tokenBalance ) , <EOL> } : balance ) ; <EOL> return { <EOL> ... rawResponse , <EOL> tokenBalances : fixedTokenBalances <EOL> } ; <EOL> } <EOL> / ** <EOL> * Updates Web3 ' s internal subscription architecture to also handle Alchemy <EOL> * specific subscriptions . <EOL> * / <EOL> function patchSubscriptions ( web3 ) { <EOL> const { <EOL> eth <EOL> } = web3 ; <EOL> const oldSubscribe = eth . subscribe . bind ( eth ) ; <EOL> eth . subscribe = ( ( type , ... rest ) = > { <EOL> if ( type == = "<STR_LIT>" | | type == = "<STR_LIT>" ) { <EOL> return suppressNoSubscriptionExistsWarning ( ( ) = > oldSubscribe ( "<STR_LIT>" <EOL> as any , ... rest ) ) ; <EOL> } <EOL> if ( type == = "<STR_LIT>" | | type == = "<STR_LIT>" | | type == = "<STR_LIT>" ) { <EOL> return suppressNoSubscriptionExistsWarning ( ( ) = > oldSubscribe ( "<STR_LIT>" <EOL> as any , ... rest ) ) ; <EOL> } <EOL> return oldSubscribe ( type as any , ... rest ) ; <EOL> } ) as any ; <EOL> } <EOL> / ** <EOL> * VERY hacky wrapper to suppress a spurious warning when subscribing to an <EOL> * Alchemy subscription that isn ' t built into Web3 . <EOL> * / <EOL> function suppressNoSubscriptionExistsWarning < T > ( f ) { <EOL> const oldConsoleWarn = console . warn ; <EOL> console . warn = ( ... args ) = > { <EOL> if ( typeof args [ <NUM_LIT> ] == = "<STR_LIT>" & & args [ <NUM_LIT> ] . includes ( "<STR_LIT>" ) ) { <EOL> return ; <EOL> } <EOL> return oldConsoleWarn . apply ( console , args ) ; <EOL> } ; <EOL> try { <EOL> return f ( ) ; <EOL> } finally { <EOL> console . warn = oldConsoleWarn ; <EOL> } <EOL> } <EOL> / ** <EOL> * Another VERY hacky monkeypatch to make sure that we can take extra parameters to certain alchemy subscriptions <EOL> * I hate doing this , but the other option is to fork web3 - core and I think for now this is better <EOL> * / <EOL> const { <EOL> subscription <EOL> } = web3CoreSubscriptions as any ; <EOL> const oldSubscriptionPrototypeValidateArgs = subscription . prototype . _validateArgs ; <EOL> subscription . prototype . _validateArgs = function ( args ) { <EOL> if ( [ "<STR_LIT>" , "<STR_LIT>" , "<STR_LIT>" , ] . includes ( this . subscriptionMethod ) ) { } else { <EOL> if ( [ "<STR_LIT>" , "<STR_LIT>" , ] . includes ( this . subscriptionMethod ) ) { <EOL> if ( this . options . subscription ) { <EOL> this . options . subscription . subscriptionName = this . subscriptionMethod ; <EOL> } <EOL> } <EOL> const validator = oldSubscriptionPrototypeValidateArgs . bind ( this ) ; <EOL> validator ( args ) ; <EOL> } <EOL> } ; <EOL> function noop ( ) { } <EOL> function identity < T > ( x ) { <EOL> return x ; <EOL> } </s>
<s> import { <EOL> Component , <EOL> AfterViewInit , <EOL> ChangeDetectionStrategy , <EOL> Input <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Observable <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> GameState <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> GameService <EOL> } from "<STR_LIT>" ; <EOL> @ Component ( { <EOL> selector : '<STR_LIT>' , <EOL> templateUrl : '<STR_LIT>' , <EOL> changeDetection : ChangeDetectionStrategy . OnPush <EOL> } ) export class GameContainerComponent implements AfterViewInit { <EOL> @ Input ( ) state : GameState ; <EOL> height ; <EOL> width ; <EOL> constructor ( private game ) { } <EOL> ngAfterViewInit ( ) { <EOL> this . createGame ( ) ; / ** Clone hero when space is clicked * / <EOL> Observable . fromEvent ( document , '<STR_LIT>' ) . subscribe ( ( e ) = > { <EOL> if ( e . keyCode == = <NUM_LIT> ) { <EOL> this . game . addBot ( ) ; <EOL> } <EOL> } ) ; <EOL> } <EOL> createGame ( ) { <EOL> this . height = <NUM_LIT> ; <EOL> this . width = <NUM_LIT> ; <EOL> this . game . newGame ( this . width , this . height ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> Operator <EOL> } from "<STR_LIT>" ; <EOL> export function Equal < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } <EOL> export function NotEqual < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } <EOL> export function LessThan < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } <EOL> export function LessThanOrEqual < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } <EOL> export function GreaterThan < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } <EOL> export function GreaterThanOrEqual < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } <EOL> export function Between < T > ( from , to ) { <EOL> return new Operator ( "<STR_LIT>" , [ from , to ] as any ) ; <EOL> } <EOL> export function In < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value as any ) ; <EOL> } <EOL> export function AttributeExists ( ) { <EOL> return new Operator ( "<STR_LIT>" , undefined as any , false ) ; <EOL> } <EOL> export function AttributeNotExists ( ) { <EOL> return new Operator ( "<STR_LIT>" , undefined as any , false ) ; <EOL> } <EOL> export function BeginsWith < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } <EOL> export function Contains < T > ( value ) { <EOL> return new Operator ( "<STR_LIT>" , value ) ; <EOL> } </s>
<s> </s>
<s> import { <EOL> IIndexPattern , <EOL> IFieldType <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter <EOL> } from '<STR_LIT>' ; <EOL> export function filterMatchesIndex ( filter , indexPattern   ? ) { <EOL> if ( ! filter . meta ? . key | |   ! indexPattern ) { <EOL> return true ; <EOL> } <EOL> return indexPattern . fields . some ( ( field ) = > field . name == = filter . meta . key ) ; <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ChromeStart , <EOL> DocLinksStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Filter <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisualizeServices , <EOL> VisualizeEditorVisInstance <EOL> } from '<STR_LIT>' ; <EOL> export const addHelpMenuToAppChrome = ( chrome , docLinks ) = > { <EOL> chrome . setHelpExtension ( { <EOL> appName : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> links : [ { <EOL> linkType : '<STR_LIT>' , <EOL> href :   ` $ { docLinks . links . noDocumentation . visualize . guide } ` , <EOL> } , ] , <EOL> } ) ; <EOL> } ; <EOL> export const addBadgeToAppChrome = ( chrome ) = > { <EOL> chrome . setBadge ( { <EOL> text : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> tooltip : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> iconType : '<STR_LIT>' , <EOL> } ) ; <EOL> } ; <EOL> export const getDefaultQuery = ( { <EOL> data <EOL> } ) = > { <EOL> return data . query . queryString . getDefaultQuery ( ) ; <EOL> } ; <EOL> export const visStateToEditorState = ( visInstance , services ) = > { <EOL> const vis = visInstance . vis ; <EOL> const savedVisState = services . visualizations . convertFromSerializedVis ( vis . serialize ( ) ) ; <EOL> const savedVis = '<STR_LIT>' in visInstance   ? visInstance . savedVis : undefined ; <EOL> return { <EOL> uiState : savedVis & & savedVis . uiStateJSON   ? JSON . parse ( savedVis . uiStateJSON ) : vis . uiState . toJSON ( ) , <EOL> query : vis . data . searchSource ? . getOwnField ( '<STR_LIT>' ) | | getDefaultQuery ( services ) , <EOL> filters : ( vis . data . searchSource ? . getOwnField ( '<STR_LIT>' ) as Filter [ ] ) | | [ ] , <EOL> vis : { <EOL> ... savedVisState . visState , <EOL> title : vis . title <EOL> } , <EOL> linked : savedVis & & savedVis . id   ?   ! ! savedVis . savedSearchId :   ! ! savedVisState . savedSearchId , <EOL> } ; <EOL> } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiSpacer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SearchResponse <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ShardFailureOpenModalButton <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> toMountPoint <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getNotifications <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> SearchRequest <EOL> } from '<STR_LIT>' ; <EOL> export function handleResponse ( request , response ) { <EOL> if ( response . timed_out ) { <EOL> getNotifications ( ) . toasts . addWarning ( { <EOL> title : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } ) ; <EOL> } <EOL> if ( response . _shards & & response . _shards . failed ) { <EOL> const title = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> shardsFailed : response . _shards . failed , <EOL> shardsTotal : response . _shards . total , <EOL> } , <EOL> } ) ; <EOL> const description = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> const text = toMountPoint ( < > { description } < EuiSpacer size = "<STR_LIT>" / > < ShardFailureOpenModalButton request = { request . body } response = { response } title = { title } / > < / > ) ; getNotifications ( ) . toasts . addWarning ( { title , text } ) ; } return response ; } </s>
<s> import { <EOL> Query <EOL> } from '<STR_LIT>' ; <EOL> export const isQuery = ( x ) : x is Query = >   ! ! x & & typeof x == = '<STR_LIT>' & & typeof ( x as Query ) . language == = '<STR_LIT>' & & ( typeof ( x as Query ) . query == = '<STR_LIT>' | | ( typeof ( x as Query ) . query == = '<STR_LIT>' & &   ! ! ( x as Query ) . query ) ) ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MetricAggType , <EOL> IMetricAggConfig <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> METRIC_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OSD_FIELD_TYPES <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BaseAggParams <EOL> } from '<STR_LIT>' ; <EOL> const uniqueCountTitle = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> export interface AggParamsCardinality extends BaseAggParams { <EOL> field : string ; <EOL> } <EOL> export const getCardinalityMetricAgg = ( ) = > new MetricAggType ( { <EOL> name : METRIC_TYPES . CARDINALITY , <EOL> title : uniqueCountTitle , <EOL> makeLabel ( aggConfig ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> values : { <EOL> field : aggConfig . getFieldDisplayName ( ) <EOL> } , <EOL> } ) ; <EOL> } , <EOL> getSerializedFormat ( agg ) { <EOL> return { <EOL> id : '<STR_LIT>' , <EOL> } ; <EOL> } , <EOL> params : [ { <EOL> name : '<STR_LIT>' , <EOL> type : '<STR_LIT>' , <EOL> filterFieldTypes : Object . values ( OSD_FIELD_TYPES ) . filter ( ( type ) = > type != = OSD_FIELD_TYPES . HISTOGRAM ) , <EOL> } , ] , <EOL> } ) ; </s>
<s> import { <EOL> Filter , <EOL> FilterMeta <EOL> } from '<STR_LIT>' ; <EOL> export interface MatchAllFilterMeta extends FilterMeta { <EOL> field : any ; formattedValue : string ; <EOL> } <EOL> export type MatchAllFilter = Filter & { <EOL> meta : MatchAllFilterMeta ; match_all : any ; <EOL> } ; <EOL> export const isMatchAllFilter = ( filter ) : filter is MatchAllFilter = > filter & & filter . match_all ; </s>
<s> import { <EOL> Inject , <EOL> Injectable , <EOL> Renderer2 , <EOL> RendererFactory2 <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DOCUMENT <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> NavigationEnd , <EOL> Router , <EOL> RouterEvent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> environment <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Observable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> filter , <EOL> share , <EOL> tap <EOL> } from '<STR_LIT>' ; <EOL> declare let gtag ; <EOL> @ Injectable ( ) export class GoogleAnalyticsService { <EOL> private readonly renderer : Renderer2 ; <EOL> private readonly googleId : string ; <EOL> private loaded = false ; <EOL> private loadingInProgress = false ; <EOL> constructor ( private rendererFactory , @ Inject ( DOCUMENT ) private document , private router ) { <EOL> this . renderer = rendererFactory . createRenderer ( null , null ) ; <EOL> this . googleId = environment . googleAnalyticsId ; <EOL> } <EOL> async init ( ) { <EOL> if ( this . loaded | | this . loadingInProgress ) return ; <EOL> try { <EOL> await this . insertGoogleScript ( ) ; <EOL> await this . insertLocalScript ( ) ; <EOL> this . loaded = true ; <EOL> } catch ( error ) { <EOL> console . error ( error ) ; <EOL> } finally { <EOL> this . loadingInProgress = false ; <EOL> } <EOL> } <EOL> trackPageViews ( ) { <EOL> return this . router . events . pipe ( filter ( ( ) = > this . loaded ) , filter ( ( evt ) = > evt instanceof NavigationEnd ) , tap ( ( event ) = > { <EOL> this . trackSinglePageView ( event ) ; <EOL> } ) , share ( ) ) ; <EOL> } <EOL> private trackSinglePageView ( event ) { <EOL> gtag ( '<STR_LIT>' , this . googleId , { <EOL> page_path : event . urlAfterRedirects <EOL> } ) ; <EOL> } <EOL> private async insertGoogleScript ( ) { <EOL> if ( ! this . googleId ) throw new Error ( '<STR_LIT>' ) ; <EOL> await this . insertScript ( ` https : // www . googletagmanager . com / gtag / js ? id = $ { this . googleId } ` ) ; <EOL> } <EOL> private async insertLocalScript ( ) { <EOL> await this . insertScript ( '<STR_LIT>' ) ; <EOL> gtag ( '<STR_LIT>' , this . googleId ) ; <EOL> } <EOL> private insertScript ( path ) { <EOL> return new Promise < void > ( ( resolve , reject ) = > { <EOL> const script = this . renderer . createElement ( '<STR_LIT>' ) as HTMLScriptElement ; <EOL> script . type = '<STR_LIT>' ; <EOL> script . onload = ( ) = > resolve ( ) ; <EOL> script . onerror = ( ) = > reject ( ) ; <EOL> script . src = path ; <EOL> this . renderer . appendChild ( this . document . head , script ) ; <EOL> } ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> difference <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPattern , <EOL> IndexPatternField <EOL> } from '<STR_LIT>' ; <EOL> export function getIndexPatternFieldList ( indexPattern   ? , fieldCounts   ? ) { <EOL> if ( ! indexPattern | |   ! fieldCounts ) return [ ] ; <EOL> const fieldNamesInDocs = Object . keys ( fieldCounts ) ; <EOL> const fieldNamesInIndexPattern = indexPattern . fields . getAll ( ) . map ( ( fld ) = > fld . name ) ; <EOL> const unknownTypes = [ ] ; <EOL> difference ( fieldNamesInDocs , fieldNamesInIndexPattern ) . forEach ( ( unknownFieldName ) = > { <EOL> unknownTypes . push ( { <EOL> displayName : String ( unknownFieldName ) , <EOL> name : String ( unknownFieldName ) , <EOL> type : '<STR_LIT>' , <EOL> } <EOL> as IndexPatternField ) ; <EOL> } ) ; <EOL> return [ ... indexPattern . fields . getAll ( ) , ... unknownTypes ] ; <EOL> } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> FormattedMessage <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> orderBy <EOL> } from '<STR_LIT>' ; <EOL> import React , { <EOL> ChangeEvent <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiFieldSearch , <EOL> EuiFlexGroup , <EOL> EuiFlexItem , <EOL> EuiKeyPadMenu , <EOL> EuiKeyPadMenuItem , <EOL> EuiModalHeader , <EOL> EuiModalHeaderTitle , <EOL> EuiScreenReaderOnly , <EOL> EuiSpacer , <EOL> EuiTitle , <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> memoizeLast <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisTypeAlias <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> NewVisHelp <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisHelpText <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisTypeIcon <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> VisType , <EOL> TypesStart <EOL> } from '<STR_LIT>' ; <EOL> interface VisTypeListEntry { <EOL> type : VisType | VisTypeAlias ; highlighted : boolean ; <EOL> } <EOL> interface TypeSelectionProps { <EOL> addBasePath : ( path : string ) = > string ; onVisTypeSelected : ( visType : VisType | VisTypeAlias ) = > void ; visTypesRegistry : TypesStart ; showExperimental : boolean ; <EOL> } <EOL> interface HighlightedType { <EOL> name : string ; title : string ; description   ? : string ; highlightMsg   ? : string ; <EOL> } <EOL> interface TypeSelectionState { <EOL> highlightedType : HighlightedType | null ; query : string ; <EOL> } <EOL> function isVisTypeAlias ( type ) { <EOL> return '<STR_LIT>' in type ; <EOL> } <EOL> class TypeSelection extends React . Component < TypeSelectionProps , TypeSelectionState > { <EOL> public state : TypeSelectionState = { <EOL> highlightedType : null , <EOL> query : '<STR_LIT>' , <EOL> } ; private readonly getFilteredVisTypes = memoizeLast ( this . filteredVisTypes ) ; public render ( ) { <EOL> const { <EOL> query , <EOL> highlightedType <EOL> } = this . state ; <EOL> const visTypes = this . getFilteredVisTypes ( this . props . visTypesRegistry , query ) ; <EOL> return ( < React . Fragment > < EuiModalHeader > < EuiModalHeaderTitle > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / EuiModalHeaderTitle > < / EuiModalHeader > < div className = "<STR_LIT>" > < EuiFlexGroup gutterSize = "<STR_LIT>" > < EuiFlexItem > < EuiFlexGroup className = "<STR_LIT>" direction = "<STR_LIT>" gutterSize = "<STR_LIT>" responsive = { false } > < EuiFlexItem grow = { false } className = "<STR_LIT>" > < EuiFieldSearch placeholder = "<STR_LIT>" value = { query } onChange = { this . onQueryChange } fullWidth data - test - subj = "<STR_LIT>" aria - label = { i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) } / > < / EuiFlexItem > < EuiFlexItem grow = { <NUM_LIT> } className = "<STR_LIT>" > < EuiScreenReaderOnly > < span aria - live = "<STR_LIT>" > { query & & ( < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" values = { { resultCount : visTypes . filter ( ( type ) = > type . highlighted ) . length , } } / > ) } < / span > < / EuiScreenReaderOnly > < EuiKeyPadMenu className = "<STR_LIT>" data - test - subj = "<STR_LIT>" > { visTypes . map ( this . renderVisType ) } < / EuiKeyPadMenu > < / EuiFlexItem > < / EuiFlexGroup > < / EuiFlexItem > < EuiFlexItem className = "<STR_LIT>" grow = { false } > { highlightedType   ? ( < VisHelpText { ... highlightedType } / > ) : ( < React . Fragment > < EuiTitle size = "<STR_LIT>" > < h2 > < FormattedMessage id = "<STR_LIT>" defaultMessage = "<STR_LIT>" / > < / h2 > < / EuiTitle > < EuiSpacer size = "<STR_LIT>" / > < NewVisHelp promotedTypes = { visTypes . map ( ( t ) = > t . type ) . filter ( ( t ) : t is VisTypeAlias = > isVisTypeAlias ( t ) & & Boolean ( t . promotion ) ) } onPromotionClicked = { this . props . onVisTypeSelected } / > < / React . Fragment > ) } < / EuiFlexItem > < / EuiFlexGroup > < / div > < / React . Fragment > ) ; } private filteredVisTypes ( visTypes , query ) { const types = visTypes . all ( ) . filter ( ( type ) = > { if (   ! this . props . showExperimental & & type . stage == = '<STR_LIT>' ) { return false ; } if ( type . hidden ) { return false ; } return true ; } ) ; const allTypes = [ ... types , ... visTypes . getAliases ( ) ] ; let entries ; if (   ! query ) { entries = allTypes . map ( ( type ) = > ( { type , highlighted : false } ) ) ; } else { const q = query . toLowerCase ( ) ; entries = allTypes . map ( ( type ) = > { const matchesQuery = type . name . toLowerCase ( ) . includes ( q ) | | type . title . toLowerCase ( ) . includes ( q ) | | ( typeof type . description == = '<STR_LIT>' & & type . description . toLowerCase ( ) . includes ( q ) ) ; return { type , highlighted : matchesQuery } ; } ) ; } return orderBy ( entries , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; } private renderVisType = ( visType ) = > { let stage = { } ; let highlightMsg ; if (   ! isVisTypeAlias ( visType . type ) & & visType . type . stage == = '<STR_LIT>' ) { stage = { betaBadgeLabel : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , betaBadgeTooltipContent : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , } ; highlightMsg = i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) ; } else if ( isVisTypeAlias ( visType . type ) & & visType . type . stage == = '<STR_LIT>' ) { const aliasDescription = i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) ; stage = { betaBadgeLabel : i18n . translate ( '<STR_LIT>' , { defaultMessage : '<STR_LIT>' , } ) , betaBadgeTooltipContent : aliasDescription , } ; highlightMsg = aliasDescription ; } const isDisabled = this . state . query != = '<STR_LIT>' & &   ! visType . highlighted ; const onClick = ( ) = > this . props . onVisTypeSelected ( visType . type ) ; const highlightedType = { title : visType . type . title , name : visType . type . name , description : visType . type . description , highlightMsg , } ; return ( < EuiKeyPadMenuItem key = { visType . type . name } label = { < span data - test - subj = "<STR_LIT>" > { visType . type . title } < / span > } onClick = { onClick } onFocus = { ( ) = > this . setHighlightType ( highlightedType ) } onMouseEnter = { ( ) = > this . setHighlightType ( highlightedType ) } onMouseLeave = { ( ) = > this . setHighlightType ( null ) } onBlur = { ( ) = > this . setHighlightType ( null ) } className = "<STR_LIT>" data - test - subj = { ` visType - $ { visType . type . name } ` } data - vis - stage = { ! isVisTypeAlias ( visType . type )   ? visType . type . stage : '<STR_LIT>' } disabled = { isDisabled } aria - describedby = { ` visTypeDescription - $ { visType . type . name } ` } { ... stage } > < VisTypeIcon icon = { visType . type . icon == = '<STR_LIT>'   ? '<STR_LIT>' : visType . type . icon } image = { '<STR_LIT>' in visType . type   ? visType . type . image : '<STR_LIT>' } / > < / EuiKeyPadMenuItem > ) ; } ; private setHighlightType ( highlightedType ) { this . setState ( { highlightedType , } ) ; } private onQueryChange = ( ev ) = > { this . setState ( { query : ev . target . value , } ) ; } ; } export { TypeSelection } ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> EuiButton , <EOL> EuiSpacer , <EOL> EuiText <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ApplicationStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> OsdError <EOL> } from '<STR_LIT>' ; <EOL> export enum TimeoutErrorMode { <EOL> UPGRADE , <EOL> CONTACT , <EOL> CHANGE <EOL> } <EOL> param { <EOL> Error <EOL> } <EOL> err <EOL> export class SearchTimeoutError extends OsdError { <EOL> public mode : TimeoutErrorMode ; <EOL> constructor ( err , mode ) { <EOL> super ( ` Request timeout :   $ { JSON . stringify ( err   ? . message ) } ` ) ; <EOL> this . mode = mode ; <EOL> } <EOL> private getMessage ( ) { <EOL> switch ( this . mode ) { <EOL> case TimeoutErrorMode . UPGRADE : <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> case TimeoutErrorMode . CONTACT : <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> case TimeoutErrorMode . CHANGE : <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> } <EOL> } <EOL> private getActionText ( ) { <EOL> switch ( this . mode ) { <EOL> case TimeoutErrorMode . UPGRADE : <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> break ; <EOL> case TimeoutErrorMode . CHANGE : <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> break ; <EOL> } <EOL> } <EOL> private onClick ( application ) { <EOL> switch ( this . mode ) { <EOL> case TimeoutErrorMode . UPGRADE : <EOL> application . navigateToUrl ( '<STR_LIT>' ) ; <EOL> break ; <EOL> case TimeoutErrorMode . CHANGE : <EOL> application . navigateToApp ( '<STR_LIT>' , { <EOL> path :   ` / opensearch - dashboards / settings ` , <EOL> } ) ; <EOL> break ; <EOL> } <EOL> } <EOL> public getErrorMessage ( application ) { <EOL> const actionText = this . getActionText ( ) ; <EOL> return ( < > { this . getMessage ( ) } { actionText & & ( < > < EuiSpacer size = "<STR_LIT>" / > < EuiText textAlign = "<STR_LIT>" > < EuiButton color = "<STR_LIT>" onClick = { ( ) = > this . onClick ( application ) } size = "<STR_LIT>" data - test - subj = "<STR_LIT>" > { actionText } < / EuiButton > < / EuiText > < / > ) } < / > ) ; } } </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ExpressionFunctionDefinition <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> getIndexPatterns <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IndexPatternSpec <EOL> } from '<STR_LIT>' ; <EOL> const name = '<STR_LIT>' ; <EOL> type Input = null ; <EOL> type Output = Promise < { <EOL> type : '<STR_LIT>' ; value : IndexPatternSpec ; <EOL> } > ; <EOL> interface Arguments { <EOL> id : string ; <EOL> } <EOL> export const indexPatternLoad = ( ) : ExpressionFunctionDefinition < typeof name , <EOL> Input , Arguments , Output > = > ( { <EOL> name , <EOL> type : '<STR_LIT>' , <EOL> inputTypes : [ '<STR_LIT>' ] , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> args : { <EOL> id : { <EOL> types : [ '<STR_LIT>' ] , <EOL> required : true , <EOL> help : i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) , <EOL> } , <EOL> } , <EOL> async fn ( input , args ) { <EOL> const indexPatterns = getIndexPatterns ( ) ; <EOL> const indexPattern = await indexPatterns . get ( args . id ) ; <EOL> return { <EOL> type : '<STR_LIT>' , <EOL> value : indexPattern . toSpec ( ) <EOL> } ; <EOL> } , <EOL> } ) ; </s>
<s> import React from '<STR_LIT>' ; <EOL> import { <EOL> Subscription <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> PanelState , <EOL> EmbeddableStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DashboardContainer , <EOL> DashboardReactContextValue <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> DashboardGrid <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> context <EOL> } from '<STR_LIT>' ; <EOL> export interface DashboardViewportProps { <EOL> container : DashboardContainer ; PanelComponent : EmbeddableStart [ '<STR_LIT>' ] ; renderEmpty   ? : ( ) = > React . ReactNode ; <EOL> } <EOL> interface State { <EOL> isFullScreenMode : boolean ; useMargins : boolean ; title : string ; description   ? : string ; panels : { <EOL> [ key ] : PanelState ; <EOL> } ; isEmbeddedExternally   ? : boolean ; isEmptyState   ? : boolean ; <EOL> } <EOL> export class DashboardViewport extends React . Component < DashboardViewportProps , State > { <EOL> static contextType = context ; public readonly context ! : DashboardReactContextValue ; private subscription   ? : Subscription ; private mounted : boolean = false ; constructor ( props ) { <EOL> super ( props ) ; <EOL> const { <EOL> isFullScreenMode , <EOL> panels , <EOL> useMargins , <EOL> title , <EOL> isEmbeddedExternally , <EOL> isEmptyState , <EOL> } = this . props . container . getInput ( ) ; <EOL> this . state = { <EOL> isFullScreenMode , <EOL> panels , <EOL> useMargins , <EOL> title , <EOL> isEmbeddedExternally , <EOL> isEmptyState , <EOL> } ; <EOL> } <EOL> public componentDidMount ( ) { <EOL> this . mounted = true ; <EOL> this . subscription = this . props . container . getInput $ ( ) . subscribe ( ( ) = > { <EOL> const { <EOL> isFullScreenMode , <EOL> useMargins , <EOL> title , <EOL> description , <EOL> isEmbeddedExternally , <EOL> isEmptyState , <EOL> } = this . props . container . getInput ( ) ; <EOL> if ( this . mounted ) { <EOL> this . setState ( { <EOL> isFullScreenMode , <EOL> description , <EOL> useMargins , <EOL> title , <EOL> isEmbeddedExternally , <EOL> isEmptyState , <EOL> } ) ; <EOL> } <EOL> } ) ; <EOL> } <EOL> public componentWillUnmount ( ) { <EOL> this . mounted = false ; <EOL> if ( this . subscription ) { <EOL> this . subscription . unsubscribe ( ) ; <EOL> } <EOL> } <EOL> public onExitFullScreenMode = ( ) = > { <EOL> this . props . container . updateInput ( { <EOL> isFullScreenMode : false , <EOL> } ) ; <EOL> } ; private renderEmptyScreen ( ) { <EOL> const { <EOL> renderEmpty <EOL> } = this . props ; <EOL> const { <EOL> isEmbeddedExternally , <EOL> isFullScreenMode <EOL> } = this . state ; <EOL> return ( < div className = "<STR_LIT>" > { isFullScreenMode & & ( < this . context . services . ExitFullScreenButton onExitFullScreenMode = { this . onExitFullScreenMode } toggleChrome = {   ! isEmbeddedExternally } / > ) } { renderEmpty & & renderEmpty ( ) } < / div > ) ; } private renderContainerScreen ( ) { const { container , PanelComponent } = this . props ; const { isEmbeddedExternally , isFullScreenMode , panels , title , description , useMargins , } = this . state ; return ( < div data - shared - items - count = { Object . values ( panels ) . length } data - shared - items - container data - title = { title } data - description = { description } className = { useMargins   ? '<STR_LIT>' : '<STR_LIT>' } > { isFullScreenMode & & ( < this . context . services . ExitFullScreenButton onExitFullScreenMode = { this . onExitFullScreenMode } toggleChrome = {   ! isEmbeddedExternally } / > ) } < DashboardGrid container = { container } PanelComponent = { PanelComponent } / > < / div > ) ; } public render ( ) { return ( < React . Fragment > { this . state . isEmptyState   ? this . renderEmptyScreen ( ) : null } { this . renderContainerScreen ( ) } < / React . Fragment > ) ; } } </s>
<s> import { <EOL> EuiCallOut <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import React from '<STR_LIT>' ; <EOL> import { <EOL> CoreStart <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> toMountPoint <EOL> } from '<STR_LIT>' ; <EOL> let bannerId ; <EOL> export const onRedirectNoIndexPattern = ( capabilities , navigateToApp , overlays ) = > ( ) = > { <EOL> const canManageIndexPatterns = capabilities . management . opensearchDashboards . indexPatterns ; <EOL> const redirectTarget = canManageIndexPatterns   ? '<STR_LIT>' : '<STR_LIT>' ; <EOL> let timeoutId ; <EOL> if ( timeoutId ) { <EOL> clearTimeout ( timeoutId ) ; <EOL> } <EOL> const bannerMessage = i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> bannerId = overlays . banners . replace ( bannerId , toMountPoint ( < EuiCallOut color = "<STR_LIT>" iconType = "<STR_LIT>" title = { bannerMessage } / > ) ) ; <EOL> timeoutId = setTimeout ( ( ) = > { <EOL> overlays . banners . remove ( bannerId ) ; <EOL> timeoutId = undefined ; <EOL> } , <NUM_LIT> ) ; <EOL> if ( redirectTarget == = '<STR_LIT>' ) { <EOL> navigateToApp ( '<STR_LIT>' ) ; <EOL> } else { <EOL> navigateToApp ( '<STR_LIT>' , { <EOL> path :   ` / opensearch - dashboards / indexPatterns ? bannerMessage = $ { bannerMessage } ` , <EOL> } ) ; <EOL> } <EOL> return new Promise ( ( ) = > { } ) ; <EOL> } ; </s>
<s> import { <EOL> i18n <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Action , <EOL> IncompatibleActionError <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ContainerInput , <EOL> IContainer <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> ViewMode <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> IEmbeddable <EOL> } from '<STR_LIT>' ; <EOL> export const REMOVE_PANEL_ACTION = '<STR_LIT>' ; <EOL> interface ExpandedPanelInput extends ContainerInput { <EOL> expandedPanelId : string ; <EOL> } <EOL> interface ActionContext { <EOL> embeddable : IEmbeddable ; <EOL> } <EOL> function hasExpandedPanelInput ( container ) { <EOL> return ( container as IContainer < { } , ExpandedPanelInput > ) . getInput ( ) . expandedPanelId != = undefined ; <EOL> } <EOL> export class RemovePanelAction implements Action < ActionContext > { <EOL> public readonly type = REMOVE_PANEL_ACTION ; public readonly id = REMOVE_PANEL_ACTION ; public order = <NUM_LIT> ; constructor ( ) { } <EOL> public getDisplayName ( ) { <EOL> return i18n . translate ( '<STR_LIT>' , { <EOL> defaultMessage : '<STR_LIT>' , <EOL> } ) ; <EOL> } <EOL> public getIconType ( ) { <EOL> return '<STR_LIT>' ; <EOL> } <EOL> public async isCompatible ( { <EOL> embeddable <EOL> } ) { <EOL> const isPanelExpanded = embeddable . parent & & hasExpandedPanelInput ( embeddable . parent ) & & embeddable . parent . getInput ( ) . expandedPanelId == = embeddable . id ; <EOL> return Boolean ( embeddable . parent & & embeddable . getInput ( ) . viewMode == = ViewMode . EDIT & &   ! isPanelExpanded ) ; <EOL> } <EOL> public async execute ( { <EOL> embeddable <EOL> } ) { <EOL> if ( ! embeddable . parent | |   ! ( await this . isCompatible ( { <EOL> embeddable <EOL> } ) ) ) { <EOL> throw new IncompatibleActionError ( ) ; <EOL> } <EOL> embeddable . parent . removeEmbeddable ( embeddable . id ) ; <EOL> } <EOL> } </s>
<s> import { <EOL> ApplicationImpl , <EOL> DatetimeProjectItemImpl , <EOL> ElectronExecutor , <EOL> Group , <EOL> GroupName , <EOL> Platform <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> BrowserId , <EOL> getDefaultConfigPath , <EOL> SqliteBrowserApplicationImpl <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> execFileSync <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> isEmpty , <EOL> unique <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> removeAllQueryFromUrl <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Context <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> i18n , <EOL> sentenceKey <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> generatePinyinIndex <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> generateHostIndex <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> parseSqliteDefaultResult <EOL> } from '<STR_LIT>' ; <EOL> const CHROMIUM = '<STR_LIT>' ; <EOL> const configName = '<STR_LIT>' ; <EOL> const handler = text = >   ` $ { configName }   $ { i18n . t ( sentenceKey . browserPathDescPrefix ) }   $ { text } ` ; <EOL> export class ChromiumHistoryProjectItemImpl extends DatetimeProjectItemImpl { } <EOL> export class ChromiumHistoryApplicationImpl extends SqliteBrowserApplicationImpl < ChromiumHistoryProjectItemImpl > { <EOL> private readonly browserId : BrowserId ; constructor ( id , name , type , platforms = [ Platform . win32 , Platform . darwin , Platform . linux ] , description = true , beta = false , configName = '<STR_LIT>' ) { <EOL> super ( ` $ { id } - history ` ,   ` $ { name } ` ,   ` icon / browser - $ { id } . png ` , type , platforms , Group [ GroupName . browserHistory ] , description   ? ( ) = > handler ( this . defaultConfigPath ( ) ) : undefined , beta , configName ) ; <EOL> this . browserId = id ; <EOL> } <EOL> override defaultConfigPath ( ) { <EOL> return   ` $ { getDefaultConfigPath ( this . browserId ) } $ { configName } ` ; <EOL> } <EOL> async generateCacheProjectItems ( context ) { <EOL> let items = [ ] ; <EOL> let sql = '<STR_LIT>' + context . browserHistoryLimit ; <EOL> let result = '<STR_LIT>' ; <EOL> await this . copyAndReadFile ( this . config , path = > { <EOL> result = execFileSync ( this . executor , [ path , sql , '<STR_LIT>' ] , { <EOL> encoding : '<STR_LIT>' , <EOL> maxBuffer : <NUM_LIT> <EOL> } ) ; <EOL> } ) ; <EOL> if ( ! isEmpty ( result ) ) { <EOL> let array = parseSqliteDefaultResult ( result , [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] ) ; <EOL> array . forEach ( i = > { <EOL> let title = i [ '<STR_LIT>' ]   ? ? '<STR_LIT>' ; <EOL> let url = i [ '<STR_LIT>' ]   ? ? '<STR_LIT>' ; <EOL> items . push ( { <EOL> id : '<STR_LIT>' , <EOL> title : title , <EOL> description : url , <EOL> icon : this . ifGetFavicon ( removeAllQueryFromUrl ( url ) , context ) , <EOL> searchKey : unique ( [ ... generatePinyinIndex ( context , title ) , ... generateHostIndex ( context , url ) , title , ] ) , <EOL> exists : true , <EOL> command : new ElectronExecutor ( url ) , <EOL> datetime : i [ '<STR_LIT>' ]   ? ? <NUM_LIT> , <EOL> } ) ; <EOL> } ) ; <EOL> } <EOL> return items ; <EOL> } <EOL> } <EOL> export const applications = [ new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , undefined , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , undefined , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , undefined , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , [ Platform . win32 ] , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , [ Platform . win32 ] , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , undefined , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , undefined , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , undefined , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , [ Platform . win32 ] , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , undefined , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , [ Platform . win32 ] , false , undefined , configName ) , new ChromiumHistoryApplicationImpl ( '<STR_LIT>' , '<STR_LIT>' , CHROMIUM , [ Platform . linux ] , false , undefined , configName ) , ] ; </s>
<s> import { <EOL> decorateQuery <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> luceneStringToDsl <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> Query <EOL> } from '<STR_LIT>' ; <EOL> export function buildQueryFromLucene ( queries , queryStringOptions , dateFormatTZ   ? ) { <EOL> const combinedQueries = ( queries | | [ ] ) . map ( ( query ) = > { <EOL> const queryDsl = luceneStringToDsl ( query . query ) ; <EOL> return decorateQuery ( queryDsl , queryStringOptions , dateFormatTZ ) ; <EOL> } ) ; <EOL> return { <EOL> must : combinedQueries , <EOL> filter : [ ] , <EOL> should : [ ] , <EOL> must_not : [ ] , <EOL> } ; <EOL> } </s>
<s> import * as ast from '<STR_LIT>' ; <EOL> import * as literal from '<STR_LIT>' ; <EOL> import { <EOL> IIndexPattern , <EOL> KueryNode <EOL> } from '<STR_LIT>' ; <EOL> export function buildNodeParams ( path , child ) { <EOL> const pathNode = typeof path == = '<STR_LIT>'   ? ast . fromLiteralExpression ( path ) : literal . buildNode ( path ) ; <EOL> return { <EOL> arguments : [ pathNode , child ] , <EOL> } ; <EOL> } <EOL> export function toOpenSearchQuery ( node , indexPattern   ? , config = { } , context = { } ) { <EOL> const [ path , child ] = node . arguments ; <EOL> const stringPath = ast . toOpenSearchQuery ( path ) ; <EOL> const fullPath = context ? . nested ? . path   ?   ` $ { context . nested . path } . $ { stringPath } ` : stringPath ; <EOL> return { <EOL> nested : { <EOL> path : fullPath , <EOL> query : ast . toOpenSearchQuery ( child , indexPattern , config , { <EOL> ... context , <EOL> nested : { <EOL> path : fullPath <EOL> } , <EOL> } ) , <EOL> score_mode : '<STR_LIT>' , <EOL> } , <EOL> } ; <EOL> } </s>
<s> import { <EOL> Injectable <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> RavenErrorHandler <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> MissingTranslationHandler , <EOL> MissingTranslationHandlerParams <EOL> } from '<STR_LIT>' ; <EOL> @ Injectable ( ) export class TranslationErrorService implements MissingTranslationHandler { <EOL> constructor ( private errorHandler ) { } <EOL> handle ( params ) { <EOL> this . errorHandler . handleError ( ` Missing Translation :   $ { params . key } ` ) ; <EOL> } <EOL> } </s>
<s> import * as React from '<STR_LIT>' ; <EOL> import { <EOL> useId <EOL> } from '<STR_LIT>' ; <EOL> import { <EOL> wrapEvent <EOL> } from '<STR_LIT>' ; <EOL> const AccordionContext = React . createContext ( ) ; <EOL> / ** <EOL> * Accordion <EOL> * / <EOL> export const Accordion = React . forwardRef ( ( { <EOL> children , <EOL> onChange , <EOL> defaultIndex = <NUM_LIT> , <EOL> id , <EOL> ... props <EOL> } , forwardedRef ) = > { <EOL> const [ selectedIndex , setSelectedIndex ] = React . useState ( defaultIndex ) ; <EOL> const accordionId = useId ( id ) ; <EOL> children = React . Children . map ( children , ( child , index ) = > { <EOL> const panelId =   ` accordion - $ { accordionId } - panel - $ { index } ` ; <EOL> const buttonId =   ` accordion - $ { accordionId } - button - $ { index } ` ; <EOL> const context = { <EOL> buttonId , <EOL> panelId , <EOL> selected : selectedIndex == = index , <EOL> selectPanel : ( ) = > { <EOL> onChange & & onChange ( index ) ; <EOL> setSelectedIndex ( index ) ; <EOL> } , <EOL> } ; <EOL> return < AccordionContext . Provider value = { context } children = { child } / > ; <EOL> } ) ; <EOL> return ( < div data - accordion = "<STR_LIT>" ref = { forwardedRef } { ... props } > { children } < / div > ) ; } ) ; Accordion . displayName = '<STR_LIT>' ; / ** <EOL> * Accordion Item <EOL> * / export const AccordionItem = React . forwardRef ( ( { children , ... props } , forwardedRef ) = > { const { selected } = React . useContext ( AccordionContext ) ; return ( < div { ... props } data - accordion - item = "<STR_LIT>" data - state = { selected   ? '<STR_LIT>' : '<STR_LIT>' } ref = { forwardedRef } > { children } < / div > ) ; } ) ; AccordionItem . displayName = '<STR_LIT>' ; / ** <EOL> * Accordion Button <EOL> * / export const AccordionButton = React . forwardRef ( ( { children , onClick , ... props } , forwardedRef ) = > { const { panelId , selected , selectPanel } = React . useContext ( AccordionContext ) ; return ( < button { ... props } onClick = { wrapEvent ( onClick , selectPanel ) } data - accordion - button = "<STR_LIT>" data - state = { selected   ? '<STR_LIT>' : '<STR_LIT>' } aria - expanded = { selected } aria - controls = { panelId } ref = { forwardedRef } > { children } < / button > ) ; } ) ; AccordionButton . displayName = '<STR_LIT>' ; / ** <EOL> * Accordion Panel <EOL> * / export const AccordionPanel = React . forwardRef ( ( { children , ... props } , forwardedRef ) = > { const { buttonId , panelId , selected } = React . useContext ( AccordionContext ) ; return ( < div role = "<STR_LIT>" { ... props } id = { panelId } aria - labelledby = { buttonId } hidden = {   ! selected } data - accordion - panel = "<STR_LIT>" data - state = { selected   ? '<STR_LIT>' : '<STR_LIT>' } ref = { forwardedRef } > { children } < / div > ) ; } ) ; AccordionPanel . displayName = '<STR_LIT>' ; </s>
<s> import { <EOL> ASTNode <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> callcc <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> getEnvironmentForValue , <EOL> GetValue <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> apply , <EOL> at , <EOL> evaluate , <EOL> evaluateArray , <EOL> get , <EOL> getProperty , <EOL> setProperty , <EOL> visitArray <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> LocatedException , <EOL> NotImplementedException , <EOL> toException <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> bindArgs <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> createMetaFunctionWrapper , <EOL> evaluateMetaFunction , <EOL> getMetaFunction , <EOL> isMetaFunction <EOL> } from "<STR_LIT>" ; <EOL> import * as NodeTypes from "<STR_LIT>" ; <EOL> import { <EOL> Interpreter <EOL> } from "<STR_LIT>" ; <EOL> import { <EOL> createClass <EOL> } from "<STR_LIT>" ; <EOL> const concatSpreads = ( all , next ) = > ( next instanceof SpreadElementValue   ? all . concat ( next . value ) : all . concat ( [ next ] ) ) ; <EOL> export const CallExpression = ( e , c , cerr , env , config ) = > evaluateArray ( e . arguments , ( args ) = > { <EOL> args = args . reduce ( concatSpreads , [ ] ) ; <EOL> switch ( e . callee . type ) { <EOL> case "<STR_LIT>" : <EOL> evaluate ( get ( "<STR_LIT>" ) , ( thisValue ) = > evaluate ( at ( e , apply ( Object . getPrototypeOf ( thisValue ) . constructor , thisValue , args , e ) ) , c , cerr , env , config ) , cerr , env , config ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> case "<STR_LIT>" : <EOL> case "<STR_LIT>" : <EOL> case "<STR_LIT>" : <EOL> evaluate ( e . callee , ( callee ) = > { <EOL> if ( typeof callee == = "<STR_LIT>" ) { <EOL> try { <EOL> if ( callee == = callcc ) { <EOL> try { <EOL> const [ receiver , _arguments ] = args ; <EOL> receiver ( _arguments , c , cerr , env , config ) ; <EOL> } catch ( e ) { <EOL> cerr ( toException ( e ) ) ; <EOL> } <EOL> } else { <EOL> evaluate ( at ( e , apply ( callee , undefined , args , e ) ) , c , cerr , env , config ) ; <EOL> } <EOL> } catch ( error ) { <EOL> cerr ( toException ( error , e . callee ) ) ; <EOL> } <EOL> } else { <EOL> cerr ( toException ( new TypeError ( callee + "<STR_LIT>" ) , e . callee ) ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> const e_callee = e . callee ; <EOL> evaluate ( e . callee . object , ( object ) = > { <EOL> function evalApply ( property ) { <EOL> if ( typeof property == = "<STR_LIT>" ) { <EOL> evaluate ( at ( e , apply ( property , object , args , e ) ) , c , cerr , env , config ) ; <EOL> } else { <EOL> const source = config . script . source ; <EOL> const callee = typeof source == = "<STR_LIT>"   ? source . substring ( ... e . callee . range ! ) : "<STR_LIT>" ; <EOL> cerr ( LocatedException ( new TypeError ( callee + "<STR_LIT>" ) , e . callee ) ) ; <EOL> } <EOL> } <EOL> if ( ! e_callee . computed & & e_callee . property . type == = "<STR_LIT>" ) { <EOL> evaluate ( at ( e_callee , getProperty ( object , e_callee . property . name ) ) , evalApply , cerr , env , config ) ; <EOL> } else { <EOL> evaluate ( e_callee . property , ( propertyValue ) = > evaluate ( at ( e_callee , getProperty ( object , propertyValue ) ) , evalApply , cerr , env , config ) , cerr , env , config ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> evaluate ( e . callee , ( callee ) = > { <EOL> try { <EOL> const cnt = ( thisValue   ? ) = > evaluate ( at ( e , apply ( callee , thisValue , args , e ) ) , c , cerr , env , config ) ; <EOL> evaluate ( at ( e . callee , get ( "<STR_LIT>" ) ) , cnt , ( ) = > cnt ( undefined ) , env , config ) ; <EOL> } catch ( error ) { <EOL> cerr ( toException ( error , e . callee ) ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( ` '<STR_LIT>' callee node is not supported yet . ` , e . callee ) ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> export const MemberExpression = ( e , c , cerr , env , config ) = > evaluate ( e . object , ( object ) = > { <EOL> function getProp ( ) { <EOL> evaluate ( e . property , ( property ) = > evaluate ( at ( e . property , getProperty ( object , property ) ) , c , cerr , env , config ) , cerr , env , config ) ; <EOL> } <EOL> if ( e . computed ) { <EOL> getProp ( ) ; <EOL> } else { <EOL> switch ( e . property . type ) { <EOL> case "<STR_LIT>" : <EOL> if ( e . computed ) { <EOL> getProp ( ) ; <EOL> } else { <EOL> switch ( e . property . type ) { <EOL> case "<STR_LIT>" : <EOL> evaluate ( at ( e . property , getProperty ( object , e . property . name ) ) , c , cerr , env , config ) ; <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( ` Not implemented   $ { e . property [ "<STR_LIT>" ] } property type of   $ { e . type } ` ) ) ; <EOL> } <EOL> } <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( "<STR_LIT>" ) ) ; <EOL> } <EOL> } <EOL> } , cerr , env , config ) ; <EOL> const _createMetaFunction = ( e , c , cerr , env , config ) = > { <EOL> try { <EOL> c ( createMetaFunctionWrapper ( { <EOL> e , <EOL> closure : env , <EOL> config <EOL> } ) ) ; <EOL> } catch ( error ) { <EOL> cerr ( LocatedException ( error , e ) ) ; <EOL> } <EOL> } ; <EOL> export const ArrowFunctionExpression = ( e , c , cerr , env , config ) = > _createMetaFunction ( e , c , cerr , env , config ) ; <EOL> export const FunctionExpression = ( e , c , cerr , env , config ) = > _createMetaFunction ( e , c , cerr , env , config ) ; <EOL> export const AssignmentExpression = ( e , c , cerr , env , config ) = > evaluate ( e . right , ( right ) = > { <EOL> const e_left = e . left ; <EOL> switch ( e_left . type ) { <EOL> case "<STR_LIT>" : <EOL> evaluate ( at ( e_left , get ( e_left . name ) ) , ( ) = > evaluate ( setProperty ( getEnvironmentForValue ( env , e_left . name ) ? . values , e_left . name , right , e . operator ) , c , cerr , env , config ) , cerr , env , config ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> evaluate ( e_left . object , ( object ) = > { <EOL> const property = e_left . property ; <EOL> if ( e_left . computed ) { <EOL> evaluate ( e_left . property , ( property ) = > evaluate ( at ( e , setProperty ( object , property , right , e . operator ) ) , c , cerr , env , config ) , cerr , env , config ) ; <EOL> } else if ( property . type == = "<STR_LIT>" ) { <EOL> evaluate ( at ( e , setProperty ( object , property . name , right , e . operator ) ) , c , cerr , env , config ) ; <EOL> } else { <EOL> cerr ( NotImplementedException ( "<STR_LIT>" , property ) ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( "<STR_LIT>" ) ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> export const ObjectExpression = ( e , c , cerr , env , config ) = > { <EOL> let result = { } ; <EOL> visitArray ( e . properties , ( itemNode , c , cerr ) = > evaluate ( itemNode , function ( item ) { <EOL> if ( item instanceof SpreadElementValue ) { <EOL> c ( ( result = Object . assign ( result , item . value ) ) ) ; <EOL> } else { <EOL> const { <EOL> key , <EOL> value <EOL> } = item ; <EOL> c ( ( result [ key ] = value ) ) ; <EOL> } <EOL> } , cerr , env , config ) , ( ) = > c ( result ) , cerr ) ; <EOL> } ; <EOL> export const Property = ( e , c , cerr , env , config ) = > { <EOL> if ( e . computed ) { <EOL> evaluate ( e . key , ( key ) = > evaluate ( e . value , ( value ) = > c ( { <EOL> key , <EOL> value <EOL> } ) , cerr , env , config ) , cerr , env , config ) ; <EOL> } else { <EOL> let key ; <EOL> switch ( e . key . type ) { <EOL> case "<STR_LIT>" : <EOL> key = e . key . name ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> key = e . key . value ; <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( ` '<STR_LIT>' property key type is not supported yet . ` ) ) ; <EOL> return ; <EOL> } <EOL> evaluate ( e . value , ( value ) = > c ( { <EOL> key , <EOL> value <EOL> } ) , cerr , env , config ) ; <EOL> } <EOL> } ; <EOL> export const BinaryExpression = ( e , c , cerr , env , config ) = > evaluate ( e . left , ( left ) = > evaluate ( e . right , ( right ) = > { <EOL> switch ( e . operator ) { <EOL> case "<STR_LIT>" : <EOL> c ( left + right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left - right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left == = right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left == right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left != = right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left != right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left < right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left <= right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left > right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left >= right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left * right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left / right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left instanceof right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left in right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left ^ right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left << right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left >> right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left >> > right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left % right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left & right ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( left | right ) ; <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( e . type +   ` operator "<STR_LIT>" is not implemented yet . ` , e ) ) ; <EOL> } <EOL> } , cerr , env , config ) , cerr , env , config ) ; <EOL> const nullValueInstance = { } ; <EOL> export const NullValue = ( _ , c ) = > c ( nullValueInstance ) ; <EOL> const nullToASTNode = ( value ) = > ( value == = null   ? { <EOL> type : "<STR_LIT>" <EOL> } : value ) ; <EOL> function deleteNullValues ( array ) { <EOL> let i = array . length ; <EOL> while ( i - - >= <NUM_LIT> ) { <EOL> if ( array [ i ] == = nullValueInstance ) { <EOL> delete array [ i ] ; <EOL> } <EOL> } <EOL> return array ; <EOL> } <EOL> export const ArrayExpression = ( e , c , cerr , env , config ) = > evaluateArray ( e . elements . map ( nullToASTNode ) , ( values ) = > c ( deleteNullValues ( values . reduce ( concatSpreads , [ ] ) ) ) , cerr , env , config ) ; <EOL> export const NewExpression = ( e , c , cerr , env , config ) = > evaluateArray ( e . arguments , ( args ) = > { <EOL> const calleeNode = e . callee ; <EOL> switch ( calleeNode . type ) { <EOL> case "<STR_LIT>" : <EOL> case "<STR_LIT>" : <EOL> case "<STR_LIT>" : <EOL> evaluate ( calleeNode , function ( callee ) { <EOL> if ( isMetaFunction ( callee ) ) { <EOL> const newThis = Object . create ( callee . prototype ) ; <EOL> evaluateMetaFunction ( { <EOL> metaFunction : getMetaFunction ( callee ) , <EOL> thisObject : newThis , <EOL> args <EOL> } , ( value ) = > c ( typeof value == = "<STR_LIT>"   ? value : newThis ) , cerr , undefined , config ) ; <EOL> } else { <EOL> if ( typeof callee != = "<STR_LIT>" ) { <EOL> cerr ( LocatedException ( new TypeError ( typeof callee + "<STR_LIT>" ) , e ) ) ; <EOL> } else { <EOL> try { <EOL> c ( new ( Function . prototype . bind . apply ( callee , [ undefined ] . concat ( args ) ) ) ( ) ) ; <EOL> } catch ( error ) { <EOL> cerr ( toException ( error , calleeNode ) ) ; <EOL> } <EOL> } <EOL> } <EOL> } , cerr , env , config ) ; <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( ` $ { calleeNode [ "<STR_LIT>" ] } type of callee is not supported yet . ` ) ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> export const SequenceExpression = ( e , c , cerr , env , config ) = > evaluateArray ( e . expressions , ( results ) = > ( results . length   ? c ( results [ results . length - <NUM_LIT> ] ) : c ( ) ) , cerr , env , config ) ; <EOL> export const LogicalExpression = ( e , c , cerr , env , config ) = > evaluate ( e . left , ( left ) = > { <EOL> if ( ! left & & e . operator == = "<STR_LIT>" ) { <EOL> c ( left ) ; <EOL> } else if ( left & & e . operator == = "<STR_LIT>" ) { <EOL> c ( left ) ; <EOL> } else { <EOL> evaluate ( e . right , c , cerr , env , config ) ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> export const UpdateExpression = ( e , c , cerr , env , config ) = > { <EOL> function performUpdate ( container , identifierName ) { <EOL> try { <EOL> if ( e . prefix ) { <EOL> switch ( e . operator ) { <EOL> case "<STR_LIT>" : <EOL> c ( + + container [ identifierName ] ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( - - container [ identifierName ] ) ; <EOL> break ; <EOL> default : <EOL> throw NotImplementedException ( ` Support of operator of type '<STR_LIT>' not implemented yet . ` ) ; <EOL> } <EOL> } else { <EOL> switch ( e . operator ) { <EOL> case "<STR_LIT>" : <EOL> c ( container [ identifierName ] + + ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( container [ identifierName ] - - ) ; <EOL> break ; <EOL> default : <EOL> throw NotImplementedException ( ` Support of operator of type '<STR_LIT>' not implemented yet . ` ) ; <EOL> } <EOL> } <EOL> } catch ( e ) { <EOL> cerr ( e ) ; <EOL> } <EOL> } <EOL> let identifierName ; <EOL> switch ( e . argument . type ) { <EOL> case "<STR_LIT>" : <EOL> identifierName = e . argument . name ; <EOL> const variableEnv = getEnvironmentForValue ( env , identifierName )   ! ; <EOL> performUpdate ( variableEnv . values , identifierName ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> const arg = e . argument ; <EOL> if ( arg . property . type == = "<STR_LIT>" ) { <EOL> const cont = ( identifierName ) = > evaluate ( arg . object , ( object ) = > performUpdate ( object , identifierName ) , cerr , env , config ) ; <EOL> if ( arg . computed ) { <EOL> evaluate ( arg . property , cont , cerr , env , config ) ; <EOL> } else { <EOL> cont ( arg . property . name ) ; <EOL> } <EOL> } else { <EOL> cerr ( NotImplementedException ( "<STR_LIT>" , arg ) ) ; <EOL> } <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( ` Support of argument of type '<STR_LIT>' in UpdateExpression is not implemented yet . ` ) ) ; <EOL> } <EOL> } ; <EOL> export const UnaryExpression = ( e , c , cerr , env , config ) = > evaluate ( e . argument , ( argument ) = > { <EOL> switch ( e . operator ) { <EOL> case "<STR_LIT>" : <EOL> c ( typeof argument ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( - argument ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( ! argument ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( + argument ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( ~ argument ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> c ( void argument ) ; <EOL> break ; <EOL> case "<STR_LIT>" : <EOL> switch ( e . argument . type ) { <EOL> case "<STR_LIT>" : <EOL> const name = e . argument . name ; <EOL> const variableEnv = getEnvironmentForValue ( env , name ) ; <EOL> try { <EOL> c ( variableEnv ! . values [ name ] ) ; <EOL> } catch ( e ) { <EOL> cerr ( e ) ; <EOL> } <EOL> break ; <EOL> case "<STR_LIT>" : { <EOL> const argumentNode = e . argument ; <EOL> evaluate ( e . argument . object , ( object ) = > { <EOL> const evalProperty = ( ) = > evaluate ( argumentNode . property , ( property ) = > c ( delete object [ property ] ) , cerr , env , config ) ; <EOL> switch ( argumentNode . property . type ) { <EOL> case "<STR_LIT>" : <EOL> if ( argumentNode . computed ) { <EOL> evalProperty ( ) ; <EOL> } else { <EOL> c ( delete object [ argumentNode . property . name ] ) ; <EOL> } <EOL> break ; <EOL> default : <EOL> evalProperty ( ) ; <EOL> break ; <EOL> } <EOL> } , cerr , env , config ) ; <EOL> break ; <EOL> } <EOL> default : <EOL> cerr ( NotImplementedException ( ` Delete on operator of type "<STR_LIT>" is not implemented yet . ` ) ) ; <EOL> break ; <EOL> } <EOL> break ; <EOL> default : <EOL> cerr ( NotImplementedException ( ` Support for "<STR_LIT>" operator is not implemented yet ` ) ) ; <EOL> } <EOL> } , ( error ) = > e . operator == = "<STR_LIT>" & & e . argument . type == = "<STR_LIT>" & & error . value instanceof ReferenceError   ? c ( "<STR_LIT>" ) : cerr ( error ) , env , config ) ; <EOL> export const ThisExpression = ( e , c , cerr , env , config ) = > evaluate ( at ( e , get ( "<STR_LIT>" ) ) , c , cerr , env , config ) ; <EOL> export const ConditionalExpression = ( e , c , cerr , env , config ) = > GetValue ( { <EOL> name : "<STR_LIT>" <EOL> } , bindArgs ( e , c , cerr , env , config ) , cerr , config . interpreters ) ; <EOL> export const TemplateLiteral = ( e , c , cerr , env , config ) = > { <EOL> if ( e . quasis . length == = <NUM_LIT> & & e . expressions . length == = <NUM_LIT> ) { <EOL> c ( e . quasis [ <NUM_LIT> ] . value . raw ) ; <EOL> } else { <EOL> evaluateArray ( e . expressions , ( expressions ) = > c ( expressions . map ( ( expr , i ) = > e . quasis [ i ] . value . raw + expr ) . join ( "<STR_LIT>" ) + e . quasis [ e . quasis . length - <NUM_LIT> ] . value . raw ) , cerr , env , config ) ; <EOL> } <EOL> } ; <EOL> export const TaggedTemplateExpression = ( e , c , cerr , env , config ) = > evaluate ( e . tag , ( tag ) = > typeof tag == = "<STR_LIT>"   ? evaluate ( e . quasi , ( quasi ) = > evaluate ( at ( e . quasi , apply ( tag , undefined , [ quasi ] , e ) ) , c , cerr , env , config ) , cerr , env , config ) : cerr ( toException ( new TypeError ( ` Template expression tag is not a function ` ) , e . tag ) ) , cerr , env , config ) ; <EOL> class SpreadElementValue { <EOL> constructor ( public value ) { } <EOL> } <EOL> export const SpreadElement = ( e , c , cerr , env , config ) = > evaluate ( e . argument , ( value ) = > c ( new SpreadElementValue ( value ) ) , cerr , env , config ) ; <EOL> export const AwaitExpression = ( e , c , cerr , env , config ) = > evaluate ( e . argument , ( arg ) = > ( typeof arg == = "<STR_LIT>" & & arg instanceof Promise   ? arg . then ( c ) : c ( arg ) ) , cerr , env , config ) ; <EOL> export const ClassExpression = ( e , c , cerr , env , config ) = > createClass ( e , c , cerr , env , config ) ; <EOL> export default { <EOL> CallExpression , <EOL> MemberExpression , <EOL> ArrowFunctionExpression , <EOL> FunctionExpression , <EOL> AssignmentExpression , <EOL> ObjectExpression , <EOL> Property , <EOL> BinaryExpression , <EOL> ArrayExpression , <EOL> NullValue , <EOL> NewExpression , <EOL> SequenceExpression , <EOL> LogicalExpression , <EOL> UpdateExpression , <EOL> UnaryExpression , <EOL> ThisExpression , <EOL> ConditionalExpression , <EOL> TemplateLiteral , <EOL> TaggedTemplateExpression , <EOL> SpreadElement , <EOL> AwaitExpression , <EOL> ClassExpression <EOL> } ; </s>
