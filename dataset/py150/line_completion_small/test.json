{"id": 51, "input": "<s> import threading <EOL> import IECore <EOL> import Gaffer <EOL> import GafferUI <EOL> import GafferImage <EOL> __all__ = [ ] <EOL> Gaffer . Metadata . registerNode ( <EOL> GafferImage . Display , <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> plugs = { <EOL> \"<STR_LIT:port>\" : [ <EOL> \"<STR_LIT:description>\" , <EOL> \"\"\"<STR_LIT>\"\"\" , <EOL> ] , <EOL> } <EOL> ) <EOL> __plugsPendingUpdate = [ ] <EOL> __plugsPendingUpdateLock = threading . Lock ( ) <EOL> def __scheduleUpdate ( plug , force = False ) : <EOL> if not force : <EOL> global __plugsPendingUpdate <EOL> global __plugsPendingUpdateLock <EOL> with __plugsPendingUpdateLock : <EOL> for p in __plugsPendingUpdate : <EOL> if plug . isSame ( p ) : <EOL> return <EOL> __plugsPendingUpdate . append ( plug ) <EOL> GafferUI . EventLoop . executeOnUIThread ( lambda : __update ( plug ) ) <EOL> def __update ( plug ) : <EOL> node = plug . node ( ) <EOL> if node : <EOL> updateCountPlug = node [ \"<STR_LIT>\" ] <EOL> updateCountPlug . setValue ( updateCountPlug . getValue ( )", "gt": ""}
{"id": 40753, "input": "<s> import re , operator <EOL> def str_find_all ( str , ch ) : <EOL> result = [ ] <EOL> index = <NUM_LIT:0> <EOL> while index >= <NUM_LIT:0> : <EOL> index = str . find ( ch , index ) <EOL> if index >= <NUM_LIT:0> : <EOL> result . append ( index ) <EOL> index += <NUM_LIT:1> <EOL> return result <EOL> word_pattern = re . compile ( \"<STR_LIT>\" ) <EOL> def markwords ( str , iswordfun ) : <EOL> markers = { True : \"<STR_LIT:x>\" , False : \"<STR_LIT:o>\" } <EOL> return \"<STR_LIT>\" . join ( [ markers [ iswordfun ( ch ) ] for ch in str ] ) <EOL> def split_words ( str , iswordfun ) : <EOL> return [ x for x in word_pattern . split ( markwords ( str , iswordfun ) ) if x != \"<STR_LIT>\" ] <EOL> def mark_start_segment ( str , is_segment ) : <EOL> def mark_start ( s ) : <EOL> if s [ <NUM_LIT:0> : <NUM_LIT:1> ] == \"<STR_LIT:x>\" : <EOL> return \"<STR_LIT:s>\" + s [ <NUM_LIT:1> : ] <EOL> else : <EOL> return s <EOL> return \"<STR_LIT>\" . join ( map ( mark_start , split_words ( str , is_segment ) ) ) <EOL> def mark_end_segment ( str , is_segment ) : <EOL> def mark_start ( s ) : <EOL> if s [ <NUM_LIT:0> : <NUM_LIT:1> ] == \"<STR_LIT:x>\" : <EOL> return s [ : - <NUM_LIT:1> ] + \"<STR_LIT:s>\" <EOL> else : <EOL> return s <EOL> return \"<STR_LIT>\" . join ( map ( mark_start , split_words ( str , is_segment ) ) ) <EOL> def mark_start_segment_index ( str , is_segment ) : <EOL> return str_find_all ( mark_start_segment ( str , is_segment ) , \"<STR_LIT:s>\" ) <EOL> def mark_end_segment_index ( str , is_segment ) : <EOL> return [ x + <NUM_LIT:1> for x in str_find_all ( mark_end_segment ( str , is_segment ) , \"<STR_LIT:s>\" ) ] <EOL> def is_word_token ( str ) : <EOL> return not is_non_word_token ( str ) <EOL> def is_non_word_token ( str ) : <EOL> if len ( str ) != <NUM_LIT:1> or str in \"<STR_LIT>\" : <EOL> return True <EOL> else : <EOL> return False <EOL> def next_start_segment ( str , is_segment ) : <EOL> str = \"<STR_LIT>\" . join ( str ) <EOL> result = [ ] <EOL> for start in mark_start_segment_index ( str , is_segment ) : <EOL> result [ len ( result ) : start ] = [ start for x in range ( start - len ( result ) ) ] <EOL> result [ len ( result ) : len ( str ) ] = [ len ( str ) for x in range ( len ( str ) - len ( result ) + <NUM_LIT:1> ) ] <EOL> return result <EOL> def next_end_segment ( str , is_segment ) : <EOL> str = \"<STR_LIT>\" . join ( str ) <EOL> result = [ ] <EOL> for start in mark_end_segment_index ( str , is_segment ) : <EOL> result [ len ( result ) : start ] = [ start for x in range ( start -", "gt": ""}
{"id": 32889, "input": "<s> import unittest <EOL> import pymel . internal . startup <EOL> class TestGetMayaVersion ( unittest . TestCase ) : <EOL> versions = [ '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' , '<STR_LIT>' ] <EOL> extensions = [ <NUM_LIT:1> , <NUM_LIT:2> , <NUM_LIT> ] <EOL>", "gt": ""}
{"id": 49349, "input": "<s> import time <EOL> import logging <EOL> import datetime <EOL> from django . db import transaction <EOL> from django . utils . encoding import smart_unicode <EOL> from jellyroll . models import Item , CodeRepository , CodeCommit <EOL> from jellyroll . providers import utils <EOL> try : <EOL> import pysvn <EOL> except ImportError : <EOL> pysvn = None <EOL> log = logging . getLogger ( \"<STR_LIT>\" ) <EOL> def enabled ( ) : <EOL> ok = pysvn is not None <EOL> if not ok : <EOL> log . warn ( \"<STR_LIT>\" <EOL> \"<STR_LIT>\" ) <EOL> return ok <EOL> def update ( ) : <EOL> for repository in CodeRepository . objects . filter ( type = \"<STR_LIT>\" ) : <EOL> _update_repository ( repository ) <EOL> def _update_repository ( repository ) : <EOL> source_identifier = \"<STR_LIT>\" %", "gt": ""}
{"id": 27038, "input": "<s> import os <EOL> import os . path as osp <EOL> import textwrap <EOL> import waflib . Utils <EOL> import waflib . Logs as msg <EOL> from waflib . Configure import conf <EOL> _heptooldir = osp . dirname ( osp . abspath ( __file__ ) ) <EOL> def options ( opt ) : <EOL> opt . load ( '<STR_LIT>' , tooldir = _heptooldir ) <EOL> opt . add_option ( <EOL> '<STR_LIT>' , <EOL> default = None , <EOL> help = \"<STR_LIT>\" ) <EOL> return <EOL> def configure ( conf ) : <EOL> conf . load ( '<STR_LIT>' , tooldir = _heptooldir ) <EOL> return <EOL> @ conf <EOL> def find_cmake ( ctx , ** kwargs ) : <EOL> if not ctx . env . HWAF_FOUND_C_COMPILER : <EOL> ctx . fatal ( '<STR_LIT>' ) <EOL> pass <EOL>", "gt": ""}
{"id": 42397, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import sys <EOL> from pypy . objspace . flow . model import Block <EOL> from pypy . objspace . flow . model import traverse <EOL> def ordered_blocks ( graph ) : <EOL> allblocks = [ ] <EOL> def visit ( block ) : <EOL> if isinstance ( block , Block ) : <EOL> if block . operations : <EOL> ofs = block . operations [ <NUM_LIT:0> ] . offset <EOL> else : <EOL> ofs = sys . maxint <EOL> if block . inputargs : <EOL> txt = str ( block . inputargs [ <NUM_LIT:0> ] ) <EOL> else : <EOL> txt = \"<STR_LIT>\" <EOL> allblocks . append ( ( ofs , txt , block ) ) <EOL> traverse ( visit , graph ) <EOL> allblocks . sort ( ) <EOL> return [ block for ofs , txt , block in allblocks ] <EOL> class UniqueList ( list ) : <EOL> def __init__ ( self , * args , ** kwds ) : <EOL> list . __init__ ( self , * args , ** kwds ) <EOL> self . dic = { } <EOL> def append1 ( self , arg ) : <EOL> try : <EOL> self . dic [ arg ] <EOL> except KeyError : <EOL> self . dic [ arg ] = <NUM_LIT:1> <EOL> list . append ( self , arg ) <EOL> except TypeError : <EOL> if arg not in self : <EOL> list . append ( self , arg ) <EOL> def builtin_base ( obj ) : <EOL> typ = type ( obj ) <EOL> return builtin_type_base ( typ ) <EOL> def builtin_type_base ( typ ) : <EOL> from copy_reg import _HEAPTYPE <EOL> while typ . __flags__ & _HEAPTYPE : <EOL> typ = typ . __base__ <EOL> return typ <EOL> def c_string ( s ) : <EOL> return '<STR_LIT>' % ( s . replace ( '<STR_LIT:\\\\>' , '<STR_LIT>' ) . replace ( '<STR_LIT:\">' , '<STR_LIT>' ) , ) <EOL> def uniquemodulename ( name , SEEN = { } ) : <EOL> i = <NUM_LIT:0> <EOL> while True : <EOL> i += <NUM_LIT:1> <EOL> result = '<STR_LIT>' % ( name , i ) <EOL> if result not in SEEN : <EOL> SEEN [ result ] = True <EOL> return result <EOL> C_IDENTIFIER = '<STR_LIT>' . join ( [ ( ( '<STR_LIT:0>' <= chr ( i ) <= '<STR_LIT>' or <EOL> '<STR_LIT:a>' <= chr ( i ) <= '<STR_LIT:z>' or <EOL> '<STR_LIT:A>' <= chr ( i ) <= '<STR_LIT>' ) and chr ( i ) or '<STR_LIT:_>' ) <EOL> for i in range ( <NUM_LIT> ) ] ) <EOL> class NameManager ( object ) : <EOL> def __init__ ( self , global_prefix = '<STR_LIT>' , number_sep = '<STR_LIT:_>' ) : <EOL> self . seennames = { } <EOL> self . scope = <NUM_LIT:0> <EOL> self . scopelist = [ ] <EOL> self . global_prefix = global_prefix <EOL> self . number_sep = number_sep <EOL> def make_reserved_names", "gt": ""}
{"id": 8256, "input": "<s> import time <EOL> import unittest <EOL> from robotide . robotapi import TestCaseFile <EOL> from robotide . controller . filecontrollers import TestCaseFileController <EOL> from resources import COMPLEX_SUITE_PATH <EOL> from nose . tools import assert_equals , assert_true <EOL> class TestCaseAndUserKeywordCopyingTest ( unittest . TestCase ) : <EOL> controller = TestCaseFileController ( <EOL> TestCaseFile ( source = COMPLEX_SUITE_PATH ) . populate ( ) ) <EOL> def test_test_case_copy ( self ) : <EOL> test = self . controller . tests [ <NUM_LIT:0> ] <EOL> copy = test . copy ( '<STR_LIT>' ) <EOL> assert_equals ( copy . name , '<STR_LIT>' ) <EOL> for orig , copied in zip ( test . settings , copy . settings ) : <EOL> assert_equals ( orig . value , copied . value ) <EOL> assert_true ( copied is not orig ) <EOL> assert_equals ( test . steps , copy . steps ) <EOL> assert_true ( test . steps is not copy . steps ) <EOL> def test_keyword_copy ( self ) : <EOL> test =", "gt": ""}
{"id": 45314, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> __author__ = '<STR_LIT>' <EOL> class TreeNode : <EOL> def __init__ ( self , x ) : <EOL> self . val = x <EOL> self . left = None <EOL> self . right = None <EOL> class ListNode : <EOL> def __init__ ( self , x ) : <EOL> self . val = x <EOL> self . next = None <EOL> class Solution : <EOL> def __init__ ( self ) : <EOL> self . current_node = None <EOL> def sortedListToBST ( self , head ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> if not head : <EOL> return head <EOL> self . current_node = head <EOL> length = self . getLength ( head ) <EOL> return self", "gt": ""}
{"id": 19145, "input": "<s> \"\"\"<STR_LIT>\"\"\" <EOL> import yaki . Engine , yaki . Store <EOL> from yaki . Utils import * <EOL> from BeautifulSoup import * <EOL> import re , urlparse <EOL> template = \"\"\"<STR_LIT>\"\"\" <EOL> class FlashMovieWikiPlugin ( yaki . Plugins . WikiPlugin ) : <EOL> def __init__ ( self , registry , webapp ) : <EOL> self . ac = webapp . getContext ( ) <EOL> registry . register ( '<STR_LIT>' , self , '<STR_LIT>' , '<STR_LIT>' ) <EOL> def", "gt": ""}
{"id": 27415, "input": "<s> from . . excel_comparsion_test import ExcelComparisonTest <EOL> from ... workbook import Workbook <EOL> class TestCompareXLSXFiles ( ExcelComparisonTest ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> def setUp ( self ) : <EOL> self . maxDiff = None <EOL> filename = '<STR_LIT>' <EOL> test_dir = '<STR_LIT>' <EOL> self . got_filename = test_dir + '<STR_LIT>' + filename <EOL> self . exp_filename = test_dir + '<STR_LIT>' + filename <EOL> self . ignore_files = [ ] <EOL> self . ignore_elements = { '<STR_LIT>' : [ '<STR_LIT>' ] } <EOL> def test_create_file ( self ) : <EOL> \"\"\"<STR_LIT>\"\"\" <EOL> workbook = Workbook ( self . got_filename ) <EOL> worksheet = workbook . add_worksheet ( ) <EOL> chart = workbook . add_chart ( { '<STR_LIT:type>' : '<STR_LIT>' } ) <EOL> date_format = workbook . add_format ( { '<STR_LIT>' : <NUM_LIT> } ) <EOL> chart . axis_ids = [ <NUM_LIT> , <NUM_LIT> ] <EOL> data = [ <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> [ <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> , <NUM_LIT> ] , <EOL> ] <EOL> for row in range ( <NUM_LIT:5> ) : <EOL> worksheet . write ( row , <NUM_LIT:0> , data [ <NUM_LIT:0> ] [ row ] , date_format ) <EOL> worksheet . write ( row , <NUM_LIT:1> , data [ <NUM_LIT:1> ] [ row ] ) <EOL> worksheet . write ( row , <NUM_LIT:2> , data [ <NUM_LIT:2> ] [ row ] ) <EOL> worksheet . write ( row , <NUM_LIT:3> , data [ <NUM_LIT:3> ] [ row ] ) <EOL> worksheet . set_column ( '<STR_LIT>' ,", "gt": ""}